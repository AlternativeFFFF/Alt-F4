<!DOCTYPE html>
<html lang="it" class="it">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Alt-F4 #24 - Creating Memories</title>
	<!-- Meta -->
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">

	<!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="Alt-F4 #24 - Creating Memories">
<meta name="author" content="pocarski">
<meta property="og:locale" content="en">
<meta name="description" content="This week, we’re following up on pocarski’s piece from last week that was all about how to build a computer inside Factorio using only belts. This time, we’re trying to teach it how to remember things. Let’s see how that goes. Belt-only Computing, Part 2: Never Forget pocarski This week, I’ll continue with the continuation of my article about belt-only computing. I highly advise going back to the previous issue for a refresher. A short note before we begin: during the week Discord user BlueCheetah#7844 made significant layout improvements to my adder circuit, it is now slightly longer, but four tiles wide. Here’s an image of it doing the same math as last week: With that out of the way, let’s get down to business. Last time, we explored adding numbers using only belts and splitters, and this week we will look at something just as important when it comes to computing: memory. The ability to add numbers is neat, but ultimately useless if there is no way to store the instructions or the result. Inside a CPU, the results of addition are remembered and then, after some manipulation, fed back to the same adders that just calculated them. This allows for pretty much every imaginable mathematical operation. Just like last week, everyone is welcome to have a hands-on experience with a blueprint book with all the circuits from this article. The multiplexer To start off, we will introduce a new circuit: the multiplexer. A multiplexer has two data inputs A and B, one pointer input P and one output O. Here is the truth table for this multiplexer (“-“ means input doesn’t affect output): A B P O 0 - 0 0 1 - 0 1 - 0 1 0 - 1 1 1 Input P effectively chooses which of the data inputs should be passed to the output. If P is 0, our output will equal the value of A, and if it is 1, our output will be the value of B. Now, to actually build this, we can make use of AND gates. They allow us to selectively ignore an input. We can choose whether we want to pass through an input or not by simply enabling or disabling the gate’s other input. With this in mind, we can reimagine the multiplexer as (A AND NOT P) OR (B AND P). All of those are elements that we’re already familiar with, which means a multiplexer can be built like this: &lt;/source&gt; Belt multiplexer This is simply a duplicator-NOT circuit and two AND gates. We also need some item swappers, to match all input and output item types. Basic memory cell Memory cells sound very complicated at first. A circuit that remembers an input? Surely that would need some kind of storage, and how do you make it output without the storage running out? This is where our new friend the multiplexer comes in. What happens if we loop the output all the way around and feed it into its own input A? The answer is: magic happens! &lt;/source&gt; Looped multiplexer As you can see, with this single change we transformed the multiplexer into a very basic memory cell. What used to be input B is now the sole data input into the memory cell, and what used to be input P is now the “write” input. This circuit doesn’t have an output since we looped it, so we fix that by adding a duplicator (and also combining a swapper with an AND, just like last time): &lt;/source&gt; Basic latch This circuit we just made is called a D latch. It has two inputs: D for “Data”, and E for “Enable”. Unlike in electronic computers, we have to keep E turned on for quite some time, since the items need to make their way back to the beginning for the output to become stable. However, a D latch has a pretty significant issue, that being, while input E is on, the output completely copies input D, effectively turning the entire thing into a fancy wire. We need to guarantee output stability, and for that, we need something more than a simple D latch. Master-slave memory cell Many problems can be solved by just building another copy, and the D latch’s issue is no exception. We duplicate and invert input E, and feed its inversion into another D latch’s enable input. Then, we make the first latch’s output go into the second one’s data input. The inversion here is done by introducing a third item type, which gets overridden by the enable input. Just like last week, the two sides of belts come to the rescue, and we don’t actually need to build a whole other copy, we can just do some clever looping: &lt;/source&gt; Spread out master-slave memory cell This double latch system creates a sort of staircase for our data value, where it’s allowed on the first step when input E turns on, and allowed to keep going only after it turns back off. This protects the output from changing until we have completed a cycle. Now we can rearrange everything to make a compact module: &lt;/source&gt; Compact memory cell Interestingly, it has the exact same dimensions as last week’s adder module (or it used to until BlueCheetah came along). Talk about a satisfying coincidence! Final note Now that we have an adder and memory, we’re all set to build a CPU. Of course, we need a clock to run everything, but that is as simple as a half-full belt loop with a duplicator. The arithmetic logic unit (ALU) is just a bunch of adders looping back into themselves through a register, which in itself is just a bunch of memory cells. My knowledge of computer science is not extensive enough to explain everything fully, so please consider checking out letao12 on YouTube, as it was his series that inspired me to give this belt-based logic a try. Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started!">
<meta property="og:description" content="This week, we’re following up on pocarski’s piece from last week that was all about how to build a computer inside Factorio using only belts. This time, we’re trying to teach it how to remember things. Let’s see how that goes. Belt-only Computing, Part 2: Never Forget pocarski This week, I’ll continue with the continuation of my article about belt-only computing. I highly advise going back to the previous issue for a refresher. A short note before we begin: during the week Discord user BlueCheetah#7844 made significant layout improvements to my adder circuit, it is now slightly longer, but four tiles wide. Here’s an image of it doing the same math as last week: With that out of the way, let’s get down to business. Last time, we explored adding numbers using only belts and splitters, and this week we will look at something just as important when it comes to computing: memory. The ability to add numbers is neat, but ultimately useless if there is no way to store the instructions or the result. Inside a CPU, the results of addition are remembered and then, after some manipulation, fed back to the same adders that just calculated them. This allows for pretty much every imaginable mathematical operation. Just like last week, everyone is welcome to have a hands-on experience with a blueprint book with all the circuits from this article. The multiplexer To start off, we will introduce a new circuit: the multiplexer. A multiplexer has two data inputs A and B, one pointer input P and one output O. Here is the truth table for this multiplexer (“-“ means input doesn’t affect output): A B P O 0 - 0 0 1 - 0 1 - 0 1 0 - 1 1 1 Input P effectively chooses which of the data inputs should be passed to the output. If P is 0, our output will equal the value of A, and if it is 1, our output will be the value of B. Now, to actually build this, we can make use of AND gates. They allow us to selectively ignore an input. We can choose whether we want to pass through an input or not by simply enabling or disabling the gate’s other input. With this in mind, we can reimagine the multiplexer as (A AND NOT P) OR (B AND P). All of those are elements that we’re already familiar with, which means a multiplexer can be built like this: &lt;/source&gt; Belt multiplexer This is simply a duplicator-NOT circuit and two AND gates. We also need some item swappers, to match all input and output item types. Basic memory cell Memory cells sound very complicated at first. A circuit that remembers an input? Surely that would need some kind of storage, and how do you make it output without the storage running out? This is where our new friend the multiplexer comes in. What happens if we loop the output all the way around and feed it into its own input A? The answer is: magic happens! &lt;/source&gt; Looped multiplexer As you can see, with this single change we transformed the multiplexer into a very basic memory cell. What used to be input B is now the sole data input into the memory cell, and what used to be input P is now the “write” input. This circuit doesn’t have an output since we looped it, so we fix that by adding a duplicator (and also combining a swapper with an AND, just like last time): &lt;/source&gt; Basic latch This circuit we just made is called a D latch. It has two inputs: D for “Data”, and E for “Enable”. Unlike in electronic computers, we have to keep E turned on for quite some time, since the items need to make their way back to the beginning for the output to become stable. However, a D latch has a pretty significant issue, that being, while input E is on, the output completely copies input D, effectively turning the entire thing into a fancy wire. We need to guarantee output stability, and for that, we need something more than a simple D latch. Master-slave memory cell Many problems can be solved by just building another copy, and the D latch’s issue is no exception. We duplicate and invert input E, and feed its inversion into another D latch’s enable input. Then, we make the first latch’s output go into the second one’s data input. The inversion here is done by introducing a third item type, which gets overridden by the enable input. Just like last week, the two sides of belts come to the rescue, and we don’t actually need to build a whole other copy, we can just do some clever looping: &lt;/source&gt; Spread out master-slave memory cell This double latch system creates a sort of staircase for our data value, where it’s allowed on the first step when input E turns on, and allowed to keep going only after it turns back off. This protects the output from changing until we have completed a cycle. Now we can rearrange everything to make a compact module: &lt;/source&gt; Compact memory cell Interestingly, it has the exact same dimensions as last week’s adder module (or it used to until BlueCheetah came along). Talk about a satisfying coincidence! Final note Now that we have an adder and memory, we’re all set to build a CPU. Of course, we need a clock to run everything, but that is as simple as a half-full belt loop with a duplicator. The arithmetic logic unit (ALU) is just a bunch of adders looping back into themselves through a register, which in itself is just a bunch of memory cells. My knowledge of computer science is not extensive enough to explain everything fully, so please consider checking out letao12 on YouTube, as it was his series that inspired me to give this belt-based logic a try. Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started!">
<link rel="canonical" href="https://alt-f4.blog/it/ALTF4-24/">
<meta property="og:url" content="https://alt-f4.blog/ALTF4-24/">
<meta property="og:site_name" content="Alternative Friday Factorio Fan Facts">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-02-19T00:00:00+00:00">
<script type="application/ld+json">
{"dateModified":"2021-02-19T00:00:00+00:00","datePublished":"2021-02-19T00:00:00+00:00","author":{"@type":"Person","name":"pocarski"},"description":"This week, we’re following up on pocarski’s piece from last week that was all about how to build a computer inside Factorio using only belts. This time, we’re trying to teach it how to remember things. Let’s see how that goes. Belt-only Computing, Part 2: Never Forget pocarski This week, I’ll continue with the continuation of my article about belt-only computing. I highly advise going back to the previous issue for a refresher. A short note before we begin: during the week Discord user BlueCheetah#7844 made significant layout improvements to my adder circuit, it is now slightly longer, but four tiles wide. Here’s an image of it doing the same math as last week: With that out of the way, let’s get down to business. Last time, we explored adding numbers using only belts and splitters, and this week we will look at something just as important when it comes to computing: memory. The ability to add numbers is neat, but ultimately useless if there is no way to store the instructions or the result. Inside a CPU, the results of addition are remembered and then, after some manipulation, fed back to the same adders that just calculated them. This allows for pretty much every imaginable mathematical operation. Just like last week, everyone is welcome to have a hands-on experience with a blueprint book with all the circuits from this article. The multiplexer To start off, we will introduce a new circuit: the multiplexer. A multiplexer has two data inputs A and B, one pointer input P and one output O. Here is the truth table for this multiplexer (“-“ means input doesn’t affect output): A B P O 0 - 0 0 1 - 0 1 - 0 1 0 - 1 1 1 Input P effectively chooses which of the data inputs should be passed to the output. If P is 0, our output will equal the value of A, and if it is 1, our output will be the value of B. Now, to actually build this, we can make use of AND gates. They allow us to selectively ignore an input. We can choose whether we want to pass through an input or not by simply enabling or disabling the gate’s other input. With this in mind, we can reimagine the multiplexer as (A AND NOT P) OR (B AND P). All of those are elements that we’re already familiar with, which means a multiplexer can be built like this: &lt;/source&gt; Belt multiplexer This is simply a duplicator-NOT circuit and two AND gates. We also need some item swappers, to match all input and output item types. Basic memory cell Memory cells sound very complicated at first. A circuit that remembers an input? Surely that would need some kind of storage, and how do you make it output without the storage running out? This is where our new friend the multiplexer comes in. What happens if we loop the output all the way around and feed it into its own input A? The answer is: magic happens! &lt;/source&gt; Looped multiplexer As you can see, with this single change we transformed the multiplexer into a very basic memory cell. What used to be input B is now the sole data input into the memory cell, and what used to be input P is now the “write” input. This circuit doesn’t have an output since we looped it, so we fix that by adding a duplicator (and also combining a swapper with an AND, just like last time): &lt;/source&gt; Basic latch This circuit we just made is called a D latch. It has two inputs: D for “Data”, and E for “Enable”. Unlike in electronic computers, we have to keep E turned on for quite some time, since the items need to make their way back to the beginning for the output to become stable. However, a D latch has a pretty significant issue, that being, while input E is on, the output completely copies input D, effectively turning the entire thing into a fancy wire. We need to guarantee output stability, and for that, we need something more than a simple D latch. Master-slave memory cell Many problems can be solved by just building another copy, and the D latch’s issue is no exception. We duplicate and invert input E, and feed its inversion into another D latch’s enable input. Then, we make the first latch’s output go into the second one’s data input. The inversion here is done by introducing a third item type, which gets overridden by the enable input. Just like last week, the two sides of belts come to the rescue, and we don’t actually need to build a whole other copy, we can just do some clever looping: &lt;/source&gt; Spread out master-slave memory cell This double latch system creates a sort of staircase for our data value, where it’s allowed on the first step when input E turns on, and allowed to keep going only after it turns back off. This protects the output from changing until we have completed a cycle. Now we can rearrange everything to make a compact module: &lt;/source&gt; Compact memory cell Interestingly, it has the exact same dimensions as last week’s adder module (or it used to until BlueCheetah came along). Talk about a satisfying coincidence! Final note Now that we have an adder and memory, we’re all set to build a CPU. Of course, we need a clock to run everything, but that is as simple as a half-full belt loop with a duplicator. The arithmetic logic unit (ALU) is just a bunch of adders looping back into themselves through a register, which in itself is just a bunch of memory cells. My knowledge of computer science is not extensive enough to explain everything fully, so please consider checking out letao12 on YouTube, as it was his series that inspired me to give this belt-based logic a try. Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started!","mainEntityOfPage":{"@type":"WebPage","@id":"https://alt-f4.blog/ALTF4-24/"},"url":"https://alt-f4.blog/ALTF4-24/","@type":"BlogPosting","headline":"Alt-F4 #24 - Creating Memories","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
	

	
	  <meta property="og:image" content="https://alt-f4.blog/assets/ALTF4/24/thumbnail.jpg">
	  <meta name="twitter:image" content="https://alt-f4.blog/assets/ALTF4/24/thumbnail.jpg">
	

	<!-- CSS & fonts -->
	<link href="/it/assets/GLOBAL/css/titillium-web.css" rel="stylesheet">
	<link rel="stylesheet" href="/it/assets/GLOBAL/css/style.css">
	<link rel="stylesheet" href="/it/assets/GLOBAL/css/spidertron.css">
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.css" rel="stylesheet" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,400italic%7CSignika:700,300,400,600" rel="stylesheet" type="text/css">

	<link href="/it/assets/GLOBAL/img/favicon.ico" rel="icon" type="image/x-icon">
	<link href="/it/assets/GLOBAL/img/favicon.ico" rel="shortcut icon" type="image/x-icon">

	<!-- RSS -->
	<link href="/it/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed">

	<script src="/assets/GLOBAL/js/spidertron.js"></script>
	<script src="/assets/GLOBAL/js/localization.js"></script>
	<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
</head>


  <body>
    <!-- Navigation Bar -->
    <nav id="top" class="top-bar">
	<div class="top-bar-inner flex flex-space-between">
		<div class="sites links flex">
			<a href="/it/" class="sites-current">
				<div id="navbar-logo" role="img" aria-label="Alt-F4 Logo"></div>
			</a>
			<a href="https://alt-f4.blog/it/discord" class="">Discord</a>
			<span class="separator">|</span>
			<a href="https://factorio.com/blog" class="">FFF</a>
		</div>
		<div class="sites links flex hide-tag-line">
			<em>Il seguito degli amati Factorio Friday Facts gestito dalla community</em>
		</div>
		<div class="dropdown flex-end">
			<a class="button flex flex-space-between" href="#">
				<i class="fas fa-language"></i>
			</a>
			<div class="submenu">
				
				<a class="button lang-button" href="/../ALTF4-24/" onclick="setLanguage('en')">English</a>
				
				<a class="button lang-button" href="/cs/ALTF4-24/" onclick="setLanguage('cs')">Čeština</a>
				
				<a class="button lang-button" href="/de/ALTF4-24/" onclick="setLanguage('de')">Deutsch</a>
				
				<a class="button lang-button" href="/es/ALTF4-24/" onclick="setLanguage('es')">Español</a>
				
				<a class="button lang-button" href="/fr/ALTF4-24/" onclick="setLanguage('fr')">Français</a>
				
				<a class="button button-green lang-button" href="/it/ALTF4-24/" onclick="setLanguage('it')">Italiano</a>
				
				<a class="button lang-button" href="/nl/ALTF4-24/" onclick="setLanguage('nl')">Nederlands</a>
				
				<a class="button lang-button" href="/pt-br/ALTF4-24/" onclick="setLanguage('pt-br')">Português Brasileiro</a>
				
				<a class="button lang-button" href="/ru/ALTF4-24/" onclick="setLanguage('ru')">Русский</a>
				
				<a class="button lang-button" href="/zh/ALTF4-24/" onclick="setLanguage('zh')">中文</a>
				
			</div>
		</div>
	</div>
</nav>


    <!-- Main content -->
    <div class="container">
      <div class="container-inner">
        <div class="small-center"></div>
        <!-- Posts -->
        <article class="panel blog-post">
	
	<h1 class="page-title-headder">Alt-F4 #24 - Creating Memories  <author>19-02-2021</author>
</h1>
	
	
	<div class="panel-inset mb0">
		
Scritto da <em>pocarski</em>,



editato da <em>stringweasel, Nanogamer7, Conor_, Therenas, Firerazer</em>








	</div>
	
	<div class="panel-inset-lighter mt0">
		<div class="post-header">
  <div class="panel">
    <div class="outer">
      <img class="inner" src="/assets/ALTF4/24/thumbnail.jpg" alt="" style="margin: 1px;">
    </div>
  </div>
  <details class="panel toc">
    <summary>
      <h2>Tabella dei Contenuti</h2>
    </summary>
    <div class="panel-inset mb0">
      <ul>
  <li>
<a href="#belt-only-computing-part-2-never-forget-pocarski">Belt-only Computing, Part 2: Never Forget <author>pocarski</author></a>
    <ul>
      <li><a href="#the-multiplexer">The multiplexer</a></li>
      <li><a href="#basic-memory-cell">Basic memory cell</a></li>
      <li><a href="#master-slave-memory-cell">Master-slave memory cell</a></li>
      <li><a href="#final-note">Final note</a></li>
    </ul>
  </li>
  <li><a href="#contributing">Contributing</a></li>
</ul>

    </div>
  </details>
</div>


<div class="center banner">
  <p>Siamo spiacenti, ma questo articolo non è ancora stato tradotto in Italiano, perciò lo state vedendo in Inglese. Se volete darci una mano a rimediare, vi invitiamo ad entrare nel server <a href="https://alt-f4.blog/it/discord">Discord</a> di Alt-F4. Grazie per la pazienza!</p>

</div>



<p>This week, we’re following up on pocarski’s piece from last week that was all about how to build a computer inside Factorio using only belts. This time, we’re trying to teach it how to remember things. Let’s see how that goes.</p>
      <h2 id="belt-only-computing-part-2-never-forget-pocarski">
        
        
            <a href="#belt-only-computing-part-2-never-forget-pocarski" class="anchor" style="text-decoration: none;">Belt-only Computing, Part 2: Never Forget <author>pocarski</author></a>
          
        
      </h2>
    

<p>This week, I’ll continue with the continuation of my article about belt-only computing. I highly advise going back to the <a href="https://alt-f4.blog/it/ALTF4-23/#belt-only-computing-part-1-not-so-quick-maths-pocarski">previous issue</a> for a refresher.</p>

<p>A short note before we begin: during the week <a href="https://alt-f4.blog/it/discord">Discord</a> user <em>BlueCheetah#7844</em> made significant layout improvements to my adder circuit, it is now slightly longer, but four tiles wide. Here’s an image of it doing the same math as last week:</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      
        <img src="https://media.alt-f4.blog/ALTF4/24/improved-8-bit-adder.jpg" alt="Better adder" style="max-width: ; max-height:  ">
        
        
      
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>With that out of the way, let’s get down to business. Last time, we explored adding numbers using only belts and splitters, and this week we will look at something just as important when it comes to computing: memory. The ability to add numbers is neat, but ultimately useless if there is no way to store the instructions or the result. Inside a CPU, the results of addition are remembered and then, after some manipulation, fed back to the same adders that just calculated them. This allows for pretty much every imaginable mathematical operation.</p>

<p>Just like last week, everyone is welcome to have a hands-on experience with a <a href="https://media.alt-f4.blog/ALTF4/24/belt-computer-blueprint-book-2.txt">blueprint book</a> with all the circuits from this article.</p>
      <h3 id="the-multiplexer">
        
        
            <a href="#the-multiplexer" class="anchor" style="text-decoration: none;">The multiplexer</a>
          
        
      </h3>
    

<p>To start off, we will introduce a new circuit: the <a href="https://en.wikipedia.org/wiki/Multiplexer">multiplexer</a>. A multiplexer has two data inputs <em>A</em> and <em>B</em>, one pointer input <em>P</em> and one output <em>O</em>. Here is the truth table for this multiplexer (“-“ means input doesn’t affect output):</p>

<table>
  <thead>
    <tr>
      <th>A</th>
      <th>B</th>
      <th>P</th>
      <th>O</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>-</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>-</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <td>-</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <td>-</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p><em>Input P</em> effectively chooses which of the data inputs should be passed to the output. If <em>P</em> is <code class="language-plaintext highlighter-rouge">0</code>, our output will equal the value of <em>A</em>, and if it is <code class="language-plaintext highlighter-rouge">1</code>, our output will be the value of <em>B</em>. Now, to actually build this, we can make use of AND gates. They allow us to selectively ignore an input. We can choose whether we want to pass through an input or not by simply enabling or disabling the gate’s other input. With this in mind, we can reimagine the multiplexer as <code class="language-plaintext highlighter-rouge">(A AND NOT P) OR (B AND P)</code>. All of those are elements that we’re already familiar with, which means a multiplexer can be built like this:</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 960px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/24/multiplexer.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Belt multiplexer
    </video>
    <figcaption></figcaption>
  </figure>
</p>

<p>This is simply a duplicator-NOT circuit and two AND gates. We also need some item swappers, to match all input and output item types.</p>
      <h3 id="basic-memory-cell">
        
        
            <a href="#basic-memory-cell" class="anchor" style="text-decoration: none;">Basic memory cell</a>
          
        
      </h3>
    

<p>Memory cells sound very complicated at first. A circuit that <em>remembers</em> an input? Surely that would need some kind of storage, and how do you make it output without the storage running out? This is where our new friend the multiplexer comes in. What happens if we loop the output all the way around and feed it into its own <em>input A</em>? The answer is: <em>magic happens!</em></p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 960px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/24/looped_mux.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Looped multiplexer
    </video>
    <figcaption></figcaption>
  </figure>
</p>

<p>As you can see, with this single change we transformed the multiplexer into a very basic memory cell. What used to be <em>input B</em> is now the sole data input into the memory cell, and what used to be <em>input P</em> is now the “write” input. This circuit doesn’t have an output since we looped it, so we fix that by adding a duplicator (and also combining a swapper with an AND, just like last time):</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 960px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/24/basic_latch.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Basic latch
    </video>
    <figcaption></figcaption>
  </figure>
</p>

<p>This circuit we just made is called a <strong>D latch</strong>. It has two inputs: <em>D</em> for “Data”, and <em>E</em> for “Enable”. Unlike in electronic computers, we have to keep <em>E</em> turned on for quite some time, since the items need to make their way back to the beginning for the output to become stable. However, a D latch has a pretty significant issue, that being, while <em>input E</em> is on, the output completely copies <em>input D</em>, effectively turning the entire thing into a fancy wire. We need to guarantee output stability, and for that, we need something more than a simple D latch.</p>
      <h3 id="master-slave-memory-cell">
        
        
            <a href="#master-slave-memory-cell" class="anchor" style="text-decoration: none;">Master-slave memory cell</a>
          
        
      </h3>
    

<p>Many problems can be solved by just building another copy, and the D latch’s issue is no exception. We duplicate and invert <em>input E</em>, and feed its inversion into another D latch’s enable input. Then, we make the first latch’s output go into the second one’s data input. The inversion here is done by introducing a third item type, which gets overridden by the enable input. Just like last week, the two sides of belts come to the rescue, and we don’t actually need to build a whole other copy, we can just do some clever looping:</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 960px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/24/spread_out_master-slave.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Spread out master-slave memory cell
    </video>
    <figcaption></figcaption>
  </figure>
</p>

<p>This double latch system creates a sort of staircase for our data value, where it’s allowed on the first step when <em>input E</em> turns on, and allowed to keep going only after it turns back off. This protects the output from changing until we have completed a cycle. Now we can rearrange everything to make a compact module:</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 960px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/24/compact_memory_cell.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Compact memory cell
    </video>
    <figcaption></figcaption>
  </figure>
</p>

<p>Interestingly, it has the exact same dimensions as last week’s adder module (or it used to until BlueCheetah came along). Talk about a satisfying coincidence!</p>
      <h3 id="final-note">
        
        
            <a href="#final-note" class="anchor" style="text-decoration: none;">Final note</a>
          
        
      </h3>
    

<p>Now that we have an adder and memory, we’re all set to build a CPU. Of course, we need a clock to run everything, but that is as simple as a half-full belt loop with a duplicator. The arithmetic logic unit (ALU) is just a bunch of adders looping back into themselves through a register, which in itself is just a bunch of memory cells. My knowledge of computer science is not extensive enough to explain everything fully, so please consider checking out <a href="https://www.youtube.com/channel/UC6BeS4toXnPJe-Kds9E_FEQ">letao12</a> on YouTube, as it was his series that inspired me to give this belt-based logic a try.</p>
      <h2 id="contributing">
        
        
            <a href="#contributing" class="anchor" style="text-decoration: none;">Contributing</a>
          
        
      </h2>
    

<p>As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the <a href="https://alt-f4.blog/it/discord">Discord</a> to get started!</p>





<script>
  (() => {
    if (window.innerWidth >= 720) {
      document.getElementsByClassName('toc')[0].setAttribute('open', '')
    }
  })()

  var slideIndex = 1;
  showSlides(slideIndex);

  function plusSlides(n) {
    showSlides(slideIndex += n);
  }

  function currentSlide(n) {
    showSlides(slideIndex = n);
  }

  function showSlides(n) {
    var i;
    var slides = document.getElementsByClassName("galleryItem");
    var dots = document.getElementsByClassName("galleryPreview");
    var captionText = document.getElementById("caption");
    if (n > slides.length) { slideIndex = 1 }
    if (n < 1) { slideIndex = slides.length }
    for (i = 0; i < slides.length; i++) {
      slides[i].style.display = "none";
    }
    for (i = 0; i < dots.length; i++) {
      dots[i].className = dots[i].className.replace(" active", "");
    }
    slides[slideIndex - 1].style.display = "block";
    dots[slideIndex - 1].className += " active";
    captionText.innerHTML = dots[slideIndex - 1].alt;
  }
</script>

		
<div class="flex flex-column flex-items-center mt8">
  
  <a class="button-green-right m4" style="width: 16em;" href="https://forums.factorio.com/viewtopic.php?f=5&t=96311">
    Discutine sui Forum di Factorio
  </a>
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://www.reddit.com/r/factorio/comments/lneq4q/altf4_24_creating_memories/">
    Discutine su Reddit
  </a>
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://alt-f4.blog/it/discord">
    Discutine su Discord
  </a>
  
</div>


	</div>
	<div class="panel-inset mb0 p4 flex">
		<div>
		<!-- Previous Button -->
		
		<a href="/it/ALTF4-23/" class="button square-sm"><i class="fas fa-angle-double-left"></i></a>
		
		<a class="button square-sm" href="/it/">
			<i class="fas fa-home"></i>
		</a>

		<!-- Next Button -->
		
		<a href="/it/ALTF4-25/" class="button square-sm">
			<i class="fas fa-angle-double-right"></i>
		</a>
		
		</div>
	</div>
</article>

      </div>
    </div>


    <!-- Footer -->
    <footer class="footer">
  <div class="footer-inner panel">

    <div class="footer-links panel-inset slots p1 mt0 mb0">
      <a href="/it/about" class="slot" title="About">
        <div class="slot-button">
          <i class="fas fa-info"></i>
        </div>
      </a>
      <a href="https://github.com/AlternativeFFFF/Alt-F4" class="slot" title="Github">
        <div class="slot-button">
          <i class="fab fa-github"></i>
        </div>
      </a>
      <a href="https://alt-f4.blog/it/discord" class="slot" title="Discord">
        <div class="slot-button">
          <i class="fab fa-discord"></i>
        </div>
      </a>
      <a href="/it/atom.xml" type="application/atom+xml" rel="alternate" class="slot" title="ATOM Feed">
        <div class="slot-button">
          <i class="fas fa-rss"></i>
        </div>
      </a>
      <a href="https://www.freelists.org/list/alt-f4" class="slot" title="Email Newsletter">
        <div class="slot-button">
          <i class="fas fa-envelope"></i>
        </div>
      </a>

      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
    </div>
    <div class="footer-rocket panel-inset m0">
      <div class="spidertron-center">
        <div id="spidertron" class="spidertron-home" data-spidertron-scale="0.6" data-spidertron-speed="400"></div>
      </div>
      <div class="shadow-overlay"></div>
      <div class="shadow-overlay-bottom"></div>
    </div>
    <div class="footer-copyright panel-inset m0">
      Questo è un progetto gestito dai fan e non direttamente dagli sviluppatori Wube Software Wube Software
    </div>
  </div>
</footer>

  </body>

</html>
