<!DOCTYPE html>
<html lang="it" class="it">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Alt-F4 #61 - Draftsman: A Python module for creating blueprints</title>
	<!-- Meta -->
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">

	<!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="Alt-F4 #61 - Draftsman: A Python module for creating blueprints">
<meta name="author" content="redruin1">
<meta property="og:locale" content="en">
<meta name="description" content="For this week’s issue of Alt-F4, we return to the roots of being a spiritual successor to the FFF by going deep on a technical topic. To that end, redruin1 presents his newest invention: Factorio Draftsman. Sure, there have been other projects trying to build a library for generating blueprints for the game, but this one tries to be the new gold standard. Motivations, technical details, and a few fun projects realized with it - all that, and more, this week! Draftsman redruin1 A couple months ago, I decided that I wanted to try my hand at making a self-expanding factory in Factorio. After seeing a number of impressive examples, I was inspired to have a go at the problem. I already had an outline of the logic, and how the factory would keep track of itself, as well as lofty ideas on impressive things that I could make it do. The only trouble was that I had actually never used combinators before, and I was planning on using them for the actual decision-making. That’s no problem, though: We just create a scrap world, switch to the editor and start playing around! 1 / 3 2 / 3 Any attempt to understand the meaningless scribbles of a madman will only result in disappointment and despair. 3 / 3 ROOKIE NUMBERS ❮ ❯ I may have gotten carried away a little. Here’s a CPU I made. This is the seventh (I think?) revision. It has a ROM, RAM, a stack, 256 registers, over 40 instructions, breakpoints and code stepping, hardware and software interrupts, as well as a generalized circuit interface to interact with other machines. Ah, Factorio. One of the only games where you literally get smarter on repeated playthroughs. Ironically, I’m not actually here to talk about any of this. This is all just foreshadowing. I was starting the second revision of the computer and I wanted a more compact ROM. I came up with the design below, which has the capability of storing true 32-bit numbers and can store 4 KiB of data per row: Everything starts somewhere. The ROM is very dense, but it functions on a system where each value is split into and stored as two 16-bit numbers, which are then recombined on output. ROMs are normally tedious to create, manually encoding each signal you want by hand, one at a time, but this design was even more involved. I now had to split, bitwise AND, bitwise right-shift, and populate not one signal, but two, in two different specific locations, making sure that they both had the correct value and signal type. Needless to say, it was going to be painful to set tens of values, let alone hundreds, or the thousands the machine was capable of storing. The solution? Get a computer to do it for me. It can stomach this task far better than I ever could, and can do it way faster as well. Factorio’s blueprint string import function can take any correctly formatted string; all I had to do was create this text string to my specification with the data I wanted and I could just paste it where needed. This concept is not new, at all. Even a cursory search will turn up numerous examples of this used in practice: factorio-blueprint NPM module by demipixel, justarandomgeek’s compiler for his massive combinator computer, a generic combinator instruction language by Jobarion, image-to-blueprint converters, etc. The list is extensive. With all these examples, I was hoping that I could find some similarities with one of them and use that as a baseline for my solution to avoid “retreading” the same ground. Something troubled me about the solutions that were available though: They all had problems! Many implementations were highly specific to the domain they were written for; a combinator computer compiler script was not going to be portable for many other purposes than compiling code for a specific combinator computer. They lacked a unified language; many were written in Lua, some in Python, another in JavaScript, one in C++, etc. This meant that each one had to write their own implementations for the same operations, instead of just having someone write the implementation they need and making it available to others. Many of them were written for versions of Factorio that are now severely out of date. Documentation for a lot of these modules was sparse and sporadic, which turns off users like me who want to know what the module is capable of before investing any time into learning how to use it. Fundamentally unsatisfied with the options, I resigned myself to my fate. I was going to have to follow in the footsteps of all before me, and develop my own implementation from scratch. How arduous! I made a prototype script in an afternoon that did exactly what I needed and it worked perfectly. It used a template system and it took less than a week to completely finish. I’m not exaggerating: If I was a stronger man, I would have left it at that and done something else with my life. But then I started to wonder. It wouldn’t be that difficult to update a module like factorio-blueprint to modern Factorio, and I bet I could figure out some way to automatically extract the data from Factorio itself, so you would never have to manually update source files every version. Then I started getting lofty ideas about how I could write documentation for the complex and largely undocumented control_behavior key in entities, or adding custom entity types to create and manipulate groups of entities, or even, god forbid, adding mod support into the mix. That was three or four months ago. Anyway, here’s a Python module I made. Introducing: factorio-draftsman I went through dozens of different combinations of tile orders before settling on this one. Draftsman is a Python module for creating, modifying, importing, and exporting all manner of Factorio blueprint strings. The package allows you to create and design blueprints programmatically, to aid in the development of tedious and repetitive blueprints that would be untenable to create by hand, much like the problem I ran into described above. Draftsman attempts to solve all of the shortcomings of existing Factorio blueprint implementations: Draftsman does it all. All types of entities are supported, from splitters to stack inserters. If you can do it in-game, you can do it with Draftsman, allowing you to focus on the one problem you’re actually trying to solve. Draftsman is uni-language. Written in Python, this makes it exceptionally easy to install, simple to use, and gives the user access to the entirety of Python’s vast packaging index. Chances are you can do it in Python with Draftsman, regardless of what Factorio-related thing you’re actually doing. Draftsman is easy to use. Designed from the start to be simple and (most importantly) self-documenting, Draftsman allows you to manipulate blueprints and entities by auto-completable attributes and methods. Draftsman is well-documented. Every function, method, attribute, and class is documented and crosslinked at its readthedocs site. In addition, tutorials and supplementary materials are provided, as well as a whole host of example programs to help illustrate how Draftsman works. Draftsman is stable. A rigorous suite of tests ensure that Draftsman behaves predictably and correctly (or at least correctly enough), with a code coverage of 100%. Draftsman is verified to work on the latest versions of Python 2 and 3, and is compatible with all versions of Factorio greater than 1.0, with the metrics to prove it. Draftsman is descriptive. Draftsman enforces “Factorio-safety” as a core philosophy, which means that if a blueprint would have an import error in Factorio, an exception is thrown by Draftsman. Draftsman also tries to enforce “Factorio-correctness”, which means that values that won’t break, but are otherwise nonsensical, will raise warnings. Both errors and warnings are verbose, so that any problem with your script can be understood and resolved in seconds. Draftsman is close-to-source. Draftsman bases all of its data off of Wube’s factorio-data repository, which means that all entities are exactly as you would expect in-game, with no inconsistencies. This makes Draftsman up-to-date, makes updating Draftsman for future Factorio versions a breeze, and allows version control to monitor changes between Draftsman and Factorio, if any future breakage should occur. Draftsman supports mods. Draftsman emulates Factorio’s data lifecycle directly, meaning that the same loading process that happens when you launch the game is mimicked with a single Draftsman function. In addition to ensuring absolute accuracy to Factorio, this also means that custom mod prototypes can be accessed from Draftsman as if they were any other vanilla entity. Draftsman has custom classes designed around each individual entity and prototype, and is designed to work as seamlessly as possible with blueprint strings and other software. Draftsman converts to and from these prototypes when you import and export blueprint strings automatically, no extra steps required. You can import a blueprint string from Factorio as a Blueprint object, make any change you want, and then export that Blueprint object back into a string. Or, you can just make an entirely new Blueprint from scratch; Draftsman is designed to work around you, not for you to work around it. Draftsman also has support for custom &quot;EntityLike&quot; objects, most notably Group objects, that allow you to create custom constructs that can be inserted into blueprints for aid with clarity and compartmentalization. For example, you can make a design for a smelting block in a Group, and then you can place that block as many times as you want, wherever you want, rotated or flipped, essentially acting as a copy-paste tool within Draftsman. In an effort to keep this article brief, I’m not going to go too far into the nitty-gritty about the module or how exactly it works; I’ve spent a lot of time writing documentation for that purpose instead. Rather, I’m going to show off a couple of things that I’ve made with it so far, as well as potential things that could be made in the future, to try to illustrate exactly why I spent all this time making it in the first place. Automatic Item Stack Sizes Oftentimes, for you want to figure out how much storage you need for a specific amount of an item. However, storage in Factorio is based on slots, not amounts, so the amount of storage is actually dependent on not only the amount you’re trying to store, but also the stack size of that item. You can design a circuit contraption to determine the number of slots that you need for any input item, but you’d need a big cell of combinators documenting the item sizes. This is boring to make, and easily broken if a new item is added or the stack size is changed. Clearly, for such a simple and repetitive task, a script is better suited: # Create an N x 5 grid of connected constant combinators, with every item and their stack size from draftsman.blueprintable import Blueprint from draftsman.constants import Direction from draftsman.data import items from draftsman.entity import ConstantCombinator COMBINATOR_HEIGHT = 5 def main(): blueprint = Blueprint() signals_added = 0 signal_index = 0 combinators_added = 0 x = 0 y = 0 combinator = ConstantCombinator(direction=Direction.SOUTH) # Iterate over every item in order: for item in items.raw: # Ignore hidden items/entities if &quot;flags&quot; in items.raw[item]: if &quot;hidden&quot; in items.raw[item][&quot;flags&quot;]: continue # Keep track of how many signals we've gone through signals_added += 1 # Write the stack size signal stack_size = items.raw[item][&quot;stack_size&quot;] combinator.set_signal(signal_index, item, stack_size) signal_index += 1 # Once we exceed the number of signals a combinator can hold, place it and reset if signal_index == combinator.item_slot_count: # Add the combinator to the blueprint combinator.id = &quot;{}_{}&quot;.format(x, y) blueprint.entities.append(combinator) # Reset the combinator combinators_added += 1 y = combinators_added % COMBINATOR_HEIGHT x = int(combinators_added / COMBINATOR_HEIGHT) combinator.set_signals(None) # Clear signals combinator.tile_position = (x, y) signal_index = 0 # Add the last combinator if partially full if len(combinator.signals) &gt; 0: combinator.id = &quot;{}_{}&quot;.format(x, y) blueprint.entities.append(combinator) # Add connections to each neighbour for cx in range(x): for cy in range(COMBINATOR_HEIGHT): here = &quot;{}_{}&quot;.format(cx, cy) right = &quot;{}_{}&quot;.format(cx + 1, cy) below = &quot;{}_{}&quot;.format(cx, cy + 1) try: blueprint.add_circuit_connection(&quot;red&quot;, here, right) except KeyError: pass try: blueprint.add_circuit_connection(&quot;red&quot;, here, below) except KeyError: pass print(&quot;Total number of item signals added:&quot;, signals_added) print(blueprint.to_string()) if __name__ == &quot;__main__&quot;: main() This script is concise and easy to follow, but the really amazing thing about Draftsman is that this script is completely dynamic and can adjust to whatever version of Factorio that you’re playing. New items, removed items, or changed stack sizes, regardless of the author of the change, are resolved automatically with the exact same code. For illustration, pictured top-left is what’s generated by running the script for a vanilla game, top-right a game with the medium-sized overhaul modpack Space Exploration, and at the bottom a Bobs + Pyanodon mega-modpack: This doesn’t only applies to items either. All entities, instruments, signals, recipes, modules, and tiles are pulled from the emulated load process and then stored in Draftsman for later use. Any script can be designed to be completely flexible across these categories; extra instruments in a new programmable speaker, new module types only in certain machines, complete virtual signal lists for signal mappings, etc., all are interpreted correctly by Draftsman. By saving the data of the current mod configuration internally for later, this also means that you only have to update the data once, each time you change what mods you’re using. Image to Blueprint Converter This was something I made on a whim. It uses the Pillow image library to load an image, and converts it to a blueprint intended to be visible from the map view, all in less than 150 lines of code: A peculiar man with a comically large flask, colorized. Many improvements could be made to this: Dithering is only implemented on 1x1 tiles; I was having trouble adjusting the algorithm to multi-tile entities. Multi-tile entities also fail to adjust the error metric property; palettization doesn’t work as well when some pixels are of different sizes. Some multi-tile entities have different rotations; a better implementation would check which orientation produces the least error before placing, instead of only placing them with the default orientation. The colors themselves are hardcoded; it would be nice to dynamically load this from the game, especially with modded map colors… Despite these shortcomings, the output actually ends up pretty good for its quick and dirty implementation. This shows that Draftsman is versatile enough for some rather eclectic purposes. Jay Bauman, notorious hack fraud, criminal at large. Armed and dangerous. Factorio Movie Player Resurrection A little while ago, while trawling for projects to use as examples for this very article, I came across the classic Factorio Sandstorm. A perfect project to adapt; or, it would have been, if I could actually load the map in-game! The original map version was still dated to the tender version of 0.14.20. In addition, a lot of the migrations that took place over such a long span of time broke the functionality of the script to convert the image frames into map data, as well as some functionality of the map itself, so just downloading an old version of Factorio and coercing it along wasn’t going to be enough to revive the old save. For example, the build.lua script in charge of encoding still called the automation-science-pack and logistic-science-pack items science-pack-1 and science-pack-2. That should give you some indication of how old the map was! It troubled me, seeing such an iconic piece of Factorio history fall into disrepair. So I took the time to fix the issues and migrated it all the way to 1.1.57: &lt;/source&gt; video of feel the beat Pictured is part of Feel the Beat, keeping the tradition of Darude music videos. Changing the build script could be done by hand, but the signal raw-wood that the machine internally used no longer exists in modern Factorio. In order to fix it, I replaced all occurrences of the signal with it in the map with artillery-wagon (since I knew it would be unique), and that map updating was done with a script running Draftsman code. I also added a number of other scripts for extracting the images from the source, as well as taking screenshots of the result and stitching them into an output video, which is pretty easy in Python. I used said scripts to make the output above. I was also playing around with the idea of using Draftsman to make a blueprint-based version of the builder script, instead of the console-based original method; this would allow you to see exactly what parts of the memory you are modifying by placing a grid aligned blueprint on top of them, and would also allow you to extend the memory of the machine by simply adding more blocks (the memory provided on the map is only enough for 4800 frames). I figured this was less important than updating what was there originally, especially when the code that was already there I knew worked. There could be other considerations as well; the amount of encoded data is pretty hefty, especially for blueprint strings which I suspect may be less dense than the console scripts, which are so large they are dumped in text files when built. Determining whether a blueprint method was actually feasible I figured could wait until I had some spare time further down the line. For more information on what’s changed/new, as well as the updated world file, you can check out my fork here. What’s next? While I’ve done a bunch of things with this module, the whole point of it was to make it easy for anyone to do a whole bunch of other things as well. Some ideas that I would like to do, but have yet to do, I will defer here as food for thought: Many combinator computer compilers are written via script. Perhaps someone could devise a LLVM equivalent; a generic compiler, where you can tell it what instructions your CPU can perform and have it compile high level, established languages like C. Perhaps you could even use LLVM itself? Take advantage of edge case behavior for specific optimization problems. Did you know that you can set entities to request any item, not just modules? You can only request items when originally constructed, which limits its usefulness somewhat, but robots will fulfill the request, allowing you to “kickstart” production in some cases. With something like the Recursive Blueprints mod, by placing assembling machines with item requests, and then deconstructing them when they’ve finished consuming their inputs, theoretically you can build a fully automated factory with only construction bots. Perhaps the Micro Factory can be further optimized? Or a new goal could be to have the fewest total number of entities to launch a rocket without user input? A perhaps more generally applicable use case is this blueprint, a single gun turret that automatically requests 200 red ammo from the logistics network when placed. This is particularly useful in offensive efforts on large biter nests, as you can spam turrets around you and the bots in your inventory will create the turrets and deliver the ammo automatically, allowing you to focus on not dissolving in spitter goo. &lt;/source&gt; An illustration of the turret blueprint in action Routing problems; pass in a set of outpost points and use an algorithm to automatically connect them to minimize distance, number of crossings, etc. Perhaps you could have it read from save files themselves? Combinator contraptions are usually very complex and unintuitive for the layman to decode, as I have found out during my extensive exploration in the introduction. This is due to the density of the circuits, the hidden operations of each combinator, the rat’s nest of wires that is generated with no way to cleanly route them in small areas, and the inability to give labels to combinators or the wires that connect them. It would be nice to have a piece of software that can do take a blueprint string input, and allow the user to do all of the above to create easily decodable and understandable documentation for complex circuit contraptions. I’d love to use such a thing to create vectorized circuit diagrams for my computer. When I finish it. Eventually. Use constraint satisfaction to design blueprints. I’ve experimented with this in the past, and it should be possible; assuming you can get the time complexity down from O(MFG). If I end up writing another article for Alt-F4, it might be on this. You can also use neural networks for the previous goal; this is Python after all! I wonder if you could actually get some usable blueprints this way. Perhaps if you train it on the entirety of factorio.school… Hopefully that should give the creative ones among you some interesting ideas. And maybe, just maybe, when someone needs to write a script for some specific problem to save themselves some time, they can actually save themselves some time instead of spending three to four months writing a Python module from scratch. Eh, it was still pretty fun to make. Educational, too. &lt;/source&gt; It works! Thank heavens. Ah, finally. Back to real work. Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started!">
<meta property="og:description" content="For this week’s issue of Alt-F4, we return to the roots of being a spiritual successor to the FFF by going deep on a technical topic. To that end, redruin1 presents his newest invention: Factorio Draftsman. Sure, there have been other projects trying to build a library for generating blueprints for the game, but this one tries to be the new gold standard. Motivations, technical details, and a few fun projects realized with it - all that, and more, this week! Draftsman redruin1 A couple months ago, I decided that I wanted to try my hand at making a self-expanding factory in Factorio. After seeing a number of impressive examples, I was inspired to have a go at the problem. I already had an outline of the logic, and how the factory would keep track of itself, as well as lofty ideas on impressive things that I could make it do. The only trouble was that I had actually never used combinators before, and I was planning on using them for the actual decision-making. That’s no problem, though: We just create a scrap world, switch to the editor and start playing around! 1 / 3 2 / 3 Any attempt to understand the meaningless scribbles of a madman will only result in disappointment and despair. 3 / 3 ROOKIE NUMBERS ❮ ❯ I may have gotten carried away a little. Here’s a CPU I made. This is the seventh (I think?) revision. It has a ROM, RAM, a stack, 256 registers, over 40 instructions, breakpoints and code stepping, hardware and software interrupts, as well as a generalized circuit interface to interact with other machines. Ah, Factorio. One of the only games where you literally get smarter on repeated playthroughs. Ironically, I’m not actually here to talk about any of this. This is all just foreshadowing. I was starting the second revision of the computer and I wanted a more compact ROM. I came up with the design below, which has the capability of storing true 32-bit numbers and can store 4 KiB of data per row: Everything starts somewhere. The ROM is very dense, but it functions on a system where each value is split into and stored as two 16-bit numbers, which are then recombined on output. ROMs are normally tedious to create, manually encoding each signal you want by hand, one at a time, but this design was even more involved. I now had to split, bitwise AND, bitwise right-shift, and populate not one signal, but two, in two different specific locations, making sure that they both had the correct value and signal type. Needless to say, it was going to be painful to set tens of values, let alone hundreds, or the thousands the machine was capable of storing. The solution? Get a computer to do it for me. It can stomach this task far better than I ever could, and can do it way faster as well. Factorio’s blueprint string import function can take any correctly formatted string; all I had to do was create this text string to my specification with the data I wanted and I could just paste it where needed. This concept is not new, at all. Even a cursory search will turn up numerous examples of this used in practice: factorio-blueprint NPM module by demipixel, justarandomgeek’s compiler for his massive combinator computer, a generic combinator instruction language by Jobarion, image-to-blueprint converters, etc. The list is extensive. With all these examples, I was hoping that I could find some similarities with one of them and use that as a baseline for my solution to avoid “retreading” the same ground. Something troubled me about the solutions that were available though: They all had problems! Many implementations were highly specific to the domain they were written for; a combinator computer compiler script was not going to be portable for many other purposes than compiling code for a specific combinator computer. They lacked a unified language; many were written in Lua, some in Python, another in JavaScript, one in C++, etc. This meant that each one had to write their own implementations for the same operations, instead of just having someone write the implementation they need and making it available to others. Many of them were written for versions of Factorio that are now severely out of date. Documentation for a lot of these modules was sparse and sporadic, which turns off users like me who want to know what the module is capable of before investing any time into learning how to use it. Fundamentally unsatisfied with the options, I resigned myself to my fate. I was going to have to follow in the footsteps of all before me, and develop my own implementation from scratch. How arduous! I made a prototype script in an afternoon that did exactly what I needed and it worked perfectly. It used a template system and it took less than a week to completely finish. I’m not exaggerating: If I was a stronger man, I would have left it at that and done something else with my life. But then I started to wonder. It wouldn’t be that difficult to update a module like factorio-blueprint to modern Factorio, and I bet I could figure out some way to automatically extract the data from Factorio itself, so you would never have to manually update source files every version. Then I started getting lofty ideas about how I could write documentation for the complex and largely undocumented control_behavior key in entities, or adding custom entity types to create and manipulate groups of entities, or even, god forbid, adding mod support into the mix. That was three or four months ago. Anyway, here’s a Python module I made. Introducing: factorio-draftsman I went through dozens of different combinations of tile orders before settling on this one. Draftsman is a Python module for creating, modifying, importing, and exporting all manner of Factorio blueprint strings. The package allows you to create and design blueprints programmatically, to aid in the development of tedious and repetitive blueprints that would be untenable to create by hand, much like the problem I ran into described above. Draftsman attempts to solve all of the shortcomings of existing Factorio blueprint implementations: Draftsman does it all. All types of entities are supported, from splitters to stack inserters. If you can do it in-game, you can do it with Draftsman, allowing you to focus on the one problem you’re actually trying to solve. Draftsman is uni-language. Written in Python, this makes it exceptionally easy to install, simple to use, and gives the user access to the entirety of Python’s vast packaging index. Chances are you can do it in Python with Draftsman, regardless of what Factorio-related thing you’re actually doing. Draftsman is easy to use. Designed from the start to be simple and (most importantly) self-documenting, Draftsman allows you to manipulate blueprints and entities by auto-completable attributes and methods. Draftsman is well-documented. Every function, method, attribute, and class is documented and crosslinked at its readthedocs site. In addition, tutorials and supplementary materials are provided, as well as a whole host of example programs to help illustrate how Draftsman works. Draftsman is stable. A rigorous suite of tests ensure that Draftsman behaves predictably and correctly (or at least correctly enough), with a code coverage of 100%. Draftsman is verified to work on the latest versions of Python 2 and 3, and is compatible with all versions of Factorio greater than 1.0, with the metrics to prove it. Draftsman is descriptive. Draftsman enforces “Factorio-safety” as a core philosophy, which means that if a blueprint would have an import error in Factorio, an exception is thrown by Draftsman. Draftsman also tries to enforce “Factorio-correctness”, which means that values that won’t break, but are otherwise nonsensical, will raise warnings. Both errors and warnings are verbose, so that any problem with your script can be understood and resolved in seconds. Draftsman is close-to-source. Draftsman bases all of its data off of Wube’s factorio-data repository, which means that all entities are exactly as you would expect in-game, with no inconsistencies. This makes Draftsman up-to-date, makes updating Draftsman for future Factorio versions a breeze, and allows version control to monitor changes between Draftsman and Factorio, if any future breakage should occur. Draftsman supports mods. Draftsman emulates Factorio’s data lifecycle directly, meaning that the same loading process that happens when you launch the game is mimicked with a single Draftsman function. In addition to ensuring absolute accuracy to Factorio, this also means that custom mod prototypes can be accessed from Draftsman as if they were any other vanilla entity. Draftsman has custom classes designed around each individual entity and prototype, and is designed to work as seamlessly as possible with blueprint strings and other software. Draftsman converts to and from these prototypes when you import and export blueprint strings automatically, no extra steps required. You can import a blueprint string from Factorio as a Blueprint object, make any change you want, and then export that Blueprint object back into a string. Or, you can just make an entirely new Blueprint from scratch; Draftsman is designed to work around you, not for you to work around it. Draftsman also has support for custom &quot;EntityLike&quot; objects, most notably Group objects, that allow you to create custom constructs that can be inserted into blueprints for aid with clarity and compartmentalization. For example, you can make a design for a smelting block in a Group, and then you can place that block as many times as you want, wherever you want, rotated or flipped, essentially acting as a copy-paste tool within Draftsman. In an effort to keep this article brief, I’m not going to go too far into the nitty-gritty about the module or how exactly it works; I’ve spent a lot of time writing documentation for that purpose instead. Rather, I’m going to show off a couple of things that I’ve made with it so far, as well as potential things that could be made in the future, to try to illustrate exactly why I spent all this time making it in the first place. Automatic Item Stack Sizes Oftentimes, for you want to figure out how much storage you need for a specific amount of an item. However, storage in Factorio is based on slots, not amounts, so the amount of storage is actually dependent on not only the amount you’re trying to store, but also the stack size of that item. You can design a circuit contraption to determine the number of slots that you need for any input item, but you’d need a big cell of combinators documenting the item sizes. This is boring to make, and easily broken if a new item is added or the stack size is changed. Clearly, for such a simple and repetitive task, a script is better suited: # Create an N x 5 grid of connected constant combinators, with every item and their stack size from draftsman.blueprintable import Blueprint from draftsman.constants import Direction from draftsman.data import items from draftsman.entity import ConstantCombinator COMBINATOR_HEIGHT = 5 def main(): blueprint = Blueprint() signals_added = 0 signal_index = 0 combinators_added = 0 x = 0 y = 0 combinator = ConstantCombinator(direction=Direction.SOUTH) # Iterate over every item in order: for item in items.raw: # Ignore hidden items/entities if &quot;flags&quot; in items.raw[item]: if &quot;hidden&quot; in items.raw[item][&quot;flags&quot;]: continue # Keep track of how many signals we've gone through signals_added += 1 # Write the stack size signal stack_size = items.raw[item][&quot;stack_size&quot;] combinator.set_signal(signal_index, item, stack_size) signal_index += 1 # Once we exceed the number of signals a combinator can hold, place it and reset if signal_index == combinator.item_slot_count: # Add the combinator to the blueprint combinator.id = &quot;{}_{}&quot;.format(x, y) blueprint.entities.append(combinator) # Reset the combinator combinators_added += 1 y = combinators_added % COMBINATOR_HEIGHT x = int(combinators_added / COMBINATOR_HEIGHT) combinator.set_signals(None) # Clear signals combinator.tile_position = (x, y) signal_index = 0 # Add the last combinator if partially full if len(combinator.signals) &gt; 0: combinator.id = &quot;{}_{}&quot;.format(x, y) blueprint.entities.append(combinator) # Add connections to each neighbour for cx in range(x): for cy in range(COMBINATOR_HEIGHT): here = &quot;{}_{}&quot;.format(cx, cy) right = &quot;{}_{}&quot;.format(cx + 1, cy) below = &quot;{}_{}&quot;.format(cx, cy + 1) try: blueprint.add_circuit_connection(&quot;red&quot;, here, right) except KeyError: pass try: blueprint.add_circuit_connection(&quot;red&quot;, here, below) except KeyError: pass print(&quot;Total number of item signals added:&quot;, signals_added) print(blueprint.to_string()) if __name__ == &quot;__main__&quot;: main() This script is concise and easy to follow, but the really amazing thing about Draftsman is that this script is completely dynamic and can adjust to whatever version of Factorio that you’re playing. New items, removed items, or changed stack sizes, regardless of the author of the change, are resolved automatically with the exact same code. For illustration, pictured top-left is what’s generated by running the script for a vanilla game, top-right a game with the medium-sized overhaul modpack Space Exploration, and at the bottom a Bobs + Pyanodon mega-modpack: This doesn’t only applies to items either. All entities, instruments, signals, recipes, modules, and tiles are pulled from the emulated load process and then stored in Draftsman for later use. Any script can be designed to be completely flexible across these categories; extra instruments in a new programmable speaker, new module types only in certain machines, complete virtual signal lists for signal mappings, etc., all are interpreted correctly by Draftsman. By saving the data of the current mod configuration internally for later, this also means that you only have to update the data once, each time you change what mods you’re using. Image to Blueprint Converter This was something I made on a whim. It uses the Pillow image library to load an image, and converts it to a blueprint intended to be visible from the map view, all in less than 150 lines of code: A peculiar man with a comically large flask, colorized. Many improvements could be made to this: Dithering is only implemented on 1x1 tiles; I was having trouble adjusting the algorithm to multi-tile entities. Multi-tile entities also fail to adjust the error metric property; palettization doesn’t work as well when some pixels are of different sizes. Some multi-tile entities have different rotations; a better implementation would check which orientation produces the least error before placing, instead of only placing them with the default orientation. The colors themselves are hardcoded; it would be nice to dynamically load this from the game, especially with modded map colors… Despite these shortcomings, the output actually ends up pretty good for its quick and dirty implementation. This shows that Draftsman is versatile enough for some rather eclectic purposes. Jay Bauman, notorious hack fraud, criminal at large. Armed and dangerous. Factorio Movie Player Resurrection A little while ago, while trawling for projects to use as examples for this very article, I came across the classic Factorio Sandstorm. A perfect project to adapt; or, it would have been, if I could actually load the map in-game! The original map version was still dated to the tender version of 0.14.20. In addition, a lot of the migrations that took place over such a long span of time broke the functionality of the script to convert the image frames into map data, as well as some functionality of the map itself, so just downloading an old version of Factorio and coercing it along wasn’t going to be enough to revive the old save. For example, the build.lua script in charge of encoding still called the automation-science-pack and logistic-science-pack items science-pack-1 and science-pack-2. That should give you some indication of how old the map was! It troubled me, seeing such an iconic piece of Factorio history fall into disrepair. So I took the time to fix the issues and migrated it all the way to 1.1.57: &lt;/source&gt; video of feel the beat Pictured is part of Feel the Beat, keeping the tradition of Darude music videos. Changing the build script could be done by hand, but the signal raw-wood that the machine internally used no longer exists in modern Factorio. In order to fix it, I replaced all occurrences of the signal with it in the map with artillery-wagon (since I knew it would be unique), and that map updating was done with a script running Draftsman code. I also added a number of other scripts for extracting the images from the source, as well as taking screenshots of the result and stitching them into an output video, which is pretty easy in Python. I used said scripts to make the output above. I was also playing around with the idea of using Draftsman to make a blueprint-based version of the builder script, instead of the console-based original method; this would allow you to see exactly what parts of the memory you are modifying by placing a grid aligned blueprint on top of them, and would also allow you to extend the memory of the machine by simply adding more blocks (the memory provided on the map is only enough for 4800 frames). I figured this was less important than updating what was there originally, especially when the code that was already there I knew worked. There could be other considerations as well; the amount of encoded data is pretty hefty, especially for blueprint strings which I suspect may be less dense than the console scripts, which are so large they are dumped in text files when built. Determining whether a blueprint method was actually feasible I figured could wait until I had some spare time further down the line. For more information on what’s changed/new, as well as the updated world file, you can check out my fork here. What’s next? While I’ve done a bunch of things with this module, the whole point of it was to make it easy for anyone to do a whole bunch of other things as well. Some ideas that I would like to do, but have yet to do, I will defer here as food for thought: Many combinator computer compilers are written via script. Perhaps someone could devise a LLVM equivalent; a generic compiler, where you can tell it what instructions your CPU can perform and have it compile high level, established languages like C. Perhaps you could even use LLVM itself? Take advantage of edge case behavior for specific optimization problems. Did you know that you can set entities to request any item, not just modules? You can only request items when originally constructed, which limits its usefulness somewhat, but robots will fulfill the request, allowing you to “kickstart” production in some cases. With something like the Recursive Blueprints mod, by placing assembling machines with item requests, and then deconstructing them when they’ve finished consuming their inputs, theoretically you can build a fully automated factory with only construction bots. Perhaps the Micro Factory can be further optimized? Or a new goal could be to have the fewest total number of entities to launch a rocket without user input? A perhaps more generally applicable use case is this blueprint, a single gun turret that automatically requests 200 red ammo from the logistics network when placed. This is particularly useful in offensive efforts on large biter nests, as you can spam turrets around you and the bots in your inventory will create the turrets and deliver the ammo automatically, allowing you to focus on not dissolving in spitter goo. &lt;/source&gt; An illustration of the turret blueprint in action Routing problems; pass in a set of outpost points and use an algorithm to automatically connect them to minimize distance, number of crossings, etc. Perhaps you could have it read from save files themselves? Combinator contraptions are usually very complex and unintuitive for the layman to decode, as I have found out during my extensive exploration in the introduction. This is due to the density of the circuits, the hidden operations of each combinator, the rat’s nest of wires that is generated with no way to cleanly route them in small areas, and the inability to give labels to combinators or the wires that connect them. It would be nice to have a piece of software that can do take a blueprint string input, and allow the user to do all of the above to create easily decodable and understandable documentation for complex circuit contraptions. I’d love to use such a thing to create vectorized circuit diagrams for my computer. When I finish it. Eventually. Use constraint satisfaction to design blueprints. I’ve experimented with this in the past, and it should be possible; assuming you can get the time complexity down from O(MFG). If I end up writing another article for Alt-F4, it might be on this. You can also use neural networks for the previous goal; this is Python after all! I wonder if you could actually get some usable blueprints this way. Perhaps if you train it on the entirety of factorio.school… Hopefully that should give the creative ones among you some interesting ideas. And maybe, just maybe, when someone needs to write a script for some specific problem to save themselves some time, they can actually save themselves some time instead of spending three to four months writing a Python module from scratch. Eh, it was still pretty fun to make. Educational, too. &lt;/source&gt; It works! Thank heavens. Ah, finally. Back to real work. Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started!">
<link rel="canonical" href="https://alt-f4.blog/it/ALTF4-61/">
<meta property="og:url" content="https://alt-f4.blog/ALTF4-61/">
<meta property="og:site_name" content="Alternative Friday Factorio Fan Facts">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-05-27T00:00:00+00:00">
<script type="application/ld+json">
{"headline":"Alt-F4 #61 - Draftsman: A Python module for creating blueprints","dateModified":"2022-05-27T00:00:00+00:00","datePublished":"2022-05-27T00:00:00+00:00","description":"For this week’s issue of Alt-F4, we return to the roots of being a spiritual successor to the FFF by going deep on a technical topic. To that end, redruin1 presents his newest invention: Factorio Draftsman. Sure, there have been other projects trying to build a library for generating blueprints for the game, but this one tries to be the new gold standard. Motivations, technical details, and a few fun projects realized with it - all that, and more, this week! Draftsman redruin1 A couple months ago, I decided that I wanted to try my hand at making a self-expanding factory in Factorio. After seeing a number of impressive examples, I was inspired to have a go at the problem. I already had an outline of the logic, and how the factory would keep track of itself, as well as lofty ideas on impressive things that I could make it do. The only trouble was that I had actually never used combinators before, and I was planning on using them for the actual decision-making. That’s no problem, though: We just create a scrap world, switch to the editor and start playing around! 1 / 3 2 / 3 Any attempt to understand the meaningless scribbles of a madman will only result in disappointment and despair. 3 / 3 ROOKIE NUMBERS &#10094; &#10095; I may have gotten carried away a little. Here’s a CPU I made. This is the seventh (I think?) revision. It has a ROM, RAM, a stack, 256 registers, over 40 instructions, breakpoints and code stepping, hardware and software interrupts, as well as a generalized circuit interface to interact with other machines. Ah, Factorio. One of the only games where you literally get smarter on repeated playthroughs. Ironically, I’m not actually here to talk about any of this. This is all just foreshadowing. I was starting the second revision of the computer and I wanted a more compact ROM. I came up with the design below, which has the capability of storing true 32-bit numbers and can store 4 KiB of data per row: Everything starts somewhere. The ROM is very dense, but it functions on a system where each value is split into and stored as two 16-bit numbers, which are then recombined on output. ROMs are normally tedious to create, manually encoding each signal you want by hand, one at a time, but this design was even more involved. I now had to split, bitwise AND, bitwise right-shift, and populate not one signal, but two, in two different specific locations, making sure that they both had the correct value and signal type. Needless to say, it was going to be painful to set tens of values, let alone hundreds, or the thousands the machine was capable of storing. The solution? Get a computer to do it for me. It can stomach this task far better than I ever could, and can do it way faster as well. Factorio’s blueprint string import function can take any correctly formatted string; all I had to do was create this text string to my specification with the data I wanted and I could just paste it where needed. This concept is not new, at all. Even a cursory search will turn up numerous examples of this used in practice: factorio-blueprint NPM module by demipixel, justarandomgeek’s compiler for his massive combinator computer, a generic combinator instruction language by Jobarion, image-to-blueprint converters, etc. The list is extensive. With all these examples, I was hoping that I could find some similarities with one of them and use that as a baseline for my solution to avoid “retreading” the same ground. Something troubled me about the solutions that were available though: They all had problems! Many implementations were highly specific to the domain they were written for; a combinator computer compiler script was not going to be portable for many other purposes than compiling code for a specific combinator computer. They lacked a unified language; many were written in Lua, some in Python, another in JavaScript, one in C++, etc. This meant that each one had to write their own implementations for the same operations, instead of just having someone write the implementation they need and making it available to others. Many of them were written for versions of Factorio that are now severely out of date. Documentation for a lot of these modules was sparse and sporadic, which turns off users like me who want to know what the module is capable of before investing any time into learning how to use it. Fundamentally unsatisfied with the options, I resigned myself to my fate. I was going to have to follow in the footsteps of all before me, and develop my own implementation from scratch. How arduous! I made a prototype script in an afternoon that did exactly what I needed and it worked perfectly. It used a template system and it took less than a week to completely finish. I’m not exaggerating: If I was a stronger man, I would have left it at that and done something else with my life. But then I started to wonder. It wouldn’t be that difficult to update a module like factorio-blueprint to modern Factorio, and I bet I could figure out some way to automatically extract the data from Factorio itself, so you would never have to manually update source files every version. Then I started getting lofty ideas about how I could write documentation for the complex and largely undocumented control_behavior key in entities, or adding custom entity types to create and manipulate groups of entities, or even, god forbid, adding mod support into the mix. That was three or four months ago. Anyway, here’s a Python module I made. Introducing: factorio-draftsman I went through dozens of different combinations of tile orders before settling on this one. Draftsman is a Python module for creating, modifying, importing, and exporting all manner of Factorio blueprint strings. The package allows you to create and design blueprints programmatically, to aid in the development of tedious and repetitive blueprints that would be untenable to create by hand, much like the problem I ran into described above. Draftsman attempts to solve all of the shortcomings of existing Factorio blueprint implementations: Draftsman does it all. All types of entities are supported, from splitters to stack inserters. If you can do it in-game, you can do it with Draftsman, allowing you to focus on the one problem you’re actually trying to solve. Draftsman is uni-language. Written in Python, this makes it exceptionally easy to install, simple to use, and gives the user access to the entirety of Python’s vast packaging index. Chances are you can do it in Python with Draftsman, regardless of what Factorio-related thing you’re actually doing. Draftsman is easy to use. Designed from the start to be simple and (most importantly) self-documenting, Draftsman allows you to manipulate blueprints and entities by auto-completable attributes and methods. Draftsman is well-documented. Every function, method, attribute, and class is documented and crosslinked at its readthedocs site. In addition, tutorials and supplementary materials are provided, as well as a whole host of example programs to help illustrate how Draftsman works. Draftsman is stable. A rigorous suite of tests ensure that Draftsman behaves predictably and correctly (or at least correctly enough), with a code coverage of 100%. Draftsman is verified to work on the latest versions of Python 2 and 3, and is compatible with all versions of Factorio greater than 1.0, with the metrics to prove it. Draftsman is descriptive. Draftsman enforces “Factorio-safety” as a core philosophy, which means that if a blueprint would have an import error in Factorio, an exception is thrown by Draftsman. Draftsman also tries to enforce “Factorio-correctness”, which means that values that won’t break, but are otherwise nonsensical, will raise warnings. Both errors and warnings are verbose, so that any problem with your script can be understood and resolved in seconds. Draftsman is close-to-source. Draftsman bases all of its data off of Wube’s factorio-data repository, which means that all entities are exactly as you would expect in-game, with no inconsistencies. This makes Draftsman up-to-date, makes updating Draftsman for future Factorio versions a breeze, and allows version control to monitor changes between Draftsman and Factorio, if any future breakage should occur. Draftsman supports mods. Draftsman emulates Factorio’s data lifecycle directly, meaning that the same loading process that happens when you launch the game is mimicked with a single Draftsman function. In addition to ensuring absolute accuracy to Factorio, this also means that custom mod prototypes can be accessed from Draftsman as if they were any other vanilla entity. Draftsman has custom classes designed around each individual entity and prototype, and is designed to work as seamlessly as possible with blueprint strings and other software. Draftsman converts to and from these prototypes when you import and export blueprint strings automatically, no extra steps required. You can import a blueprint string from Factorio as a Blueprint object, make any change you want, and then export that Blueprint object back into a string. Or, you can just make an entirely new Blueprint from scratch; Draftsman is designed to work around you, not for you to work around it. Draftsman also has support for custom &quot;EntityLike&quot; objects, most notably Group objects, that allow you to create custom constructs that can be inserted into blueprints for aid with clarity and compartmentalization. For example, you can make a design for a smelting block in a Group, and then you can place that block as many times as you want, wherever you want, rotated or flipped, essentially acting as a copy-paste tool within Draftsman. In an effort to keep this article brief, I’m not going to go too far into the nitty-gritty about the module or how exactly it works; I’ve spent a lot of time writing documentation for that purpose instead. Rather, I’m going to show off a couple of things that I’ve made with it so far, as well as potential things that could be made in the future, to try to illustrate exactly why I spent all this time making it in the first place. Automatic Item Stack Sizes Oftentimes, for you want to figure out how much storage you need for a specific amount of an item. However, storage in Factorio is based on slots, not amounts, so the amount of storage is actually dependent on not only the amount you’re trying to store, but also the stack size of that item. You can design a circuit contraption to determine the number of slots that you need for any input item, but you’d need a big cell of combinators documenting the item sizes. This is boring to make, and easily broken if a new item is added or the stack size is changed. Clearly, for such a simple and repetitive task, a script is better suited: # Create an N x 5 grid of connected constant combinators, with every item and their stack size from draftsman.blueprintable import Blueprint from draftsman.constants import Direction from draftsman.data import items from draftsman.entity import ConstantCombinator COMBINATOR_HEIGHT = 5 def main(): blueprint = Blueprint() signals_added = 0 signal_index = 0 combinators_added = 0 x = 0 y = 0 combinator = ConstantCombinator(direction=Direction.SOUTH) # Iterate over every item in order: for item in items.raw: # Ignore hidden items/entities if &quot;flags&quot; in items.raw[item]: if &quot;hidden&quot; in items.raw[item][&quot;flags&quot;]: continue # Keep track of how many signals we&#39;ve gone through signals_added += 1 # Write the stack size signal stack_size = items.raw[item][&quot;stack_size&quot;] combinator.set_signal(signal_index, item, stack_size) signal_index += 1 # Once we exceed the number of signals a combinator can hold, place it and reset if signal_index == combinator.item_slot_count: # Add the combinator to the blueprint combinator.id = &quot;{}_{}&quot;.format(x, y) blueprint.entities.append(combinator) # Reset the combinator combinators_added += 1 y = combinators_added % COMBINATOR_HEIGHT x = int(combinators_added / COMBINATOR_HEIGHT) combinator.set_signals(None) # Clear signals combinator.tile_position = (x, y) signal_index = 0 # Add the last combinator if partially full if len(combinator.signals) &gt; 0: combinator.id = &quot;{}_{}&quot;.format(x, y) blueprint.entities.append(combinator) # Add connections to each neighbour for cx in range(x): for cy in range(COMBINATOR_HEIGHT): here = &quot;{}_{}&quot;.format(cx, cy) right = &quot;{}_{}&quot;.format(cx + 1, cy) below = &quot;{}_{}&quot;.format(cx, cy + 1) try: blueprint.add_circuit_connection(&quot;red&quot;, here, right) except KeyError: pass try: blueprint.add_circuit_connection(&quot;red&quot;, here, below) except KeyError: pass print(&quot;Total number of item signals added:&quot;, signals_added) print(blueprint.to_string()) if __name__ == &quot;__main__&quot;: main() This script is concise and easy to follow, but the really amazing thing about Draftsman is that this script is completely dynamic and can adjust to whatever version of Factorio that you’re playing. New items, removed items, or changed stack sizes, regardless of the author of the change, are resolved automatically with the exact same code. For illustration, pictured top-left is what’s generated by running the script for a vanilla game, top-right a game with the medium-sized overhaul modpack Space Exploration, and at the bottom a Bobs + Pyanodon mega-modpack: This doesn’t only applies to items either. All entities, instruments, signals, recipes, modules, and tiles are pulled from the emulated load process and then stored in Draftsman for later use. Any script can be designed to be completely flexible across these categories; extra instruments in a new programmable speaker, new module types only in certain machines, complete virtual signal lists for signal mappings, etc., all are interpreted correctly by Draftsman. By saving the data of the current mod configuration internally for later, this also means that you only have to update the data once, each time you change what mods you’re using. Image to Blueprint Converter This was something I made on a whim. It uses the Pillow image library to load an image, and converts it to a blueprint intended to be visible from the map view, all in less than 150 lines of code: A peculiar man with a comically large flask, colorized. Many improvements could be made to this: Dithering is only implemented on 1x1 tiles; I was having trouble adjusting the algorithm to multi-tile entities. Multi-tile entities also fail to adjust the error metric property; palettization doesn’t work as well when some pixels are of different sizes. Some multi-tile entities have different rotations; a better implementation would check which orientation produces the least error before placing, instead of only placing them with the default orientation. The colors themselves are hardcoded; it would be nice to dynamically load this from the game, especially with modded map colors… Despite these shortcomings, the output actually ends up pretty good for its quick and dirty implementation. This shows that Draftsman is versatile enough for some rather eclectic purposes. Jay Bauman, notorious hack fraud, criminal at large. Armed and dangerous. Factorio Movie Player Resurrection A little while ago, while trawling for projects to use as examples for this very article, I came across the classic Factorio Sandstorm. A perfect project to adapt; or, it would have been, if I could actually load the map in-game! The original map version was still dated to the tender version of 0.14.20. In addition, a lot of the migrations that took place over such a long span of time broke the functionality of the script to convert the image frames into map data, as well as some functionality of the map itself, so just downloading an old version of Factorio and coercing it along wasn’t going to be enough to revive the old save. For example, the build.lua script in charge of encoding still called the automation-science-pack and logistic-science-pack items science-pack-1 and science-pack-2. That should give you some indication of how old the map was! It troubled me, seeing such an iconic piece of Factorio history fall into disrepair. So I took the time to fix the issues and migrated it all the way to 1.1.57: &lt;/source&gt; video of feel the beat Pictured is part of Feel the Beat, keeping the tradition of Darude music videos. Changing the build script could be done by hand, but the signal raw-wood that the machine internally used no longer exists in modern Factorio. In order to fix it, I replaced all occurrences of the signal with it in the map with artillery-wagon (since I knew it would be unique), and that map updating was done with a script running Draftsman code. I also added a number of other scripts for extracting the images from the source, as well as taking screenshots of the result and stitching them into an output video, which is pretty easy in Python. I used said scripts to make the output above. I was also playing around with the idea of using Draftsman to make a blueprint-based version of the builder script, instead of the console-based original method; this would allow you to see exactly what parts of the memory you are modifying by placing a grid aligned blueprint on top of them, and would also allow you to extend the memory of the machine by simply adding more blocks (the memory provided on the map is only enough for 4800 frames). I figured this was less important than updating what was there originally, especially when the code that was already there I knew worked. There could be other considerations as well; the amount of encoded data is pretty hefty, especially for blueprint strings which I suspect may be less dense than the console scripts, which are so large they are dumped in text files when built. Determining whether a blueprint method was actually feasible I figured could wait until I had some spare time further down the line. For more information on what’s changed/new, as well as the updated world file, you can check out my fork here. What’s next? While I’ve done a bunch of things with this module, the whole point of it was to make it easy for anyone to do a whole bunch of other things as well. Some ideas that I would like to do, but have yet to do, I will defer here as food for thought: Many combinator computer compilers are written via script. Perhaps someone could devise a LLVM equivalent; a generic compiler, where you can tell it what instructions your CPU can perform and have it compile high level, established languages like C. Perhaps you could even use LLVM itself? Take advantage of edge case behavior for specific optimization problems. Did you know that you can set entities to request any item, not just modules? You can only request items when originally constructed, which limits its usefulness somewhat, but robots will fulfill the request, allowing you to “kickstart” production in some cases. With something like the Recursive Blueprints mod, by placing assembling machines with item requests, and then deconstructing them when they’ve finished consuming their inputs, theoretically you can build a fully automated factory with only construction bots. Perhaps the Micro Factory can be further optimized? Or a new goal could be to have the fewest total number of entities to launch a rocket without user input? A perhaps more generally applicable use case is this blueprint, a single gun turret that automatically requests 200 red ammo from the logistics network when placed. This is particularly useful in offensive efforts on large biter nests, as you can spam turrets around you and the bots in your inventory will create the turrets and deliver the ammo automatically, allowing you to focus on not dissolving in spitter goo. &lt;/source&gt; An illustration of the turret blueprint in action Routing problems; pass in a set of outpost points and use an algorithm to automatically connect them to minimize distance, number of crossings, etc. Perhaps you could have it read from save files themselves? Combinator contraptions are usually very complex and unintuitive for the layman to decode, as I have found out during my extensive exploration in the introduction. This is due to the density of the circuits, the hidden operations of each combinator, the rat’s nest of wires that is generated with no way to cleanly route them in small areas, and the inability to give labels to combinators or the wires that connect them. It would be nice to have a piece of software that can do take a blueprint string input, and allow the user to do all of the above to create easily decodable and understandable documentation for complex circuit contraptions. I’d love to use such a thing to create vectorized circuit diagrams for my computer. When I finish it. Eventually. Use constraint satisfaction to design blueprints. I’ve experimented with this in the past, and it should be possible; assuming you can get the time complexity down from O(MFG). If I end up writing another article for Alt-F4, it might be on this. You can also use neural networks for the previous goal; this is Python after all! I wonder if you could actually get some usable blueprints this way. Perhaps if you train it on the entirety of factorio.school… Hopefully that should give the creative ones among you some interesting ideas. And maybe, just maybe, when someone needs to write a script for some specific problem to save themselves some time, they can actually save themselves some time instead of spending three to four months writing a Python module from scratch. Eh, it was still pretty fun to make. Educational, too. &lt;/source&gt; It works! Thank heavens. Ah, finally. Back to real work. Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started!","url":"https://alt-f4.blog/ALTF4-61/","@type":"BlogPosting","author":{"@type":"Person","name":"redruin1"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://alt-f4.blog/ALTF4-61/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
	

	
	  <meta property="og:image" content="https://alt-f4.blog/assets/ALTF4/61/thumbnail.jpg">
	  <meta name="twitter:image" content="https://alt-f4.blog/assets/ALTF4/61/thumbnail.jpg">
	

	<!-- CSS & fonts -->
	<link href="/it/assets/GLOBAL/css/titillium-web.css" rel="stylesheet">
	<link rel="stylesheet" href="/it/assets/GLOBAL/css/style.css">
	<link rel="stylesheet" href="/it/assets/GLOBAL/css/spidertron.css">
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.css" rel="stylesheet" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,400italic%7CSignika:700,300,400,600" rel="stylesheet" type="text/css">

	<link href="/it/assets/GLOBAL/img/favicon.ico" rel="icon" type="image/x-icon">
	<link href="/it/assets/GLOBAL/img/favicon.ico" rel="shortcut icon" type="image/x-icon">

	<!-- RSS -->
	<link href="/it/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed">

	<script src="/assets/GLOBAL/js/spidertron.js"></script>
	<script src="/assets/GLOBAL/js/localization.js"></script>
	<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
</head>


  <body>
    <!-- Navigation Bar -->
    <nav id="top" class="top-bar">
	<div class="top-bar-inner flex flex-space-between">
		<div class="sites links flex">
			<a href="/it/" class="sites-current">
				<div id="navbar-logo" role="img" aria-label="Alt-F4 Logo"></div>
			</a>
			<a href="https://alt-f4.blog/it/discord" class="">Discord</a>
			<span class="separator">|</span>
			<a href="https://factorio.com/blog" class="">FFF</a>
		</div>
		<div class="sites links flex hide-tag-line">
			<em>Il seguito degli amati Factorio Friday Facts gestito dalla community</em>
		</div>
		<div class="dropdown flex-end">
			<a class="button flex flex-space-between" href="#">
				<i class="fas fa-language"></i>
			</a>
			<div class="submenu">
				
				<a class="button lang-button" href="/../ALTF4-61/" onclick="setLanguage('en')">English</a>
				
				<a class="button lang-button" href="/cs/ALTF4-61/" onclick="setLanguage('cs')">Čeština</a>
				
				<a class="button lang-button" href="/de/ALTF4-61/" onclick="setLanguage('de')">Deutsch</a>
				
				<a class="button lang-button" href="/es/ALTF4-61/" onclick="setLanguage('es')">Español</a>
				
				<a class="button lang-button" href="/fr/ALTF4-61/" onclick="setLanguage('fr')">Français</a>
				
				<a class="button button-green lang-button" href="/it/ALTF4-61/" onclick="setLanguage('it')">Italiano</a>
				
				<a class="button lang-button" href="/nl/ALTF4-61/" onclick="setLanguage('nl')">Nederlands</a>
				
				<a class="button lang-button" href="/pt-br/ALTF4-61/" onclick="setLanguage('pt-br')">Português Brasileiro</a>
				
				<a class="button lang-button" href="/ru/ALTF4-61/" onclick="setLanguage('ru')">Русский</a>
				
				<a class="button lang-button" href="/zh/ALTF4-61/" onclick="setLanguage('zh')">中文</a>
				
			</div>
		</div>
	</div>
</nav>


    <!-- Main content -->
    <div class="container">
      <div class="container-inner">
        <div class="small-center"></div>
        <!-- Posts -->
        <article class="panel blog-post">
	
	<h1 class="page-title-headder">Alt-F4 #61 - Draftsman: A Python module for creating blueprints  <author>27-05-2022</author>
</h1>
	
	
	<div class="panel-inset mb0">
		
Scritto da <em>redruin1</em>,



editato da <em>Nanogamer7, stringweasel, Conor_, Therenas, MyNameIsTrez, Firerazer</em>








	</div>
	
	<div class="panel-inset-lighter mt0">
		<div class="post-header">
  <div class="panel">
    <div class="outer">
      <img class="inner" src="/assets/ALTF4/61/thumbnail.jpg" alt="" style="margin: 1px;">
    </div>
  </div>
  <details class="panel toc">
    <summary>
      <h2>Tabella dei Contenuti</h2>
    </summary>
    <div class="panel-inset mb0">
      <ul>
  <li>
<a href="#draftsman-redruin1">Draftsman <author>redruin1</author></a>
    <ul>
      <li><a href="#introducing-factorio-draftsman">Introducing: <code class="language-plaintext highlighter-rouge">factorio-draftsman</code></a></li>
      <li><a href="#automatic-item-stack-sizes">Automatic Item Stack Sizes</a></li>
      <li><a href="#image-to-blueprint-converter">Image to Blueprint Converter</a></li>
      <li><a href="#factorio-movie-player-resurrection">Factorio Movie Player Resurrection</a></li>
      <li><a href="#whats-next">What’s next?</a></li>
    </ul>
  </li>
  <li><a href="#contributing">Contributing</a></li>
</ul>

    </div>
  </details>
</div>


<div class="center banner">
  <p>Siamo spiacenti, ma questo articolo non è ancora stato tradotto in Italiano, perciò lo state vedendo in Inglese. Se volete darci una mano a rimediare, vi invitiamo ad entrare nel server <a href="https://alt-f4.blog/it/discord">Discord</a> di Alt-F4. Grazie per la pazienza!</p>

</div>



<p>For this week’s issue of Alt-F4, we return to the roots of being a spiritual successor to the <em>FFF</em> by going deep on a technical topic. To that end, <em>redruin1</em> presents his newest invention: Factorio Draftsman. Sure, there have been other projects trying to build a library for generating blueprints for the game, but this one tries to be the new gold standard. Motivations, technical details, and a few fun projects realized with it - all that, and more, this week!</p>
      <h2 id="draftsman-redruin1">
        
        
            <a href="#draftsman-redruin1" class="anchor" style="text-decoration: none;">Draftsman <author>redruin1</author></a>
          
        
      </h2>
    

<p>A couple months ago, I decided that I wanted to try my hand at making a <strong>self-expanding factory</strong> in Factorio. After seeing a number of <a href="https://www.youtube.com/watch?v=xF--1XdcOeM">impressive</a> <a href="https://alt-f4.blog/it/ALTF4-39/">examples</a>, I was inspired to have a go at the problem. I already had an outline of the logic, and how the factory would keep track of itself, as well as lofty ideas on impressive things that I could make it do. The only trouble was that I had actually never used combinators before, and I was planning on using them for the actual decision-making.</p>

<p>That’s no problem, though: We just create a scrap world, switch to the editor and start playing around!</p>

<!---->

<!---->

<div class="flex flex-column panel-inset">
  <div class="gallery">

    <!---->
    
    
    <div class="galleryItem">
      <div class="numbertext">1 / 3</div>
      <img src="https://media.alt-f4.blog/ALTF4/61/map_view_of_madness.jpg" alt="death" style="width:100%">
      <!---->
      <p style="text-align: center; margin-top:8px; margin-bottom:8px"></p>
    </div>
    
    
    <div class="galleryItem">
      <div class="numbertext">2 / 3</div>
      <img src="https://media.alt-f4.blog/ALTF4/61/madness.jpg" alt="additional death" style="width:100%">
      <!---->
      <p style="text-align: center; margin-top:8px; margin-bottom:8px">Any attempt to understand the meaningless scribbles of a madman will only result in disappointment and despair.</p>
    </div>
    
    
    <div class="galleryItem">
      <div class="numbertext">3 / 3</div>
      <img src="https://media.alt-f4.blog/ALTF4/61/play_time.jpg" alt="too much playtime" style="width:100%">
      <!---->
      <p style="text-align: center; margin-top:8px; margin-bottom:8px">ROOKIE NUMBERS</p>
    </div>
    

    <!---->
    <a class="prev" onclick="plusSlides(-1)">❮</a>
    <a class="next" onclick="plusSlides(1)">❯</a>

    <!---->
    <div class="row">
      
      
      <div class="column">
        <img class="galleryPreview" src="https://media.alt-f4.blog/ALTF4/61/map_view_of_madness.jpg" alt="death" onclick="currentSlide(1)" style="width:100%; cursor: pointer;">
      </div>
      
      
      <div class="column">
        <img class="galleryPreview" src="https://media.alt-f4.blog/ALTF4/61/madness.jpg" alt="additional death" onclick="currentSlide(2)" style="width:100%; cursor: pointer;">
      </div>
      
      
      <div class="column">
        <img class="galleryPreview" src="https://media.alt-f4.blog/ALTF4/61/play_time.jpg" alt="too much playtime" onclick="currentSlide(3)" style="width:100%; cursor: pointer;">
      </div>
      
    </div>
  </div>
  <!---->
  
</div>

<p>I may have gotten carried away a little.</p>

<p>Here’s a CPU I made. This is the seventh (I think?) revision. It has a ROM, RAM, a stack, 256 registers, over 40 instructions, breakpoints and code stepping, hardware and software interrupts, as well as a generalized circuit interface to interact with other machines.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/mk1_computer.jpg" alt="Picture of my first CPU design" style="max-width: ; max-height:  ">
        
        <figcaption>Ah, Factorio. One of the only games where you literally get smarter on repeated playthroughs.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Ironically, I’m not actually here to talk about <em>any</em> of this. This is all just foreshadowing.</p>

<p>I was starting the second revision of the computer and I wanted a more compact ROM. I came up with the design below, which has the capability of storing true 32-bit numbers and can store 4 KiB of data per row:</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/ROM_design.jpg" alt="Depiction of my ROM" style="max-width: ; max-height:  ">
        
        <figcaption>Everything starts somewhere.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>The ROM is <em>very</em> dense, but it functions on a system where each value is split into and stored as two 16-bit numbers, which are then recombined on output. ROMs are normally tedious to create, manually encoding each signal you want by hand, one at a time, but this design was even more involved. I now had to split, bitwise AND, bitwise right-shift, and populate not one signal, but two, in two different specific locations, making sure that they both had the correct value <em>and</em> signal type. Needless to say, it was going to be painful to set tens of values, let alone hundreds, or the <em>thousands</em> the machine was capable of storing.</p>

<p>The solution? Get a computer to do it for me. It can stomach this task far better than I ever could, and can do it way faster as well. Factorio’s blueprint string import function can take any correctly formatted string; all I had to do was create this text string to my specification with the data I wanted and I could just paste it where needed.</p>

<p>This concept is not new, at all. Even a cursory search will turn up numerous examples of this used in practice: <a href="https://github.com/demipixel/factorio-blueprint"><code class="language-plaintext highlighter-rouge">factorio-blueprint</code> NPM module by demipixel</a>, <a href="https://github.com/justarandomgeek/factorio-computer">justarandomgeek’s compiler for his massive combinator computer</a>, <a href="https://github.com/Jobarion/factoriogen/">a generic combinator instruction language by Jobarion</a>, <a href="https://github.com/EFLFE/Artorio">image-to-blueprint converters</a>, etc. The list is extensive.</p>

<p>With all these examples, I was hoping that I could find some similarities with one of them and use that as a baseline for my solution to avoid “retreading” the same ground. Something troubled me about the solutions that were available though: They all had problems!</p>

<ul>
  <li>Many implementations were highly specific to the domain they were written for; a combinator computer compiler script was not going to be portable for many other purposes than compiling code for a specific combinator computer.</li>
  <li>They lacked a unified language; many were written in Lua, some in Python, another in JavaScript, one in C++, etc. This meant that each one had to write their own implementations for the same operations, instead of just having someone write the implementation they need and making it available to others.</li>
  <li>Many of them were written for versions of Factorio that are now severely out of date.</li>
  <li>Documentation for a lot of these modules was sparse and sporadic, which turns off users like me who want to know what the module is capable of before investing any time into learning how to use it.</li>
</ul>

<p>Fundamentally unsatisfied with the options, I resigned myself to my fate. I was going to have to follow in the footsteps of all before me, and develop my own implementation from scratch. How arduous!</p>

<p>I made a prototype script in an afternoon that did exactly what I needed and it worked perfectly. It used a template system and it took less than a week to completely finish.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/populated_ROM.jpg" alt="Finished result" style="max-width: ; max-height:  ">
        
        <figcaption>I’m not exaggerating: If I was a stronger man, I would have left it at that and done something else with my life.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>But then I started to wonder. It wouldn’t be that difficult to update a module like <code class="language-plaintext highlighter-rouge">factorio-blueprint</code> to modern Factorio, and I bet I could figure out some way to automatically extract the data from Factorio itself, so you would never have to manually update source files every version. Then I started getting lofty ideas about how I could write documentation for the complex and largely undocumented <code class="language-plaintext highlighter-rouge">control_behavior</code> key in entities, or adding custom entity types to create and manipulate groups of entities, or even, god forbid, adding <em>mod support</em> into the mix. That was three or four months ago.</p>

<p>Anyway, here’s a Python module I made.</p>
      <h3 id="introducing-factorio-draftsman">
        
        
            <a href="#introducing-factorio-draftsman" class="anchor" style="text-decoration: none;">Introducing: <code class="language-plaintext highlighter-rouge">factorio-draftsman</code></a>
          
        
      </h3>
    

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/draftsman_logo.jpg" alt="Draftsman logo, represented in-game, generated via script." style="max-width: ; max-height:  ">
        
        <figcaption>I went through dozens of different combinations of tile orders before settling on this one.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p><a href="https://github.com/redruin1/factorio-draftsman">Draftsman</a> is a Python module for creating, modifying, importing, and exporting all manner of Factorio blueprint strings. The package allows you to create and design blueprints programmatically, to aid in the development of tedious and repetitive blueprints that would be untenable to create by hand, much like the problem I ran into described above. Draftsman attempts to solve all of the shortcomings of existing Factorio blueprint implementations:</p>

<ul>
  <li>
<strong>Draftsman does it all.</strong> All types of entities are supported, from splitters to stack inserters. If you can do it in-game, you can do it with Draftsman, allowing you to focus on the one problem you’re <em>actually</em> trying to solve.</li>
  <li>
<strong>Draftsman is uni-language.</strong> Written in Python, this makes it exceptionally easy to install, simple to use, and gives the user access to the entirety of Python’s vast packaging index. Chances are you can do it in Python with Draftsman, regardless of <em>what</em> Factorio-related thing you’re actually doing.</li>
  <li>
<strong>Draftsman is easy to use.</strong> Designed from the start to be simple and (most importantly) self-documenting, Draftsman allows you to manipulate blueprints and entities by auto-completable attributes and methods.</li>
  <li>
<strong>Draftsman is well-documented.</strong> Every function, method, attribute, and class is documented and crosslinked at its <a href="https://factorio-draftsman.readthedocs.io/en/latest/?badge=latest">readthedocs site</a>. In addition, tutorials and supplementary materials are provided, as well as a whole host of <a href="https://github.com/redruin1/factorio-draftsman/tree/main/examples">example programs</a> to help illustrate how Draftsman works.</li>
  <li>
<strong>Draftsman is stable.</strong> A rigorous suite of tests ensure that Draftsman behaves predictably and correctly (or at least correctly enough), with a code coverage of 100%. Draftsman is verified to work on the latest versions of Python 2 and 3, and is compatible with all versions of Factorio greater than 1.0, with the metrics to prove it.</li>
  <li>
<strong>Draftsman is descriptive.</strong> Draftsman enforces “Factorio-safety” as a core philosophy, which means that if a blueprint would have an import error in Factorio, an exception is thrown by Draftsman. Draftsman also tries to enforce “Factorio-correctness”, which means that values that won’t break, but are otherwise nonsensical, will raise warnings. Both errors and warnings are verbose, so that any problem with your script can be understood and resolved in seconds.</li>
  <li>
<strong>Draftsman is close-to-source.</strong> Draftsman bases all of its data off of <a href="https://github.com/wube/factorio-data">Wube’s <code class="language-plaintext highlighter-rouge">factorio-data</code> repository</a>, which means that all entities are exactly as you would expect in-game, with no inconsistencies. This makes Draftsman up-to-date, makes updating Draftsman for future Factorio versions a breeze, and allows version control to monitor changes between Draftsman and Factorio, if any future breakage should occur.</li>
  <li>
<strong>Draftsman supports mods.</strong> Draftsman emulates <a href="https://lua-api.factorio.com/latest/Data-Lifecycle.html">Factorio’s data lifecycle</a> directly, meaning that the same loading process that happens when you launch the game is mimicked with a single Draftsman function. In addition to ensuring absolute accuracy to Factorio, this also means that custom mod prototypes can be accessed from Draftsman as if they were any other vanilla entity.</li>
</ul>

<p>Draftsman has custom classes designed around each individual entity and prototype, and is designed to work as seamlessly as possible with blueprint strings and other software. Draftsman converts to and from these prototypes when you import and export blueprint strings automatically, no extra steps required. You can import a blueprint string from Factorio as a <code class="language-plaintext highlighter-rouge">Blueprint</code> object, make any change you want, and then export that <code class="language-plaintext highlighter-rouge">Blueprint</code> object back into a string. Or, you can just make an entirely new <code class="language-plaintext highlighter-rouge">Blueprint</code> from scratch; Draftsman is designed to work around you, not for you to work around it.</p>

<p>Draftsman also has support for custom <code class="language-plaintext highlighter-rouge">"EntityLike"</code> objects, most notably <code class="language-plaintext highlighter-rouge">Group</code> objects, that allow you to create custom constructs that can be inserted into blueprints for aid with clarity and compartmentalization. For example, you can make a design for a smelting block in a <code class="language-plaintext highlighter-rouge">Group</code>, and then you can place that block as many times as you want, wherever you want, rotated or flipped, essentially acting as a copy-paste tool within Draftsman.</p>

<p>In an effort to keep this article brief, I’m not going to go too far into the nitty-gritty about the module or how exactly it works; I’ve spent a lot of time writing documentation for that purpose instead. Rather, I’m going to show off a couple of things that I’ve made with it so far, as well as potential things that could be made in the future, to try to illustrate exactly why I spent all this time making it in the first place.</p>
      <h3 id="automatic-item-stack-sizes">
        
        
            <a href="#automatic-item-stack-sizes" class="anchor" style="text-decoration: none;">Automatic Item Stack Sizes</a>
          
        
      </h3>
    

<p>Oftentimes, for you want to figure out how much storage you need for a specific amount of an item. However, storage in Factorio is based on slots, not amounts, so the amount of storage is actually dependent on not only the amount you’re trying to store, but also the stack size of that item. <a href="https://factorioprints.com/view/-LwH68dlvOEIKWkU5JqR">You can design a circuit contraption</a> to determine the number of slots that you need for any input item, but you’d need a big cell of combinators documenting the item sizes. This is <em>boring</em> to make, and easily broken if a new item is added or the stack size is changed. Clearly, for such a simple and repetitive task, a script is better suited:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Create an N x 5 grid of connected constant combinators, with every item and their stack size
</span>
<span class="kn">from</span> <span class="nn">draftsman.blueprintable</span> <span class="kn">import</span> <span class="n">Blueprint</span>
<span class="kn">from</span> <span class="nn">draftsman.constants</span> <span class="kn">import</span> <span class="n">Direction</span>
<span class="kn">from</span> <span class="nn">draftsman.data</span> <span class="kn">import</span> <span class="n">items</span>
<span class="kn">from</span> <span class="nn">draftsman.entity</span> <span class="kn">import</span> <span class="n">ConstantCombinator</span>

<span class="n">COMBINATOR_HEIGHT</span> <span class="o">=</span> <span class="mi">5</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">blueprint</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">()</span>

    <span class="n">signals_added</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">signal_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">combinators_added</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">combinator</span> <span class="o">=</span> <span class="n">ConstantCombinator</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">Direction</span><span class="p">.</span><span class="n">SOUTH</span><span class="p">)</span>

    <span class="c1"># Iterate over every item in order:
</span>    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">.</span><span class="n">raw</span><span class="p">:</span>
        <span class="c1"># Ignore hidden items/entities
</span>        <span class="k">if</span> <span class="s">"flags"</span> <span class="ow">in</span> <span class="n">items</span><span class="p">.</span><span class="n">raw</span><span class="p">[</span><span class="n">item</span><span class="p">]:</span>
            <span class="k">if</span> <span class="s">"hidden"</span> <span class="ow">in</span> <span class="n">items</span><span class="p">.</span><span class="n">raw</span><span class="p">[</span><span class="n">item</span><span class="p">][</span><span class="s">"flags"</span><span class="p">]:</span>
                <span class="k">continue</span>
        <span class="c1"># Keep track of how many signals we've gone through
</span>        <span class="n">signals_added</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Write the stack size signal
</span>        <span class="n">stack_size</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">raw</span><span class="p">[</span><span class="n">item</span><span class="p">][</span><span class="s">"stack_size"</span><span class="p">]</span>
        <span class="n">combinator</span><span class="p">.</span><span class="n">set_signal</span><span class="p">(</span><span class="n">signal_index</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">)</span>
        <span class="n">signal_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Once we exceed the number of signals a combinator can hold, place it and reset
</span>        <span class="k">if</span> <span class="n">signal_index</span> <span class="o">==</span> <span class="n">combinator</span><span class="p">.</span><span class="n">item_slot_count</span><span class="p">:</span>
            <span class="c1"># Add the combinator to the blueprint
</span>            <span class="n">combinator</span><span class="p">.</span><span class="nb">id</span> <span class="o">=</span> <span class="s">"{}_{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">blueprint</span><span class="p">.</span><span class="n">entities</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">combinator</span><span class="p">)</span>
            <span class="c1"># Reset the combinator
</span>            <span class="n">combinators_added</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">combinators_added</span> <span class="o">%</span> <span class="n">COMBINATOR_HEIGHT</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">combinators_added</span> <span class="o">/</span> <span class="n">COMBINATOR_HEIGHT</span><span class="p">)</span>
            <span class="n">combinator</span><span class="p">.</span><span class="n">set_signals</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="c1"># Clear signals
</span>            <span class="n">combinator</span><span class="p">.</span><span class="n">tile_position</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">signal_index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Add the last combinator if partially full
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">combinator</span><span class="p">.</span><span class="n">signals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">combinator</span><span class="p">.</span><span class="nb">id</span> <span class="o">=</span> <span class="s">"{}_{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">blueprint</span><span class="p">.</span><span class="n">entities</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">combinator</span><span class="p">)</span>

    <span class="c1"># Add connections to each neighbour
</span>    <span class="k">for</span> <span class="n">cx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">COMBINATOR_HEIGHT</span><span class="p">):</span>
            <span class="n">here</span> <span class="o">=</span> <span class="s">"{}_{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="s">"{}_{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span>
            <span class="n">below</span> <span class="o">=</span> <span class="s">"{}_{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">blueprint</span><span class="p">.</span><span class="n">add_circuit_connection</span><span class="p">(</span><span class="s">"red"</span><span class="p">,</span> <span class="n">here</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">blueprint</span><span class="p">.</span><span class="n">add_circuit_connection</span><span class="p">(</span><span class="s">"red"</span><span class="p">,</span> <span class="n">here</span><span class="p">,</span> <span class="n">below</span><span class="p">)</span>
            <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Total number of item signals added:"</span><span class="p">,</span> <span class="n">signals_added</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">blueprint</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>This script is concise and easy to follow, but the really amazing thing about Draftsman is that this script is completely dynamic and can adjust to whatever version of Factorio that you’re playing. New items, removed items, or changed stack sizes, regardless of the author of the change, are resolved automatically with the exact same code. For illustration, pictured top-left is what’s generated by running the script for a vanilla game, top-right a game with the medium-sized overhaul modpack <a href="https://mods.factorio.com/mod/space-exploration">Space Exploration</a>, and at the bottom a <a href="https://mods.factorio.com/user/Bobingabout">Bobs</a> + <a href="https://mods.factorio.com/user/pyanodon">Pyanodon</a> mega-modpack:</p>

<p><img src="https://media.alt-f4.blog/ALTF4/61/item_stack_size_output.jpg" alt="Results"></p>

<p>This doesn’t only applies to items either. All entities, instruments, signals, recipes, modules, and tiles are pulled from the emulated load process and then stored in Draftsman for later use. Any script can be designed to be completely flexible across these categories; extra instruments in a new programmable speaker, new module types only in certain machines, complete virtual signal lists for signal mappings, etc., all are interpreted correctly by Draftsman. By saving the data of the current mod configuration internally for later, this also means that you only have to update the data once, each time you change what mods you’re using.</p>
      <h3 id="image-to-blueprint-converter">
        
        
            <a href="#image-to-blueprint-converter" class="anchor" style="text-decoration: none;">Image to Blueprint Converter</a>
          
        
      </h3>
    

<p><a href="https://github.com/redruin1/factorio-draftsman/blob/main/examples/image_converter.py">This was something I made on a whim.</a> It uses the <code class="language-plaintext highlighter-rouge">Pillow</code> image library to load an image, and converts it to a blueprint intended to be visible from the map view, all in less than 150 lines of code:</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/mike_stoklasa.jpg" alt="Portrait of Mike" style="max-width: ; max-height:  ">
        
        <figcaption>A peculiar man with a comically large flask, colorized.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Many improvements could be made to this:</p>

<ul>
  <li>Dithering is only implemented on 1x1 tiles; I was having trouble adjusting the algorithm to multi-tile entities.</li>
  <li>Multi-tile entities also fail to adjust the error metric property; palettization doesn’t work as well when some pixels are of different sizes.</li>
  <li>Some multi-tile entities have different rotations; a better implementation would check which orientation produces the least error before placing, instead of only placing them with the default orientation.</li>
  <li>The colors themselves are hardcoded; it would be nice to dynamically load this from the game, especially with modded map colors…</li>
</ul>

<p>Despite these shortcomings, the output actually ends up pretty good for its quick and dirty implementation. This shows that Draftsman is versatile enough for some rather eclectic purposes.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/jay_bauman.jpg" alt="Portrait of Jay" style="max-width: ; max-height:  ">
        
        <figcaption>Jay Bauman, notorious hack fraud, criminal at large. Armed and dangerous.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>
      <h3 id="factorio-movie-player-resurrection">
        
        
            <a href="#factorio-movie-player-resurrection" class="anchor" style="text-decoration: none;">Factorio Movie Player Resurrection</a>
          
        
      </h3>
    

<p>A little while ago, while trawling for projects to use as examples for this very article, I came across the classic <a href="https://www.youtube.com/watch?v=mgfwwqwxdxY">Factorio Sandstorm</a>. A perfect project to adapt; or, it would have been, if I could actually load the map in-game! The original map version was still dated to the tender version of <code class="language-plaintext highlighter-rouge">0.14.20</code>. In addition, a lot of the migrations that took place over such a long span of time broke the functionality of the script to convert the image frames into map data, as well as some functionality of the map itself, so just downloading an old version of Factorio and coercing it along wasn’t going to be enough to revive the old save. For example, the <code class="language-plaintext highlighter-rouge">build.lua</code> script in charge of encoding still called the <code class="language-plaintext highlighter-rouge">automation-science-pack</code> and <code class="language-plaintext highlighter-rouge">logistic-science-pack</code> items <code class="language-plaintext highlighter-rouge">science-pack-1</code> and <code class="language-plaintext highlighter-rouge">science-pack-2</code>. That should give you some indication of how old the map was!</p>

<p>It troubled me, seeing such an iconic piece of Factorio history fall into disrepair. So I took the time to fix the issues and migrated it all the way to 1.1.57:</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 1200px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/61/cut_and_shrunk.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      video of feel the beat
    </video>
    <figcaption>Pictured is part of <a href="https://youtu.be/aLZQ-0dHbiU?t=38">Feel the Beat</a>, keeping the tradition of Darude music videos.</figcaption>
  </figure>
</p>

<p>Changing the build script could be done by hand, but the signal <code class="language-plaintext highlighter-rouge">raw-wood</code> that the machine internally used no longer exists in modern Factorio. In order to fix it, I replaced all occurrences of the signal with it in the map with <code class="language-plaintext highlighter-rouge">artillery-wagon</code> (since I knew it would be unique), and that map updating was done with a script running Draftsman code. I also added a number of other scripts for extracting the images from the source, as well as taking screenshots of the result and stitching them into an output video, which is pretty easy in Python. I used said scripts to make the output above.</p>

<p>I was also playing around with the idea of using Draftsman to make a blueprint-based version of the builder script, instead of the console-based original method; this would allow you to see exactly what parts of the memory you are modifying by placing a grid aligned blueprint on top of them, and would also allow you to extend the memory of the machine by simply adding more blocks (the memory provided on the map is only enough for 4800 frames). I figured this was less important than updating what was there originally, especially when the code that <em>was</em> already there I knew worked. There could be other considerations as well; the amount of encoded data is pretty hefty, especially for blueprint strings which I suspect may be less dense than the console scripts, which are so large they are dumped in text files when built. Determining whether a blueprint method was actually feasible I figured could wait until I had some spare time further down the line.</p>

<p>For more information on what’s changed/new, as well as the updated world file, <a href="https://github.com/redruin1/factorio-movie-maker">you can check out my fork here</a>.</p>
      <h3 id="whats-next">
        
        
            <a href="#whats-next" class="anchor" style="text-decoration: none;">What’s next?</a>
          
        
      </h3>
    

<p>While I’ve done a bunch of things with this module, the whole point of it was to make it easy for <em>anyone</em> to do a whole bunch of other things as well. Some ideas that I would like to do, but have yet to do, I will defer here as food for thought:</p>

<ul>
  <li>
    <p>Many combinator computer compilers are written via script. Perhaps someone could devise a LLVM equivalent; a generic compiler, where you can tell it what instructions your CPU can perform and have it compile high level, established languages like C. Perhaps you could even use LLVM itself?</p>
  </li>
  <li>
    <p>Take advantage of edge case behavior for specific optimization problems. <a href="https://forums.factorio.com/viewtopic.php?t=57198">Did you know that you can set entities to request <em>any</em> item, not just modules</a>? You can only request items when originally constructed, which limits its usefulness somewhat, but robots will fulfill the request, allowing you to “kickstart” production in some cases. With something like the <a href="https://mods.factorio.com/mod/recursive-blueprints">Recursive Blueprints mod</a>, by placing assembling machines with item requests, and then deconstructing them when they’ve finished consuming their inputs, theoretically you can build a fully automated factory with only construction bots. Perhaps the <a href="https://www.youtube.com/watch?v=9dzQge6pe2o">Micro Factory</a> can be further optimized? Or a new goal could be to have the fewest total number of entities to launch a rocket without user input?</p>
  </li>
</ul>

<p>A perhaps more generally applicable use case is <a href="https://factoriobin.com/post/p38zvEAP">this blueprint</a>, a single gun turret that automatically requests 200 red ammo from the logistics network when placed. This is particularly useful in offensive efforts on large biter nests, as you can spam turrets around you and the bots in your inventory will create the turrets and deliver the ammo automatically, allowing you to focus on not dissolving in spitter goo.</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 800px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/61/preloaded_turret_short.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      An illustration of the turret blueprint in action
    </video>
    <figcaption></figcaption>
  </figure>
</p>

<ul>
  <li>
    <p>Routing problems; pass in a set of outpost points and use an algorithm to automatically connect them to minimize distance, number of crossings, etc. Perhaps you could have it read from save files themselves?</p>
  </li>
  <li>
    <p>Combinator contraptions are usually very complex and unintuitive for the layman to decode, as I have found out during my extensive exploration in the introduction. This is due to the density of the circuits, the hidden operations of each combinator, the rat’s nest of wires that is generated with no way to cleanly route them in small areas, and the inability to give labels to combinators or the wires that connect them. It would be nice to have a piece of software that can do take a blueprint string input, and allow the user to do all of the above to create easily decodable and understandable documentation for complex circuit contraptions. I’d love to use such a thing to create vectorized circuit diagrams for my computer. When I finish it. Eventually.</p>
  </li>
  <li>
    <p>Use <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction">constraint satisfaction</a> to design blueprints. I’ve experimented with this in the past, and it should be possible; assuming you can get the time complexity down from <code class="language-plaintext highlighter-rouge">O(MFG)</code>. If I end up writing another article for Alt-F4, it might be on this.</p>
  </li>
  <li>
    <p>You can also use neural networks for the previous goal; this is Python after all! I wonder if you could actually get some usable blueprints this way. Perhaps if you train it on the entirety of <a href="https://www.factorio.school/">factorio.school</a>…</p>
  </li>
</ul>

<p>Hopefully that should give the creative ones among you some interesting ideas. And maybe, <em>just maybe</em>, when someone needs to write a script for some specific problem to save themselves some time, they can actually save themselves some time instead of spending three to four months writing a Python module from scratch.</p>

<p>Eh, it was still pretty fun to make. Educational, too.</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 1276px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/61/it_works.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      It works!
    </video>
    <figcaption>Thank heavens.</figcaption>
  </figure>
</p>

<p>Ah, finally. Back to <em>real</em> work.</p>
      <h2 id="contributing">
        
        
            <a href="#contributing" class="anchor" style="text-decoration: none;">Contributing</a>
          
        
      </h2>
    

<p>As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the <a href="https://alt-f4.blog/it/discord">Discord</a> to get started!</p>





<script>
  (() => {
    if (window.innerWidth >= 720) {
      document.getElementsByClassName('toc')[0].setAttribute('open', '')
    }
  })()

  var slideIndex = 1;
  showSlides(slideIndex);

  function plusSlides(n) {
    showSlides(slideIndex += n);
  }

  function currentSlide(n) {
    showSlides(slideIndex = n);
  }

  function showSlides(n) {
    var i;
    var slides = document.getElementsByClassName("galleryItem");
    var dots = document.getElementsByClassName("galleryPreview");
    var captionText = document.getElementById("caption");
    if (n > slides.length) { slideIndex = 1 }
    if (n < 1) { slideIndex = slides.length }
    for (i = 0; i < slides.length; i++) {
      slides[i].style.display = "none";
    }
    for (i = 0; i < dots.length; i++) {
      dots[i].className = dots[i].className.replace(" active", "");
    }
    slides[slideIndex - 1].style.display = "block";
    dots[slideIndex - 1].className += " active";
    captionText.innerHTML = dots[slideIndex - 1].alt;
  }
</script>

		
<div class="flex flex-column flex-items-center mt8">
  
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://alt-f4.blog/it/discord">
    Discutine su Discord
  </a>
  
</div>


	</div>
	<div class="panel-inset mb0 p4 flex">
		<div>
		<!-- Previous Button -->
		
		<a href="/it/ALTF4-60/" class="button square-sm"><i class="fas fa-angle-double-left"></i></a>
		
		<a class="button square-sm" href="/it/">
			<i class="fas fa-home"></i>
		</a>

		<!-- Next Button -->
		
		<a class="button square-sm  disabled">
			<i class="fas fa-angle-double-right"></i>
		</a>
		
		</div>
	</div>
</article>

      </div>
    </div>


    <!-- Footer -->
    <footer class="footer">
  <div class="footer-inner panel">

    <div class="footer-links panel-inset slots p1 mt0 mb0">
      <a href="/it/about" class="slot" title="About">
        <div class="slot-button">
          <i class="fas fa-info"></i>
        </div>
      </a>
      <a href="https://github.com/AlternativeFFFF/Alt-F4" class="slot" title="Github">
        <div class="slot-button">
          <i class="fab fa-github"></i>
        </div>
      </a>
      <a href="https://alt-f4.blog/it/discord" class="slot" title="Discord">
        <div class="slot-button">
          <i class="fab fa-discord"></i>
        </div>
      </a>
      <a href="/it/atom.xml" type="application/atom+xml" rel="alternate" class="slot" title="ATOM Feed">
        <div class="slot-button">
          <i class="fas fa-rss"></i>
        </div>
      </a>
      <a href="https://www.freelists.org/list/alt-f4" class="slot" title="Email Newsletter">
        <div class="slot-button">
          <i class="fas fa-envelope"></i>
        </div>
      </a>

      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
    </div>
    <div class="footer-rocket panel-inset m0">
      <div class="spidertron-center">
        <div id="spidertron" class="spidertron-home" data-spidertron-scale="0.6" data-spidertron-speed="400"></div>
      </div>
      <div class="shadow-overlay"></div>
      <div class="shadow-overlay-bottom"></div>
    </div>
    <div class="footer-copyright panel-inset m0">
      Questo è un progetto gestito dai fan e non direttamente dagli sviluppatori Wube Software Wube Software
    </div>
  </div>
</footer>

  </body>

</html>
