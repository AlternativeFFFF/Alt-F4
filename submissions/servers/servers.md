## Factorio Servers <author>oof2win2</author>

Most of us have been at the point of connecting to a Factorio server at least once, to play with friends or just check out builds of someone else.

### History of Multiplayer

In October 2014 with `0.11.0`, multiplayer itself was introduced into the game, it was however being worked on since [`0.9.4`](https://www.factorio.com/blog/post/fff-26). This multiplayer was unlike the one you see today, you couldn't easily 'Join Friend' through Steam or use the server browser - you needed to know the exact IP address of the server. When the first multiplayer was released, there were quite a few bugs, such as [this bug](https://forums.factorio.com/viewtopic.php?t=6285), which didn't allow multiplayer games to last more than 20 seconds. It was of course fixed not even 3 hours later in typical Wube fashion. There was also [this bug](https://forums.factorio.com/viewtopic.php?t=6414), which didn't allow more than 3 people to connect at once - unlike [this 500 players multiplayer session](https://www.factorio.com/blog/post/fff-332) nearly 6 years later. A lot of work has been put into multiplayer development for 500 players to be able to connect at once.
In `0.12.0`, as a major feature, headless servers were added. This means that servers could now run on machines without GPUs, which greatly reduced the cost of Factorio servers and improved accessibility. It also allowed multiple instances (Factorio servers) to run at the same time on one machine, which is very useful in some cases. This is a feature that is however not useful for you, the player.
In `0.14.0`, Factorio servers no longer pause the game for other players if one player's computer takes too long to process an update. This means that if you have an older computer, a server will no longer wait for you to catch up in processing. This is very useful on larger servers which can have tens to hundreds of players online at once, as nobody has to wait for one single person so they can play the game.
Since version `0.14.4`, multiplayer hasn't been touched according to it's [wiki page](https://wiki.factorio.com/multiplayer#History).

### Fully Deterministic Game Approach

Since we now know when Factorio multiplayer was created, let's check how it works behind the scenes.

As mentioned in [FFF-30](https://www.factorio.com/blog/post/fff-30), all clients and the server must simulate the game in the same way, exactly the same actions at (preferably) exactly same ticks. This means that if one person does something on their own computer, other people's instances of Factorio need to do the same. Instances are an occurrence of something, for example there can be many instances of apples in a basket or tabs in Chrome. To simulate the game, Factorio uses [Lockstep algorithms](https://en.wikipedia.org/wiki/Lockstep_(computing)). In generic programming, these algorithms allow a program to run multiple times on multiple instances, to simulate the program and check if an error has been made somewhere in the code. If only two instances are running, the 'Voting Circuit' (a piece of code that votes which instance calculated it correctly) chooses only one instance to be correct, but it is not known which instance did it correctly. If there are three or more instances, the 'Voting Circuit' votes with a majority vote. For example, if 2 instances would have the same results and the 3rd one would have a different result, the 'Voting Circuit' would choose the most common answer and correct any other answers, so it would correct the 3rd instance. The name of Lockstep algorithms comes from [armies marching](https://en.wikipedia.org/wiki/Lockstep) in the way that everybody's legs move in the same way, which is also what Lockstep algorithms do. See the image below as an example:

{% include image.html src='lockstep-marching.jpg' %}


A [Fully Deterministic algorithm](https://en.wikipedia.org/wiki/Deterministic_algorithm) is also used in Factorio. A such algorithm will produce the same output when given the same input. This means that there is no randomness in the results, which is very useful in some cases such as Factorio. A Fully Deterministic algorithm is defined by the following:
- It must not use any other data other than the input to the algorithm. Disallowed is: random numbers, stored disk data, global variables, timers (i.e. from when the program is running)
- The algorithm must operate in a way that is not time-sensitive. An example of the opposite of this would be if multiple instances of a program were writing into an Excel spreadsheet and another program would read the last line of the sheet. This would make the program time-sensitive as if one instance of the writing programs is delayed by a few seconds, it can produce a completely different order of the Excel rows, leaving the program that reads the last line with a completely differen input
As explained in [Therenas's cover on 1.1 optimizations](https://alt-f4.blog/ALTF4-15/#how-does-this-optimization-work-on-a-technical-level), if things were all multithreaded, the order of things updating wouldn't work exactly as it should, which makes the game updated partially Fully Deterministic algorithms from the second definition! The main part of that article however stops the *whole update cycle* from being a Fully Deterministic algorithm as belts are now multithreaded - the order in which they update is not guaranteed.

Examples of Lockstep and Fully Deterministic algorithms:

Ex. 1: If you and your friend create a map with the exact same blueprint exchange string, your first U235 from the Kovarex Enrichment process will be the same amount of processes done in total (the centrifuges will cycle the same amount of times before outputting the U235). Even though there is a random chance (0.07%) of you getting the U2335, the game's random number generator is serialized the same - I will explain this more in-depth later.

Ex. 2: Another, more complex, example of this would be a client stamping down a blueprint. A client is someone who is connected to the main server, which in this case are players connected to a multiplayer server. All blueprints are saved in the *shared* game library, which is **not the one you see in the Game Blueprints tab**. Instead, it is the one for different clients to know what blueprints different players have, which is why when blueprints are not shared yet, they are grayed out like the image on the left below. They are grey because they are in your *local* game library, but not in the *shared* library. When you have your blueprints imported to the shared library, the blueprint icons won't be grayed out anymore, such as the right image below. This is because when you click on them, you choose to transfer them to the game's *shared* library - still not in the *Game Blueprints* tab though. Players can't place them down themselves (the blueprints don't show up in the Game tab), but their individual game instances can "place" them down when necessary (place the entities if they are told to do so). When you, the one who has the blueprint, place a blueprint down after it is transferred to the game's shared library, your client tells the server that you placed the blueprint down at XY coordinates. The server then tells all other connected clients that it has been placed down at those same coordinates. Every individual client then simulates all robots coming out of their roboports, getting resources, placing the entity they have, and coming back to their chosen roboport. All clients simulate this by themselves without any further input - the only exception to this if a *player's personal roboport construction area enters* a part of the area where something is to be placed and the player has said item - then that player's client sends out information that they have said item and their robot is placing it down.

{% include compare.html id="0" old='blueprints-not-imported.png' new='blueprints-imported.png' %}

This whole idea of Lockstep and Fully Deterministic algorithms lessens the probability of a [desynchronization](https://wiki.factorio.com/Desynchronization) (desync) happening, but the chance is still there. Normally, when the client and server are doing the same thing at the same time, they are happy, as they are synchronized (in sync). When they fall out of sync, a desync happens (see image below). During a desync, a player is instantly disconnected from the game and starts downloading the map the server has to include in a desync report, which can then be useful to mod creators or Factorio devs, depending on what causes the desync.

{% include image.html src='https://spectacularagency.files.wordpress.com/2010/09/lockstep.jpg' %}

You may wonder, how do desyncs not occur with robots moving across the map? Surely if they all do tasks and some robots are chosen to do said tasks, different clients might choose different robots to perform those tasks, no? Nope. Somewhere in the game's C++ code, there is a list of inactive robots (robots returning to roboports). If there aren't any close to the site of the building, the game dispatches a 'fresh' robot from a roboport. The ghosts are iterated over sequentially - they are put in a list, probably according to the XY coordinate of the entity, and the robot with the shortest path to that entity is dispatched (from roboport to logistic chest to entity). Keep in mind, this information **is an incomplete thought** of *curiosity* as nobody (except for the game developers) knows how this works exactly.

This has been only one example of many things that can go wrong with multiplayer: robot construction, biter AI simulations, and even mod things.

Even if you would want to use something as simple as `math.random()` in a mod or scenario of yours, there would be consistent results - all clients would get the same result of the function. If you know a bit of programming, you may understand seeding a random function. If not, seeding a random function is done with a so-called 'random seed', which initializes the random number generator. It is important to note it is a *pseudorandom* generator, and therefore not truly random, as it is initialized with a pre-determined number, which allows the results to be reproduced anywhere. See [this](https://en.wikipedia.org/wiki/Random_seed). According to [this StackOverflow answer](https://softwareengineering.stackexchange.com/a/298616), a pseudorandom number generator works by seeding it with a number first. Then, you would multiply the said number with an [extremely large prime number](https://primes.utm.edu/primes/search.php?Number=100). The number that is used as a seed is then increased by 1, which results in a completely different number after multiplication.

I couldn't explain everything about this in one simple post. If you would want to learn more about this, you should probably visit one of these:
- [Wikipedia: Pseudorandom number generator](https://en.wikipedia.org/wiki/Pseudorandom_number_generator)
- [Wikipedia: Deterministic Algorithm](https://en.wikipedia.org/wiki/Deterministic_algorithm)
- [FFF#26](https://www.factorio.com/blog/post/fff-26)
- [FFF#30](https://www.factorio.com/blog/post/fff-30)