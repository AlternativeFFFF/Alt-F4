## Factorio Servers <author>oof2win2</author>

Most of us have been at the point of connecting to a Factorio server at least once, to play with friends or just check out builds of someone else. In today's edition of Alt-F4, I will briefly explain the history of multiplayer, and then I will take a deeper dive into explaining *how* multiplayer works. I will be explaining the usage of Fully Deterministic algorithms and Lockstep algorithms amongst other things.

### History of Multiplayer

In October 2014 with Factorio 0.11.0, multiplayer itself was introduced into the game, it was however being worked on since [Factorio 0.9.4](https://www.factorio.com/blog/post/fff-26). This multiplayer was unlike the one you see today, you couldn't easily 'Join Friend' through Steam or use the server browser - you needed to know the exact IP address of the server. When the first multiplayer was released, there were quite a few bugs, such as [this bug](https://forums.factorio.com/viewtopic.php?t=6285), which didn't allow multiplayer games to last more than 20 seconds. It was of course fixed not even 3 hours later in typical Wube fashion. There was also [this bug](https://forums.factorio.com/viewtopic.php?t=6414), which didn't allow more than 3 people to connect at once - unlike [this 500+ player multiplayer session](https://www.factorio.com/blog/post/fff-332) nearly 6 years later. A lot of work has been put into multiplayer development for 500 players to be able to connect at once.

In Factorio 0.12.0, as a major feature, headless servers were added. This means that servers could now run on machines without GPUs, which greatly reduced the cost of Factorio servers and improved accessibility. It also allowed multiple instances (Factorio servers) to run at the same time on one machine, which is very useful in some cases.

In Factorio 0.14.0, Factorio servers no longer pause the game for other players if one player's computer takes too long to process an update. This means that if you have an older computer, a server will no longer wait for you to catch up in processing. This is very useful on larger servers which can have tens to hundreds of players online at once, as nobody has to wait for one single person so they can play the game.

Since version Factorio 0.14.14, multiplayer hasn't been majorly changed according to its [wiki page](https://wiki.factorio.com/multiplayer#History) (this means there have been some improvements such as optimizations, but not large game-changing features).

### Fully Deterministic Game Approach

As mentioned in [FFF-30](https://www.factorio.com/blog/post/fff-30), all clients and the server must simulate the game in the same way, exactly the same actions at exactly same ticks. This means that if one person does something on their own computer, other people's instances of Factorio need to do the same. Instances are an occurrence of something, for example, there can be many instances of apples in a basket or tabs in Chrome. Factorio is a different game from CS:GO or Overwatch, so the devs couldn't just take the implementation from CS:GO and port it to Factorio, as it wouldn't work properly. Instead, during the creation of multiplayer, the developers created multiplayer using the [Lockstep protocol](https://en.wikipedia.org/wiki/Lockstep_protocol). This protocol (algorithm/way of doing things) allows Factorio to run in a different way than games such as Overwatch. In  Factorio, the connection to the server starts with the server giving you the map and that's it. Then, the server tells you if something changes, such as if a player places a belt at some coordinates, dies from a biter etc. You only get told *that* it happened. Your client (a client is someone who is connected to the main server, which in this case are players connected to a multiplayer server) has to alter it's own simulation by itself, it doesn't get told what is currently happening (bots moving, trains stopping). That would require a lot of network bandwidth, as you would need to transfer information such as "this logistic bot moved here", which would need to happen tens of thousands of times per tick in large saves, not to mention other information, which would be transferring the whole save every tick (generally around 25MB), which takes up too much network bandwidth to happen 60x per second. Instead, you only get told the really important information (mainly interactions of players with the game) and then your client runs the game as if nobody else was there.

There are many ways using which a game can handle multiplayer. For example, [Overwatch](https://playoverwatch.com) is a game that keeps track of most of things. The difference of these two implementations of multiplayer are that Overwatch monitors every item, player, bullet etc. and only corrects your client if something went wrong, whilst Factorio monitors only player inputs and throws a desync if something goes wrong (I'll explain what a desync is later). These two implementations are different because the games are radically different: in Overwatch, you can have all the maps downloaded when you initially download the game, so you need to only transfer player and projectile positions. In Factorio, maps however change all the time. You have different positions of assemblers, lamps, power poles, belts, inserter positions, and pretty much everything, as every base is unique. This is the reason why in Factorio, only the changes caused by players are transferred, as Factorio can simulate the game as if it were singleplayer, just recieving player changes from the server. It is much easier than transferring the whole map to just give the client the map when they connect and tell them any other inputs that would alter the simulation, such as a player moving 10 tiles to the right etc. See image below. How Overwatch works has all been explained [here (shorter video)](https://www.youtube.com/watch?v=vTH2ZPgYujQ) and [maybe here too](https://www.youtube.com/watch?v=W3aieHjyNvw) by Overwatch developers in higher detail with additional information about Overwatch's network handling. 

{% include image.html src='./factorioserverjoin.png' %}

A [Fully Deterministic algorithm](https://en.wikipedia.org/wiki/Deterministic_algorithm) is also used in Factorio. Such an algorithm will produce the same output when given the same input. This means that there is no randomness in the results, which is required in some cases such as Factorio. A Fully Deterministic algorithm is required when multiple instances of Factorio are run so all instances run in a lockstep algorithm and are in sync. The reason for a Fully Deterministic algorithm would be that if you have functions that produce random outputs, you can't use the Lockstep Architecture, which means that the whole system screws up if the functions that process things don't give the same results all the time (same results for all clients). A Fully Deterministic algorithm is defined by the following:
- It must not use any other data other than the input to the algorithm. Disallowed data: random numbers, stored disk data, global variables, timers (i.e. from when the program is running)
- The algorithm must operate in a way that is not time-sensitive

An example of the opposite of this would be if multiple instances of a program were writing into an Excel spreadsheet and another program would read the last line of the sheet. This would make the program time-sensitive as if one instance of the writing programs is delayed by a few seconds, it can produce a completely different order of the Excel rows, leaving the program that reads the last line with completely different input.

A thread is something like if you are a business owner and you want to do something faster, so depending on the situation, you can assign more people to work on the said task, as it allows multiple parts of the task to be done at once. As explained in [Therenas's cover on 1.1 optimizations](https://alt-f4.blog/ALTF4-15/#11-performance-improvements-therenas) and [FFF#364](https://www.factorio.com/blog/post/fff-364), if things were all multithreaded, the order of things updating wouldn't work exactly as it should, which makes the game updated partially Fully Deterministic algorithms from the second definition! The main part of that article however explains how they made belts multithreaded again, so how did the developers manage to do so, if it would make the game non Fully Deterministic? The main issue was that inserters wouldn't work properly, as they would be tried to be activated by both threads of the belt, which depending on the order, could cause a desync. This issue has been dealt with by creating a wake-up list (a sort of a todo-list), which is run after all belts are updated, which allows the inserters to move correctly. This process ensures that the inserters "wake up" in the correct order.

Examples of Lockstep and Fully Deterministic algorithms:

Ex. 1: If you and your friend create a map with the exact same blueprint exchange string, your first U235 from the Kovarex Enrichment process will be the same amount of processes done in total (the centrifuges will cycle the same amount of times before outputting the U235). Even though there is a random chance (0.07%) of you getting the U2335, the game's random number generator is serialized the same - I will explain this more in-depth later.

Ex. 2: Another, more complex, example of this would be a client stamping down a blueprint. When you click on a blueprint to have your blueprint imported to the shared library, the blueprint icons won't be grayed out anymore, such as the right image below. This is because when you click on them, you choose to transfer them to the game's shared library. When you, the one who has the blueprint, place a blueprint down after it is transferred to the game's shared library, your client tells the server that you placed the blueprint down at XY coordinates. The server then tells all other connected clients that it has been placed down at those same coordinates. Every individual client then simulates all robots coming out of their roboports, getting resources, placing the entity they have, and coming back to their chosen roboport. All clients simulate this by themselves without any further input (there are *some* edge cases though).

{% include compare.html id="0" old='blueprints-not-imported.png' new='blueprints-imported.png' %}

A desynchronization (desync) is when two computers are supposed to be doing something at the same time with the same results from Fully Deterministic algorithms. If a modder or scenario creator have not managed data well, it can cause a desync too, as the data is not the same across multiple clients. This can make your client forcefully log off from the server and generate a desync report, which is something that the developers use to investigate these desyncs. This whole idea of Lockstep and Fully Deterministic algorithms essentially eliminates the probability of a [desynchronization](https://wiki.factorio.com/Desynchronization) (desync) happening, but they still happen on odd occasions. Normally, when the client and server are doing the same thing at the same time, they are happy, as they are synchronized (in sync). When they fall out of sync, a desync happens. A desync can occur due to two clients calculating an update with different results. During a desync, a player is instantly disconnected from the game and starts downloading the map the server has to include in a desync report, which can then be useful to mod creators or Factorio devs, depending on what causes the desync. See the image below for an example of how a desync can happen.

{% include image.html src='desync-chat.png' %}

You may wonder, how do desyncs not occur with robots moving across the map? Surely if they all do tasks and some robots are chosen to do said tasks, different clients might choose different robots to perform those tasks, no? Nope. Every client will always choose the same robot at the same time because the algorithm that chooses the robot is *fully deterministic*. Two trains coming in from a stacker into a station? Always the same train, as this is *also fully deterministic*. Which turret does a spitter decide to attack your mining outpost? Also fully deterministic. These have been just a few examples, but **everything** in the game is fully deterministic. If it weren't, you would have one desync here, another one there, and multiplayer wouldn't be playable at all. In multiplayer, desyncs can be caused by numerous things, such as robot construction, biter AI simulations, and most of all, things caused by modders themselves.

Even if you would want to use something as simple as `math.random()` in a mod or scenario of yours, there would be consistent results - all clients would get the same result of the function. If you know a bit of programming, you may understand seeding a random function. If not, seeding a random function is done with a so-called 'random seed', which initializes the random number generator. It is important to note it is a *pseudorandom* generator, and therefore not truly random, as it is initialized with a pre-determined number, which allows the results to be reproduced anywhere. See [this](https://en.wikipedia.org/wiki/Random_seed). According to [this StackOverflow answer](https://softwareengineering.stackexchange.com/a/298616), a pseudorandom number generator works by seeding it with a number first. Then, you would multiply the said number with an [extremely large prime number](https://primes.utm.edu/primes/search.php?Number=100). The number that is used as a seed is then increased by 1, which results in a completely different number after multiplication.

Now you know a bit more about what happens when you click on a server in the server list, join by IP, through Steam or over LAN. The developers of Factorio have been working very hard on multiplayer and are pretty keen about what happens with it. They allow us to create large games such as the over-500-player multiplayer session or create games with [Clusterio](https://alt-f4.blog/ALTF4-18/#the-road-to-clusterio-20-hornwitser), providing creators with tools they need to develop the fun stuff they do. There are less and less limitations to what you can do, massive bases, massive amounts of players, maybe even both! All of that is up to you and how you set it up.
