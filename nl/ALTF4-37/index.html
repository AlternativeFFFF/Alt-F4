<!DOCTYPE html>
<html lang="nl" class="nl">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Alt-F4 #37 - Combinator Crash Course Continuation</title>
	<!-- Meta -->
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">

	<!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="Alt-F4 #37 - Combinator Crash Course Continuation">
<meta name="author" content="pocarski">
<meta property="og:locale" content="en">
<meta name="description" content="On the 37th week during which an issue of Alt-F4 is being released, we present: Issue #37! What a surprise! In it, long-time contributor pocarski is back with yet more very approachable explanations of how you can spice up and optimize your base with but a few combinators! Combinators 2: Augmented Logistics pocarski Several weeks ago, I wrote an article about using combinators to improve specific builds. This time we’ll take a look at ways to apply the circuit network more generally, to make your whole factory more efficient. We will look at the pitfalls of conventional design, we will come up with ways to solve them, and we will implement those solutions using the circuit network. Such improvements can be done to both bots and trains, and the circuitry is so simple it almost doesn’t require decider combinators at all. Let’s dive right in! Bots: Network-to-network interface We’ve all had this issue: you create more bot demand, and suddenly all the bots from the far end of your base decide it’s a good idea to travel thousands of tiles across roboport-less areas. In the best case, this will cause mild frustration at the striking similarity to real-life delivery services, and in the worst case, bots will keep getting destroyed by biters, or turning around part way through to charge at the roboports they just left, leaving you with no throughput whatsoever. This happens when your logistic network has an inward-facing corner, creating a huge logistics-deprived area, which dumb straight-line-pathing bots will immediately start cutting right through. This base’s bots don’t have enough battery charge to cross the concavity, so they keep turning around halfway through. So, to avoid this, a rule was written: “Thou shalt not create concave logistic networks”. Sounds simple, right? Just have your base be a massive rectangle of roboports, and there will simply be no corners to cut. This is a valid solution, but it puts very significant constraints on your expansion, since you’ll be forced to expand the rectangle to cover all of your newly-acquired real estate. This causes situations where your actual base only takes up a tiny fraction of the area covered by your logistic network. Expanding this base’s logistic network to be a rectangle that covers that long stalk on the bottom would mean quite a lot of biter extermination. A much better way to approach this issue is to separate your networks. Essentially, instead of making one huge rectangle, you make a bunch of unconnected smaller ones, which you can then arrange to cover any shape you want. This way, any single network is still convex, meaning bots will never leave the roboport coverage. That’s a good solution, but how does one get items to travel across the gaps between networks? This is where circuits come in. Let’s construct two networks with a one tile gap in between, and call them network A and network B. The items will cross this gap using a stack inserter placed between a requester chest and an active provider chest. For any items we want to move from A to B, we should set the request on A’s requesters to be the amount of items we wish to transfer. We can transfer items from B to A in a similar way. While we can design complex ways to figure out exactly how much of what needs to go where, we’ll stick to a simple solution that works well enough for most purposes: keep both networks at equal amounts of items. To do this, we will determine half of the difference between network contents of each item, and force the network with more of that item to send that many of them to the network with less of that item. Here is a crappy diagram outlining this idea: We connect a roboport in network A to a pair of arithmetic combinators, one multiplying by 1, and the other multiplying by -1. This will give us a positive and a negative value for the items in the network. We do the same for network B. We then connect the negative value of one network to the positive value of the other. This will give us the difference between their contents. We then divide this value by 2 and feed it to the requesters. It’s important that the chests on the side with more items get a positive value, or else the system will do the exact opposite of what we want. It’s also important to round up the value to your robot cargo size, or else they can be flying back and forth forever trying to fix a two item difference by moving four items at a time. Because one inserter going each way is a bit slow, we can add more. If we just blindly add more chests, then the request of each one will be half the difference, meaning the actual request will be several times more than it’s meant to be. We need to divide the incoming difference by the number of chests, and also add the remainder on to one of the chests. Once again, rounding up to robot cargo size is paramount. This rounding does mean that networks are not going to become strictly equal, but it’s a necessary sacrifice. This circuit will now do its best to keep the networks’ contents level, with an error of a couple of items. The bots will do a bit of back and forth, because there is a delay between items being removed from one network and added to the other, which means it overcorrects slightly at first. With more than two networks, not much changes. Because each pair of networks tries to equalize the item counts, all items gradually spread more or less evenly through the whole system. This circuit is infinitely adjustable and customizable. You may add a biasing factor to have the network contents be in a specific ratio, or you may add conditions for when to apply the bias and to what items, and whatever else you can figure out how to do. In my opinion, that is an even more important feature than the simplicity. Trains: Vanilla LTN analogue Moving on from bots to trains then: Trains are very powerful, but trains are also dumb. In a complex system with many stations having the same name, you’re pretty much forced to use circuits because otherwise, trains will keep pathing to the same stations, overcrowding them while starving the rest. The conventional way to control train pathing was to disable stations that don’t need trains, forcing trains to path somewhere else. This is, however, a very crude and inefficient method, with multiple issues: trains repathing inside junctions may cause deadlocks, a single station being enabled triggers an avalanche of trains, and the extra trains from that avalanche create unnecessary traffic. There are also existing circuit systems, such as Haphollas’s Vanilla Train Network, which alleviated some of those problems, but still not all of them. The popular way to avoid all this mess is to use mods. One of the most popular and influential mods for Factorio is LTN, or Logistic Train Network. It essentially implants a logistic bot’s brain into your trains, and gives your stations the functionality of provider and requester chests. You just set what each station wants and the trains will figure the rest out themselves. Needless to say, the mod allows colossal improvements in efficiency. One would expect such a fundamental change to the system to be nearly impossible to recreate with combinators, and they would be correct. It is however extremely easy to create a much simpler, albeit somewhat less efficient, version of LTN using circuits. Today, I introduce the “Train Limit Dispatcher and Requester”, or TLDR. It is a set of very basic circuits that multiple people invented independently, making use of the train limits that were introduced in 1.1 to act as train request flags. The major simplification is that unlike LTN proper, in the TLDR system almost every train or station is dedicated to a single resource. The logic is simple: For every provider station, calculate the number of “train loads” you have in storage, and set that as your train limit. For every requester, do the same with the difference between request and contents. Each train then just goes between provider and requester with “cargo full” and “cargo empty” conditions. In this example, a provider’s stored iron plates are divided by 16000, because that’s how many iron plates can fit in four wagons. TLDR solves all the problems that the classic station-disabling solution has. Trains will never cause deadlocks by repathing inside junctions, since unlike disabling a station, changing its train limit does not force a repath. An excess amount of trains will never be released into a station, since only as many as the train limit allows will be able to leave. No train avalanching means less traffic, higher throughputs, and less trains needed, which also means better game performance. However, nothing is quite as simple as it sounds. For example, if a train unloads at a requester, but no provider is ready, then it just stands there, starving the requester. This means we need a central depot, so trains always have somewhere to go to free up a requester station. The depot can be as bare bones as it gets: just a bunch of stations with train limit at a constant 1, and some refueling inserters. Trains now also go from requester to depot to provider, stopping in the depot for a short time. Some trains may stop in the depot after leaving the provider too, for example if the provider is really far away. An example depot for up to 100 trains in a grid-friendly format. But wait, there’s more! Waiting space in stations is not unlimited, and if too many trains are requested at once, they might start queuing on tracks that shouldn’t have anything queuing on them. To fix this, we add two decider combinators. Those will check if the requested train amount is greater than a certain constant. If it isn’t, the request goes straight through. If it is, the constant is output instead. Their outputs are summed, simply because the constant and train limit use different signals, and they need to be the same signal. That sum is then given to the station as the train limit. This circuit, just like the first circuit from this article, is customizable. For example, you could have requesters automatically determine and set their own requests, or you could have something completely independent controlling their requests, or you could even change the amount of items loaded into the train. Basically, any constants that the system takes, you can turn into dynamic values, controlled by each other, some independent circuit, or manually even. You could also mess with the train schedules and conditions, for example by making stations kick out trains as soon as their requests are fulfilled, or have a train handle more than one resource. Conclusion The circuits given here are intended both as final usable products, and as foundations for your own circuit projects. I would say they are similar to unpainted figurines: you can still get a lot out of them in the form you got them, but you have limitless possibilities as soon as you break out some creativity and skill. There are intentionally no blueprints in this article, because its goal is not just to give you some neat circuits, but also to get you to understand them better. Good luck wiring! Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started!">
<meta property="og:description" content="On the 37th week during which an issue of Alt-F4 is being released, we present: Issue #37! What a surprise! In it, long-time contributor pocarski is back with yet more very approachable explanations of how you can spice up and optimize your base with but a few combinators! Combinators 2: Augmented Logistics pocarski Several weeks ago, I wrote an article about using combinators to improve specific builds. This time we’ll take a look at ways to apply the circuit network more generally, to make your whole factory more efficient. We will look at the pitfalls of conventional design, we will come up with ways to solve them, and we will implement those solutions using the circuit network. Such improvements can be done to both bots and trains, and the circuitry is so simple it almost doesn’t require decider combinators at all. Let’s dive right in! Bots: Network-to-network interface We’ve all had this issue: you create more bot demand, and suddenly all the bots from the far end of your base decide it’s a good idea to travel thousands of tiles across roboport-less areas. In the best case, this will cause mild frustration at the striking similarity to real-life delivery services, and in the worst case, bots will keep getting destroyed by biters, or turning around part way through to charge at the roboports they just left, leaving you with no throughput whatsoever. This happens when your logistic network has an inward-facing corner, creating a huge logistics-deprived area, which dumb straight-line-pathing bots will immediately start cutting right through. This base’s bots don’t have enough battery charge to cross the concavity, so they keep turning around halfway through. So, to avoid this, a rule was written: “Thou shalt not create concave logistic networks”. Sounds simple, right? Just have your base be a massive rectangle of roboports, and there will simply be no corners to cut. This is a valid solution, but it puts very significant constraints on your expansion, since you’ll be forced to expand the rectangle to cover all of your newly-acquired real estate. This causes situations where your actual base only takes up a tiny fraction of the area covered by your logistic network. Expanding this base’s logistic network to be a rectangle that covers that long stalk on the bottom would mean quite a lot of biter extermination. A much better way to approach this issue is to separate your networks. Essentially, instead of making one huge rectangle, you make a bunch of unconnected smaller ones, which you can then arrange to cover any shape you want. This way, any single network is still convex, meaning bots will never leave the roboport coverage. That’s a good solution, but how does one get items to travel across the gaps between networks? This is where circuits come in. Let’s construct two networks with a one tile gap in between, and call them network A and network B. The items will cross this gap using a stack inserter placed between a requester chest and an active provider chest. For any items we want to move from A to B, we should set the request on A’s requesters to be the amount of items we wish to transfer. We can transfer items from B to A in a similar way. While we can design complex ways to figure out exactly how much of what needs to go where, we’ll stick to a simple solution that works well enough for most purposes: keep both networks at equal amounts of items. To do this, we will determine half of the difference between network contents of each item, and force the network with more of that item to send that many of them to the network with less of that item. Here is a crappy diagram outlining this idea: We connect a roboport in network A to a pair of arithmetic combinators, one multiplying by 1, and the other multiplying by -1. This will give us a positive and a negative value for the items in the network. We do the same for network B. We then connect the negative value of one network to the positive value of the other. This will give us the difference between their contents. We then divide this value by 2 and feed it to the requesters. It’s important that the chests on the side with more items get a positive value, or else the system will do the exact opposite of what we want. It’s also important to round up the value to your robot cargo size, or else they can be flying back and forth forever trying to fix a two item difference by moving four items at a time. Because one inserter going each way is a bit slow, we can add more. If we just blindly add more chests, then the request of each one will be half the difference, meaning the actual request will be several times more than it’s meant to be. We need to divide the incoming difference by the number of chests, and also add the remainder on to one of the chests. Once again, rounding up to robot cargo size is paramount. This rounding does mean that networks are not going to become strictly equal, but it’s a necessary sacrifice. This circuit will now do its best to keep the networks’ contents level, with an error of a couple of items. The bots will do a bit of back and forth, because there is a delay between items being removed from one network and added to the other, which means it overcorrects slightly at first. With more than two networks, not much changes. Because each pair of networks tries to equalize the item counts, all items gradually spread more or less evenly through the whole system. This circuit is infinitely adjustable and customizable. You may add a biasing factor to have the network contents be in a specific ratio, or you may add conditions for when to apply the bias and to what items, and whatever else you can figure out how to do. In my opinion, that is an even more important feature than the simplicity. Trains: Vanilla LTN analogue Moving on from bots to trains then: Trains are very powerful, but trains are also dumb. In a complex system with many stations having the same name, you’re pretty much forced to use circuits because otherwise, trains will keep pathing to the same stations, overcrowding them while starving the rest. The conventional way to control train pathing was to disable stations that don’t need trains, forcing trains to path somewhere else. This is, however, a very crude and inefficient method, with multiple issues: trains repathing inside junctions may cause deadlocks, a single station being enabled triggers an avalanche of trains, and the extra trains from that avalanche create unnecessary traffic. There are also existing circuit systems, such as Haphollas’s Vanilla Train Network, which alleviated some of those problems, but still not all of them. The popular way to avoid all this mess is to use mods. One of the most popular and influential mods for Factorio is LTN, or Logistic Train Network. It essentially implants a logistic bot’s brain into your trains, and gives your stations the functionality of provider and requester chests. You just set what each station wants and the trains will figure the rest out themselves. Needless to say, the mod allows colossal improvements in efficiency. One would expect such a fundamental change to the system to be nearly impossible to recreate with combinators, and they would be correct. It is however extremely easy to create a much simpler, albeit somewhat less efficient, version of LTN using circuits. Today, I introduce the “Train Limit Dispatcher and Requester”, or TLDR. It is a set of very basic circuits that multiple people invented independently, making use of the train limits that were introduced in 1.1 to act as train request flags. The major simplification is that unlike LTN proper, in the TLDR system almost every train or station is dedicated to a single resource. The logic is simple: For every provider station, calculate the number of “train loads” you have in storage, and set that as your train limit. For every requester, do the same with the difference between request and contents. Each train then just goes between provider and requester with “cargo full” and “cargo empty” conditions. In this example, a provider’s stored iron plates are divided by 16000, because that’s how many iron plates can fit in four wagons. TLDR solves all the problems that the classic station-disabling solution has. Trains will never cause deadlocks by repathing inside junctions, since unlike disabling a station, changing its train limit does not force a repath. An excess amount of trains will never be released into a station, since only as many as the train limit allows will be able to leave. No train avalanching means less traffic, higher throughputs, and less trains needed, which also means better game performance. However, nothing is quite as simple as it sounds. For example, if a train unloads at a requester, but no provider is ready, then it just stands there, starving the requester. This means we need a central depot, so trains always have somewhere to go to free up a requester station. The depot can be as bare bones as it gets: just a bunch of stations with train limit at a constant 1, and some refueling inserters. Trains now also go from requester to depot to provider, stopping in the depot for a short time. Some trains may stop in the depot after leaving the provider too, for example if the provider is really far away. An example depot for up to 100 trains in a grid-friendly format. But wait, there’s more! Waiting space in stations is not unlimited, and if too many trains are requested at once, they might start queuing on tracks that shouldn’t have anything queuing on them. To fix this, we add two decider combinators. Those will check if the requested train amount is greater than a certain constant. If it isn’t, the request goes straight through. If it is, the constant is output instead. Their outputs are summed, simply because the constant and train limit use different signals, and they need to be the same signal. That sum is then given to the station as the train limit. This circuit, just like the first circuit from this article, is customizable. For example, you could have requesters automatically determine and set their own requests, or you could have something completely independent controlling their requests, or you could even change the amount of items loaded into the train. Basically, any constants that the system takes, you can turn into dynamic values, controlled by each other, some independent circuit, or manually even. You could also mess with the train schedules and conditions, for example by making stations kick out trains as soon as their requests are fulfilled, or have a train handle more than one resource. Conclusion The circuits given here are intended both as final usable products, and as foundations for your own circuit projects. I would say they are similar to unpainted figurines: you can still get a lot out of them in the form you got them, but you have limitless possibilities as soon as you break out some creativity and skill. There are intentionally no blueprints in this article, because its goal is not just to give you some neat circuits, but also to get you to understand them better. Good luck wiring! Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started!">
<link rel="canonical" href="https://alt-f4.blog/nl/ALTF4-37/">
<meta property="og:url" content="https://alt-f4.blog/ALTF4-37/">
<meta property="og:site_name" content="Alternative Friday Factorio Fan Facts">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-05-28T00:00:00+00:00">
<script type="application/ld+json">
{"datePublished":"2021-05-28T00:00:00+00:00","author":{"@type":"Person","name":"pocarski"},"description":"On the 37th week during which an issue of Alt-F4 is being released, we present: Issue #37! What a surprise! In it, long-time contributor pocarski is back with yet more very approachable explanations of how you can spice up and optimize your base with but a few combinators! Combinators 2: Augmented Logistics pocarski Several weeks ago, I wrote an article about using combinators to improve specific builds. This time we’ll take a look at ways to apply the circuit network more generally, to make your whole factory more efficient. We will look at the pitfalls of conventional design, we will come up with ways to solve them, and we will implement those solutions using the circuit network. Such improvements can be done to both bots and trains, and the circuitry is so simple it almost doesn’t require decider combinators at all. Let’s dive right in! Bots: Network-to-network interface We’ve all had this issue: you create more bot demand, and suddenly all the bots from the far end of your base decide it’s a good idea to travel thousands of tiles across roboport-less areas. In the best case, this will cause mild frustration at the striking similarity to real-life delivery services, and in the worst case, bots will keep getting destroyed by biters, or turning around part way through to charge at the roboports they just left, leaving you with no throughput whatsoever. This happens when your logistic network has an inward-facing corner, creating a huge logistics-deprived area, which dumb straight-line-pathing bots will immediately start cutting right through. This base’s bots don’t have enough battery charge to cross the concavity, so they keep turning around halfway through. So, to avoid this, a rule was written: “Thou shalt not create concave logistic networks”. Sounds simple, right? Just have your base be a massive rectangle of roboports, and there will simply be no corners to cut. This is a valid solution, but it puts very significant constraints on your expansion, since you’ll be forced to expand the rectangle to cover all of your newly-acquired real estate. This causes situations where your actual base only takes up a tiny fraction of the area covered by your logistic network. Expanding this base’s logistic network to be a rectangle that covers that long stalk on the bottom would mean quite a lot of biter extermination. A much better way to approach this issue is to separate your networks. Essentially, instead of making one huge rectangle, you make a bunch of unconnected smaller ones, which you can then arrange to cover any shape you want. This way, any single network is still convex, meaning bots will never leave the roboport coverage. That’s a good solution, but how does one get items to travel across the gaps between networks? This is where circuits come in. Let’s construct two networks with a one tile gap in between, and call them network A and network B. The items will cross this gap using a stack inserter placed between a requester chest and an active provider chest. For any items we want to move from A to B, we should set the request on A’s requesters to be the amount of items we wish to transfer. We can transfer items from B to A in a similar way. While we can design complex ways to figure out exactly how much of what needs to go where, we’ll stick to a simple solution that works well enough for most purposes: keep both networks at equal amounts of items. To do this, we will determine half of the difference between network contents of each item, and force the network with more of that item to send that many of them to the network with less of that item. Here is a crappy diagram outlining this idea: We connect a roboport in network A to a pair of arithmetic combinators, one multiplying by 1, and the other multiplying by -1. This will give us a positive and a negative value for the items in the network. We do the same for network B. We then connect the negative value of one network to the positive value of the other. This will give us the difference between their contents. We then divide this value by 2 and feed it to the requesters. It’s important that the chests on the side with more items get a positive value, or else the system will do the exact opposite of what we want. It’s also important to round up the value to your robot cargo size, or else they can be flying back and forth forever trying to fix a two item difference by moving four items at a time. Because one inserter going each way is a bit slow, we can add more. If we just blindly add more chests, then the request of each one will be half the difference, meaning the actual request will be several times more than it’s meant to be. We need to divide the incoming difference by the number of chests, and also add the remainder on to one of the chests. Once again, rounding up to robot cargo size is paramount. This rounding does mean that networks are not going to become strictly equal, but it’s a necessary sacrifice. This circuit will now do its best to keep the networks’ contents level, with an error of a couple of items. The bots will do a bit of back and forth, because there is a delay between items being removed from one network and added to the other, which means it overcorrects slightly at first. With more than two networks, not much changes. Because each pair of networks tries to equalize the item counts, all items gradually spread more or less evenly through the whole system. This circuit is infinitely adjustable and customizable. You may add a biasing factor to have the network contents be in a specific ratio, or you may add conditions for when to apply the bias and to what items, and whatever else you can figure out how to do. In my opinion, that is an even more important feature than the simplicity. Trains: Vanilla LTN analogue Moving on from bots to trains then: Trains are very powerful, but trains are also dumb. In a complex system with many stations having the same name, you’re pretty much forced to use circuits because otherwise, trains will keep pathing to the same stations, overcrowding them while starving the rest. The conventional way to control train pathing was to disable stations that don’t need trains, forcing trains to path somewhere else. This is, however, a very crude and inefficient method, with multiple issues: trains repathing inside junctions may cause deadlocks, a single station being enabled triggers an avalanche of trains, and the extra trains from that avalanche create unnecessary traffic. There are also existing circuit systems, such as Haphollas’s Vanilla Train Network, which alleviated some of those problems, but still not all of them. The popular way to avoid all this mess is to use mods. One of the most popular and influential mods for Factorio is LTN, or Logistic Train Network. It essentially implants a logistic bot’s brain into your trains, and gives your stations the functionality of provider and requester chests. You just set what each station wants and the trains will figure the rest out themselves. Needless to say, the mod allows colossal improvements in efficiency. One would expect such a fundamental change to the system to be nearly impossible to recreate with combinators, and they would be correct. It is however extremely easy to create a much simpler, albeit somewhat less efficient, version of LTN using circuits. Today, I introduce the “Train Limit Dispatcher and Requester”, or TLDR. It is a set of very basic circuits that multiple people invented independently, making use of the train limits that were introduced in 1.1 to act as train request flags. The major simplification is that unlike LTN proper, in the TLDR system almost every train or station is dedicated to a single resource. The logic is simple: For every provider station, calculate the number of “train loads” you have in storage, and set that as your train limit. For every requester, do the same with the difference between request and contents. Each train then just goes between provider and requester with “cargo full” and “cargo empty” conditions. In this example, a provider’s stored iron plates are divided by 16000, because that’s how many iron plates can fit in four wagons. TLDR solves all the problems that the classic station-disabling solution has. Trains will never cause deadlocks by repathing inside junctions, since unlike disabling a station, changing its train limit does not force a repath. An excess amount of trains will never be released into a station, since only as many as the train limit allows will be able to leave. No train avalanching means less traffic, higher throughputs, and less trains needed, which also means better game performance. However, nothing is quite as simple as it sounds. For example, if a train unloads at a requester, but no provider is ready, then it just stands there, starving the requester. This means we need a central depot, so trains always have somewhere to go to free up a requester station. The depot can be as bare bones as it gets: just a bunch of stations with train limit at a constant 1, and some refueling inserters. Trains now also go from requester to depot to provider, stopping in the depot for a short time. Some trains may stop in the depot after leaving the provider too, for example if the provider is really far away. An example depot for up to 100 trains in a grid-friendly format. But wait, there’s more! Waiting space in stations is not unlimited, and if too many trains are requested at once, they might start queuing on tracks that shouldn’t have anything queuing on them. To fix this, we add two decider combinators. Those will check if the requested train amount is greater than a certain constant. If it isn’t, the request goes straight through. If it is, the constant is output instead. Their outputs are summed, simply because the constant and train limit use different signals, and they need to be the same signal. That sum is then given to the station as the train limit. This circuit, just like the first circuit from this article, is customizable. For example, you could have requesters automatically determine and set their own requests, or you could have something completely independent controlling their requests, or you could even change the amount of items loaded into the train. Basically, any constants that the system takes, you can turn into dynamic values, controlled by each other, some independent circuit, or manually even. You could also mess with the train schedules and conditions, for example by making stations kick out trains as soon as their requests are fulfilled, or have a train handle more than one resource. Conclusion The circuits given here are intended both as final usable products, and as foundations for your own circuit projects. I would say they are similar to unpainted figurines: you can still get a lot out of them in the form you got them, but you have limitless possibilities as soon as you break out some creativity and skill. There are intentionally no blueprints in this article, because its goal is not just to give you some neat circuits, but also to get you to understand them better. Good luck wiring! Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started!","url":"https://alt-f4.blog/ALTF4-37/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://alt-f4.blog/ALTF4-37/"},"headline":"Alt-F4 #37 - Combinator Crash Course Continuation","dateModified":"2021-05-28T00:00:00+00:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
	

	
	  <meta property="og:image" content="https://alt-f4.blog/assets/ALTF4/37/thumbnail.jpg">
	  <meta name="twitter:image" content="https://alt-f4.blog/assets/ALTF4/37/thumbnail.jpg">
	

	<!-- CSS & fonts -->
	<link href="/nl/assets/GLOBAL/css/titillium-web.css" rel="stylesheet">
	<link rel="stylesheet" href="/nl/assets/GLOBAL/css/style.css">
	<link rel="stylesheet" href="/nl/assets/GLOBAL/css/spidertron.css">
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.css" rel="stylesheet" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,400italic%7CSignika:700,300,400,600" rel="stylesheet" type="text/css">

	<link href="/nl/assets/GLOBAL/img/favicon.ico" rel="icon" type="image/x-icon">
	<link href="/nl/assets/GLOBAL/img/favicon.ico" rel="shortcut icon" type="image/x-icon">

	<!-- RSS -->
	<link href="/nl/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed">

	<script src="/assets/GLOBAL/js/spidertron.js"></script>
	<script src="/assets/GLOBAL/js/localization.js"></script>
	<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
</head>


  <body>
    <!-- Navigation Bar -->
    <nav id="top" class="top-bar">
	<div class="top-bar-inner flex flex-space-between">
		<div class="sites links flex">
			<a href="/nl/" class="sites-current">
				<div id="navbar-logo" role="img" aria-label="Alt-F4 Logo"></div>
			</a>
			<a href="https://discord.gg/AsXAwyV" class="">Discord</a>
			<span class="separator">|</span>
			<a href="https://factorio.com/blog" class="">FFF</a>
		</div>
		<div class="sites links flex hide-tag-line">
			<em>Het gemeenschap gedreven vervolg op de geliefde Factorio Friday Facts</em>
		</div>
		<div class="dropdown flex-end">
			<a class="button flex flex-space-between" href="#">
				<i class="fas fa-language"></i>
			</a>
			<div class="submenu">
				
				<a class="button lang-button" href="/../ALTF4-37/" onclick="setLanguage('en')">English</a>
				
				<a class="button lang-button" href="/cs/ALTF4-37/" onclick="setLanguage('cs')">Čeština</a>
				
				<a class="button lang-button" href="/de/ALTF4-37/" onclick="setLanguage('de')">Deutsch</a>
				
				<a class="button lang-button" href="/es/ALTF4-37/" onclick="setLanguage('es')">Español</a>
				
				<a class="button lang-button" href="/fr/ALTF4-37/" onclick="setLanguage('fr')">Français</a>
				
				<a class="button lang-button" href="/it/ALTF4-37/" onclick="setLanguage('it')">Italiano</a>
				
				<a class="button button-green lang-button" href="/nl/ALTF4-37/" onclick="setLanguage('nl')">Nederlands</a>
				
				<a class="button lang-button" href="/pt-br/ALTF4-37/" onclick="setLanguage('pt-br')">Português Brasileiro</a>
				
				<a class="button lang-button" href="/ru/ALTF4-37/" onclick="setLanguage('ru')">Русский</a>
				
				<a class="button lang-button" href="/zh/ALTF4-37/" onclick="setLanguage('zh')">中文</a>
				
			</div>
		</div>
	</div>
</nav>


    <!-- Main content -->
    <div class="container">
      <div class="container-inner">
        <div class="small-center"></div>
        <!-- Posts -->
        <article class="panel blog-post">
	
	<h1 class="page-title-headder">Alt-F4 #37 - Combinator Crash Course Continuation  <author>28-05-2021</author>
</h1>
	
	
	<div class="panel-inset mb0">
		
Geschreven door <em>pocarski</em>,



bewerkt door <em>stringweasel, Nanogamer7, Conor_, Therenas, Firerazer</em>








	</div>
	
	<div class="panel-inset-lighter mt0">
		<div class="post-header">
  <div class="panel">
    <div class="outer">
      <img class="inner" src="/assets/ALTF4/37/thumbnail.jpg" alt="" style="margin: 1px;">
    </div>
  </div>
  <details class="panel toc">
    <summary>
      <h2>Inhoudsopgave</h2>
    </summary>
    <div class="panel-inset mb0">
      <ul>
  <li>
<a href="#combinators-2-augmented-logistics-pocarski">Combinators 2: Augmented Logistics <author>pocarski</author></a>
    <ul>
      <li><a href="#bots-network-to-network-interface">Bots: Network-to-network interface</a></li>
      <li><a href="#trains-vanilla-ltn-analogue">Trains: Vanilla LTN analogue</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
    </ul>
  </li>
  <li><a href="#contributing">Contributing</a></li>
</ul>

    </div>
  </details>
</div>


<div class="center banner">
  <p>Jammer genoeg is dit artikel nog niet vertaald naar het Nederlands, daarom zie je het in het Engels. Als je wilt helpen om dit op te lossen kan je je aansluiten op de Alt-F4 <a href="https://discord.gg/h2uv2fM/">Discord</a> om te beginnen. Bedankt!</p>

</div>



<p>On the 37th week during which an issue of Alt-F4 is being released, we present: Issue #37! What a surprise! In it, long-time contributor <em>pocarski</em> is back with yet more very approachable explanations of how you can spice up and optimize your base with but a few combinators!</p>
      <h2 id="combinators-2-augmented-logistics-pocarski">
        
        
            <a href="#combinators-2-augmented-logistics-pocarski" class="anchor" style="text-decoration: none;">Combinators 2: Augmented Logistics <author>pocarski</author></a>
          
        
      </h2>
    

<p>Several weeks ago, I wrote an <a href="https://alt-f4.blog/nl/ALTF4-31/#combinators-and-why-you-shouldnt-fear-them-pocarski">article</a> about using combinators to improve specific builds. This time we’ll take a look at ways to apply the circuit network more generally, to make your whole factory more efficient. We will look at the pitfalls of conventional design, we will come up with ways to solve them, and we will implement those solutions using the circuit network. Such improvements can be done to both bots and trains, and the circuitry is so simple it almost doesn’t require decider combinators at all. Let’s dive right in!</p>
      <h3 id="bots-network-to-network-interface">
        
        
            <a href="#bots-network-to-network-interface" class="anchor" style="text-decoration: none;">Bots: Network-to-network interface</a>
          
        
      </h3>
    

<p>We’ve all had this issue: you create more bot demand, and suddenly all the bots from the far end of your base decide it’s a good idea to travel thousands of tiles across roboport-less areas. In the best case, this will cause mild frustration at the striking similarity to real-life delivery services, and in the worst case, bots will keep getting destroyed by biters, or turning around part way through to charge at the roboports they just left, leaving you with no throughput whatsoever. This happens when your logistic network has an inward-facing corner, creating a huge logistics-deprived area, which dumb straight-line-pathing bots will immediately start cutting right through.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    <figure>
      <img src="https://media.alt-f4.blog/ALTF4/37/corner-cutting.jpg" alt="A majority of a network’s bots being stuck in battery range limbo" style="max-width: ; max-height: ">
      
      <figcaption>This base’s bots don’t have enough battery charge to cross the concavity, so they keep turning around halfway through.</figcaption>
    </figure>
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>So, to avoid this, a rule was written: <em>“Thou shalt not create concave logistic networks”</em>. Sounds simple, right? Just have your base be a massive rectangle of roboports, and there will simply be no corners to cut. This is a valid solution, but it puts very significant constraints on your expansion, since you’ll be forced to expand the rectangle to cover all of your newly-acquired real estate. This causes situations where your actual base only takes up a tiny fraction of the area covered by your logistic network.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    <figure>
      <img src="https://media.alt-f4.blog/ALTF4/37/big-rectangle.jpg" alt="A base with awkward “stalk” that would inflate the logistic rectangle" style="max-width: ; max-height: ">
      
      <figcaption>Expanding this base’s logistic network to be a rectangle that covers that long stalk on the bottom would mean quite a lot of biter extermination.</figcaption>
    </figure>
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>A much better way to approach this issue is to separate your networks. Essentially, instead of making one huge rectangle, you make a bunch of unconnected smaller ones, which you can then arrange to cover any shape you want. This way, any single network is still convex, meaning bots will never leave the roboport coverage. That’s a good solution, but how does one get items to travel across the gaps between networks? This is where circuits come in.</p>

<p>Let’s construct two networks with a one tile gap in between, and call them <strong>network A</strong> and <strong>network B</strong>. The items will cross this gap using a stack inserter placed between a requester chest and an active provider chest. For any items we want to move from A to B, we should set the request on A’s requesters to be the amount of items we wish to transfer. We can transfer items from B to A in a similar way.</p>

<p>While we can design complex ways to figure out exactly how much of what needs to go where, we’ll stick to a simple solution that works well enough for most purposes: keep both networks at equal amounts of items. To do this, we will determine half of the difference between network contents of each item, and force the network with more of that item to send that many of them to the network with less of that item. Here is a crappy diagram outlining this idea:</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    
      <img src="https://media.alt-f4.blog/ALTF4/37/crummy-diagram.jpg" alt="Diagram of the idea" style="max-width: ; max-height: ">
      
      
    
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>We connect a roboport in network A to a pair of arithmetic combinators, one multiplying by 1, and the other multiplying by -1. This will give us a positive and a negative value for the items in the network. We do the same for network B.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    
      <img src="https://media.alt-f4.blog/ALTF4/37/multipliers.jpg" alt="Negating networks" style="max-width: ; max-height: ">
      
      
    
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>We then connect the negative value of one network to the positive value of the other. This will give us the difference between their contents. We then divide this value by 2 and feed it to the requesters. It’s important that the chests on the side with <em>more</em> items get a <em>positive</em> value, or else the system will do the exact opposite of what we want. It’s also important to round up the value to your robot cargo size, or else they can be flying back and forth forever trying to fix a two item difference by moving four items at a time.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    
      <img src="https://media.alt-f4.blog/ALTF4/37/averagers.jpg" alt="Calculating half of the difference" style="max-width: ; max-height: ">
      
      
    
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Because one inserter going each way is a bit slow, we can add more. If we just blindly add more chests, then the request of <em>each one</em> will be half the difference, meaning the <em>actual</em> request will be several times more than it’s meant to be. We need to divide the incoming difference by the number of chests, and also add the remainder on to one of the chests. Once again, rounding up to robot cargo size is paramount. This rounding does mean that networks are not going to become strictly equal, but it’s a necessary sacrifice.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    
      <img src="https://media.alt-f4.blog/ALTF4/37/many-chests.jpg" alt="Multiple requesters" style="max-width: ; max-height: ">
      
      
    
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>This circuit will now do its best to keep the networks’ contents level, with an error of a couple of items. The bots will do a bit of back and forth, because there is a delay between items being removed from one network and added to the other, which means it overcorrects slightly at first. With more than two networks, not much changes. Because each pair of networks tries to equalize the item counts, all items gradually spread more or less evenly through the whole system.</p>

<p>This circuit is infinitely adjustable and customizable. You may add a biasing factor to have the network contents be in a specific ratio, or you may add conditions for when to apply the bias and to what items, and whatever else you can figure out how to do. In my opinion, that is an even more important feature than the simplicity.</p>
      <h3 id="trains-vanilla-ltn-analogue">
        
        
            <a href="#trains-vanilla-ltn-analogue" class="anchor" style="text-decoration: none;">Trains: Vanilla LTN analogue</a>
          
        
      </h3>
    

<p>Moving on from bots to trains then: Trains are very powerful, but trains are also dumb. In a complex system with many stations having the same name, you’re pretty much forced to use circuits because otherwise, trains will keep pathing to the same stations, overcrowding them while starving the rest. The conventional way to control train pathing was to disable stations that don’t need trains, forcing trains to path somewhere else. This is, however, a very crude and inefficient method, with multiple issues: trains repathing inside junctions may cause deadlocks, a single station being enabled triggers an avalanche of trains, and the extra trains from that avalanche create unnecessary traffic. There are also existing circuit systems, such as <a href="https://www.reddit.com/r/factorio/comments/aa3pz8/vanilla_train_network_by_haphollas/">Haphollas’s Vanilla Train Network</a>, which alleviated some of those problems, but still not all of them.</p>

<p>The popular way to avoid all this mess is to use mods. One of the most popular and influential mods for Factorio is <a href="https://mods.factorio.com/mods/Optera/LogisticTrainNetwork">LTN</a>, or Logistic Train Network. It essentially implants a logistic bot’s brain into your trains, and gives your stations the functionality of provider and requester chests. You just set what each station wants and the trains will figure the rest out themselves. Needless to say, the mod allows colossal improvements in efficiency. One would expect such a fundamental change to the system to be nearly impossible to recreate with combinators, and they would be correct. It is however extremely easy to create a much simpler, albeit somewhat less efficient, version of LTN using circuits.</p>

<p>Today, I introduce the “Train Limit Dispatcher and Requester”, or TLDR. It is a set of very basic circuits that multiple people invented independently, making use of the train limits that were introduced in 1.1 to act as train request flags. The major simplification is that unlike LTN proper, in the TLDR system almost every train or station is dedicated to a single resource. The logic is simple: For every provider station, calculate the number of “train loads” you have in storage, and set that as your train limit. For every requester, do the same with the difference between request and contents. Each train then just goes between provider and requester with “cargo full” and “cargo empty” conditions.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    <figure>
      <img src="https://media.alt-f4.blog/ALTF4/37/provider.jpg" alt="An extremely simple provider station" style="max-width: ; max-height: ">
      
      <figcaption>In this example, a provider’s stored iron plates are divided by 16000, because that’s how many iron plates can fit in four wagons.</figcaption>
    </figure>
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>TLDR solves all the problems that the classic station-disabling solution has. Trains will never cause deadlocks by repathing inside junctions, since unlike disabling a station, changing its train limit does not force a repath. An excess amount of trains will never be released into a station, since only as many as the train limit allows will be able to leave. No train avalanching means less traffic, higher throughputs, and less trains needed, which also means better game performance.</p>

<p>However, nothing is quite as simple as it sounds. For example, if a train unloads at a requester, but no provider is ready, then it just stands there, starving the requester. This means we need a central depot, so trains always have somewhere to go to free up a requester station. The depot can be as bare bones as it gets: just a bunch of stations with train limit at a constant 1, and some refueling inserters. Trains now also go from requester to depot to provider, stopping in the depot for a short time. Some trains may stop in the depot after leaving the provider too, for example if the provider is really far away.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    <figure>
      <img src="https://media.alt-f4.blog/ALTF4/37/depot.jpg" alt="An example depot" style="max-width: ; max-height: ">
      
      <figcaption>An example depot for up to 100 trains in a grid-friendly format.</figcaption>
    </figure>
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>But wait, there’s more! Waiting space in stations is not unlimited, and if too many trains are requested at once, they might start queuing on tracks that shouldn’t have <em>anything</em> queuing on them. To fix this, we add two decider combinators. Those will check if the requested train amount is greater than a certain constant. If it isn’t, the request goes straight through. If it is, the constant is output instead. Their outputs are summed, simply because the constant and train limit use different signals, and they need to be the same signal. That sum is then given to the station as the train limit.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    
      <img src="https://media.alt-f4.blog/ALTF4/37/limiter.jpg" alt="Train limit limiter" style="max-width: ; max-height: ">
      
      
    
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>This circuit, just like the first circuit from this article, is customizable. For example, you could have requesters automatically determine and set their own requests, or you could have something completely independent controlling their requests, or you could even change the amount of items loaded into the train. Basically, any constants that the system takes, you can turn into dynamic values, controlled by each other, some independent circuit, or manually even. You could also mess with the train schedules and conditions, for example by making stations kick out trains as soon as their requests are fulfilled, or have a train handle more than one resource.</p>
      <h3 id="conclusion">
        
        
            <a href="#conclusion" class="anchor" style="text-decoration: none;">Conclusion</a>
          
        
      </h3>
    

<p>The circuits given here are intended both as final usable products, and as foundations for your own circuit projects. I would say they are similar to unpainted figurines: you can still get a lot out of them in the form you got them, but you have limitless possibilities as soon as you break out some creativity and skill. There are intentionally no blueprints in this article, because its goal is not just to give you some neat circuits, but also to get you to understand them better. Good luck wiring!</p>
      <h2 id="contributing">
        
        
            <a href="#contributing" class="anchor" style="text-decoration: none;">Contributing</a>
          
        
      </h2>
    

<p>As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the <a href="https://discord.gg/nxnCFkb">Discord</a> to get started!</p>





<script>
  (() => {
    if (window.innerWidth >= 720) {
      document.getElementsByClassName('toc')[0].setAttribute('open', '')
    }
  })()
</script>

		
<div class="flex flex-column flex-items-center mt8">
  
  <a class="button-green-right m4" style="width: 16em;" href="https://forums.factorio.com/viewtopic.php?f=5&t=98585">
    Bespreek op Factorio Forums
  </a>
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://www.reddit.com/r/factorio/comments/nmxfxn/altf4_37_combinator_crash_course_continuation/">
    Bespreek op Reddit
  </a>
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://discord.gg/ceKebbY">
    Bespreek op Discord
  </a>
  
</div>


	</div>
	<div class="panel-inset mb0 p4 flex">
		<div>
		<!-- Previous Button -->
		
		<a href="/nl/ALTF4-36/" class="button square-sm"><i class="fas fa-angle-double-left"></i></a>
		
		<a class="button square-sm" href="/nl/">
			<i class="fas fa-home"></i>
		</a>

		<!-- Next Button -->
		
		<a class="button square-sm  disabled">
			<i class="fas fa-angle-double-right"></i>
		</a>
		
		</div>
	</div>
</article>

      </div>
    </div>


    <!-- Footer -->
    <footer class="footer">
  <div class="footer-inner panel">

    <div class="footer-links panel-inset slots p1 mt0 mb0">
      <a href="/nl/about" class="slot" title="About">
        <div class="slot-button">
          <i class="fas fa-info"></i>
        </div>
      </a>
      <a href="https://github.com/AlternativeFFFF/Alt-F4" class="slot" title="Github">
        <div class="slot-button">
          <i class="fab fa-github"></i>
        </div>
      </a>
      <a href="https://discord.gg/ceKebbY" class="slot" title="Discord">
        <div class="slot-button">
          <i class="fab fa-discord"></i>
        </div>
      </a>
      <a href="/nl/atom.xml" type="application/atom+xml" rel="alternate" class="slot" title="ATOM Feed">
        <div class="slot-button">
          <i class="fas fa-rss"></i>
        </div>
      </a>
      <a href="https://www.freelists.org/list/alt-f4" class="slot" title="Email Newsletter">
        <div class="slot-button">
          <i class="fas fa-envelope"></i>
        </div>
      </a>

      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
    </div>
    <div class="footer-rocket panel-inset m0">
      <div class="spidertron-center">
        <div id="spidertron" class="spidertron-home" data-spidertron-scale="0.6" data-spidertron-speed="400"></div>
      </div>
      <div class="shadow-overlay"></div>
      <div class="shadow-overlay-bottom"></div>
    </div>
    <div class="footer-copyright panel-inset m0">
      Deze website is een fan project en niet direct aangesloten met Wube Software
    </div>
  </div>
</footer>

  </body>

</html>
