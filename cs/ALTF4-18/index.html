<!DOCTYPE html>
<html lang="cs" class="cs">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Alt-F4 #18 - The Road to Clusterio 2.0</title>
	<!-- Meta -->
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">

	<!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="Alt-F4 #18 - The Road to Clusterio 2.0">
<meta name="author" content="Hornwitser, DedlySpyder">
<meta property="og:locale" content="en">
<meta name="description" content="As the year draws to a close, we picked two mod-related topics for this week’s 18th issue of Alt-F4. First, Hornwitser gives us some insight into the long development progress of Clusterio 2.0 and the challenges that it poses. Then, DedlySpyder talks about their process of developing a simple mod and the compatibility challenges they face. The Road to Clusterio 2.0 Hornwitser I want to tell the story of how I ended up spending a year developing Clusterio 2.0, which still has a long way to go before a release. If you haven’t heard of Clusterio before, it’s open source server software written by Danielv123 (with contributions from around 30 others) that enables mods to interact across servers. It is perhaps best known for the Clusterio 60k event in 2018 where teleport chests were used to transfer items between some 46 Factorio servers in order to build a vanilla-like factory that could do 60k science per minute. These teleportation chests work like active provider and requester chests; one removes items from the game and puts them in shared cloud storage and the other takes items requested from that cloud storage and puts them in the game. &lt;/source&gt; Items being transported across servers using clusterio V1 Iron ore being mined on the server on the left, then sent to the server on the right via Clusterio teleportation chests. Clusterio has always been composed of two parts: the gameplay interactions that are implemented in mod code and run inside the game, and the server-side infrastructure which deals with moving data between the various game servers. In the beginning, the server side was coded around handling the teleportation chests, but as development progressed and more and more features were added the idea of what Clusterio is changed from teleporting chests to a modular server-side platform for making such cross-server gameplay elements. In July 2019, The Gridlock Cluster event was held. Instead of teleportation chests for transporting items between servers, there were trains that could teleport from the edge of one server to the edge of another server using teleporting train stops. The code for teleporting the trains was implemented by Godmave as a plugin to Clusterio. &lt;/source&gt; Train teleporting between servers Train teleporting from the edge of one server to the edge of another. Sadly, the code was plagued with issues, which is where I enter the picture. Humble Beginnings I started out hacking on the Clusterio codebase back in July 2019 as part of trying to help the Gridlock team with the many issues they had. Servers were going down left and right, players were having issues, and new bugs and problems seemed to be cropping up by the hour. It was hectic, but there was also quite a lot of fun to be had. The event had sparked my interest in the code behind Clusterio, and after the event I took it upon myself to improve this code for the next event. That turned out to be a far greater project than I could possibly have imagined. I’ve steadily worked on Clusterio 2.0 for around 16 months now and my estimate for when it’s done is still the same “just a couple of months” that I started out with. Despite this, my motivation to keep working on it remains strong, and one of the things I find particularly motivating is putting all this work to the test by organising my own Clusterio event. I have put out a teaser on Reddit for what I have in mind and right now the aim is to run it early next year. Possibly January, though only time will tell when it’s all ready. But back to where it all began for me. I was installing Clusterio on my server, trying to set up my own test cluster in order to work on fixes for the issues encountered in The Gridlock Cluster. One of the first things I noticed was the one thousand packages it pulled in as dependencies, taking up over 300 MB of disk space. For this project to need that many libraries to function seemed preposterous. Node.js was new to me then, and while I’ve learned now that this isn’t actually such an unreasonable number of dependencies for a Node.js application to have, it’s still a lot. It was an indication of the sort of development style that had been used in the project: a top-down approach of adding features in whichever way was the simplest and quickest to implement there and then. This style of development had led to the accumulation of a lot of technical debt, and I mean a lot. Technical debt is a term often thrown around in software development. It’s the idea that choosing shortcuts in development to save time often creates more work down the line when maintaining and extending the code base. In some ways you could say Clusterio was more a collection of hacks piled on top of each other than a well thought out and structured project. One memorable example of this was the inclusion and usage of four different HTTP clients in the same source file. Usually one such client is more than enough for a whole project, but presumably certain things were easier to do with one client compared to others and as time went on, different clients piled up. So, I got to work on improving and cleaning up the Clusterio codebase. One of the first things I did was slimming down those one thousand or so dependencies. It turned out that most of it wasn’t actually needed to run Clusterio. About half were development tools that didn’t need to be installed in a production environment and a quarter were what I would describe as quick solutions: large libraries pulled in to use a single function from it. Many of these libraries were trivial to remove, either by reimplementing the function locally or by using another library that was already a dependency of the project. In the end I managed to remove the need for some 700 packages (244 MB), though it should be noted most of these were dependencies of dependencies. The next issue I tackled was the automated testing. If you’re unfamiliar with automated testing, it is the idea of writing code to verify that the main code works as it should and doesn’t break with future changes. Automated testing is sort of a cornerstone for writing reliable code and while there were extensive tests set up at some point, they didn’t work when I got into the project. It’s another example of technical debt rearing its ugly head. Maintaining the tests, and adding new tests to cover new code, is extra work; skipping that work is a shortcut. After the tests were fixed, my focus turned to cleaning up the code itself. Doing things like fixing broken code, removing unused or obsolete code, and refactoring bad code into slightly less bad code. One of the changes that started to take shape was moving the code for the teleportation chests out of the main codebase and into a separate plugin. Since Clusterio is first and foremost the server software making cross-server mod interactions possible, having these teleportation chests also called Clusterio is confusing when we’re expecting more and more that Clusterio will be used for other things than those chests. So we also decided to rebrand the item-teleportation-through-magical-chests feature as Subspace Storage. While I was at it, I also decided to replace those wonky sky chest and collection net sprites with something more appropriate to subspace storage. New placeholder sprites for the item, fluid, and electricity inputs and outputs in the Subspace Storage mod. They are still more of a placeholder though, since I’m not much of a 3D artist when it comes to texturing and mechanical modelling. I took the time to set up an automated toolchain with Blender to render, crop and output the sprites into the mod. You know how it is with programmers: automate all the things. Save patching As my work continued, the first major improvement I worked on was save patching, but before I talk about it I want to give some context to the problem it’s trying to solve. The game engine permits modifying the behaviour of the game with Lua code through mods and/or scenarios. Mods are loaded when the game starts and updating them requires restarting the game. Scenarios are Lua code packaged with the game saves and changing to a different scenario code requires only loading a different save. When game-changing behaviour is put into scenario code, it’s often called soft-modding as you don’t need to download any mods and restart Factorio in order to join a server using such scenario code. While it’s easy to update a mod and continue an existing save, it’s not as straight forward with scenario code. There’s essentially three ways to update scenario code in a save, which I will list out roughly in the order of difficulty to implement: For scenarios distributed via a mod it’s possible to add a migration script in the mod that updates the scenario when the mod is updated. While this is quite simple to do, it comes with the major drawback of requiring the mod to be installed to run the migration. You can replace the scenario code stored in the save while the game is not running. This is what I call save patching and it’s relatively simple to do as the saves are regular zip files and the Lua code is stored in them as ordinary text files. You could also use the dynamic nature of Lua to load and execute new code while the game and scenario is running. This option is by far the most complicated but comes with the power of being able to apply fixes to the game while a map is running. The drawback is that it’s complicated to implement and get right, increasing the chances that something will go wrong. Additionally, the only way to send data to a running game is via commands, which gets problematic when they are long. For the Gridlock Cluster the third option was done via a scenario called Hotpatch (also known as Server-side Multi-mod Scenario). Conceptually, Hotpatch is a very cool thing; it lets you load in mod-like code while the game is running, and it’ll execute that code in an environment that emulates the Factorio mod environment. But there were major issues with using Hotpatch: it’s poorly documented, making it hard to use correctly; the implementation was incomplete and buggy; and the most troublesome issue was that the updated scenario code was sent as long commands on start up. This meant that if players joined a server while it was starting up and in the process of sending those long commands to update the scenario, things went haywire, which is just one of the many ways the servers at Gridlock failed. While many of the issues with Hotpatch have been fixed, the complexity and difficulties of working with it have taught me a valuable lesson: having advanced capabilities like being able to fix code at runtime, or technical marvels of any kind for that matter, does not always justify the complexity and issues that such advanced systems face. I got to experience this first hand when trying to fix issues that Hotpatch had a part in: everyone in the crew (myself included) struggled to understand the system and how to solve the issues with it. For that reason, I decided to replace the role Hotpatch had in Clusterio with something simpler: save patching. It’s a less capable solution with more limitations on how code is written, but the simplicity in the way it works more than makes up for it. Breaking Everything After I implemented save patching, it became clear that a major overhaul of the code was needed. A particularly painful point about Clusterio has been the complete lack of remote management. If you want to start a Factorio server that is part of the cluster you have to log in to the computer that hosts it and manually start it through whichever process manager you choose to use, the same goes if you want to change any settings for that server. Managing a cluster in this way is painful and that was a lesson learned the hard way in the Clusterio 60k event. For Gridlock, the Pterodactyl game server management panel was used to manage servers remotely; a good idea that turned out to be the cause of a lot of issues. But that’s a story for another time. Having the ability to remotely manage Factorio servers in Clusterio has been a desired feature for a long time and there have been attempts at implementing it. Those attempts were more of an afterthought though, and due to the way the code was structured (running a single Factorio server per Node.js process) it became very difficult to implement any sensible remote management without doing a major overhaul of the code and breaking everything in the process. So naturally I broke everything and implemented remote management. The way Clusterio 2.0 works is that a slave process is run on each computer you want to host Factorio servers on. These Factorio servers are called instances in Clusterio and the slave process connects to the master server and listens for commands to create and start instances. Multiple instances can run at the same time on a slave, which means you only need to set up one slave for each computer you want to host Factorio servers on, and there’s only one Node.js process to start up on these computers. Another thing that had to change was the way Clusterio communicated between computers. In version 1, this is handled for the most part by the master server hosting an HTTP server and responding to requests on it. This has the problem that the master server can’t send messages to other computers, only respond to requests sent to it from other computers; that’s how HTTP works. To get around this I replaced HTTP with a simple WebSocket based protocol using JSON payloads. WebSocket, unlike HTTP, allows both parties of the connection to send messages to each other at any time. With everything now broken, this sort of became the point where the 2.0 development really began. I used this opportunity to start fresh on a lot of things in the subsequent months. I hope you liked this glimpse into Clusterio 2.0 development. As you might imagine there are many more things about 2.0 that have happened in the past 16 months, certainly enough for more articles on the subject. Please note that 2.0 is not yet ready for production use, though if you’re interested in the development and want to test it out, check out our Discord server and GitHub repository. Moddability: The Birth of a Mod DedlySpyer Something kovarex said in FFF-363 stuck with me: This is an example of a feature, that I just HAD TO DO, because once I realised that the feature could be there, I was almost trying to use it and was annoyed by the fact that it wasn’t there. — kovarex I’ve dipped in and out of playing Factorio for around six years, but since I started modding I’ve always loved tinkering with the game. Sometimes when I play, I end up seeing something new that bothers me just a bit and for which there isn’t a mod to fix it. I’ll get to a point where I just end up modding it myself. Normally, this causes me to discard my current playthrough of Factorio, mostly because, for me, modding scratches the same itch that actually playing the game does. Soon after the 1.0 launch this happened to me again. I picked up the latest version of Krastorio 2, got to the power armor point of the game, and was wondering why I couldn’t rotate equipment. Sure, I could probably shuffle everything around in my armour, but sometimes I just want to hit R and slap something into place with minimal effort. A quick search on the mod portal showed me that there was Rotatable Batteries by GotLag; so it was possible, but it hasn’t been implemented for everything. Making a mod work in every circumstance can be a ton of work sometimes. The safe way to handle every case is to hardcode your changes for every situation. That will definitely work, but requires constant monitoring. Having done something like this in the past, I know that it can get quite unwieldly and hard to read. Plus, if one of those other mods changes something, my implementation either outright breaks or is inconsistent with the “supported” mod. So, I’ve recently become a big fan of trying to make my mods as dynamic as possible to avoid this. It should, in theory, also save tons of time, but this doesn’t always work out. Credit: xkcd #1319 That reality is what I enjoy in Factorio though; the “Oh, but I need to do this thing.” That’s not fun if it’s just adding another mod dependency by adding some string to a list. So, to start a new mod with the aim of being able to rotate any equipment without the need for me to constantly maintain it, I needed to lean on how Factorio loads mods. In other games where you want to add mods, you have some form of a mod-order list. You, the player, or a program created by modders, needs to tell the game in what order the mods are to be loaded, to make sure everything meshes together well enough to not explode. Factorio achieves this ordering via mod dependencies, but it also goes a whole step further. Factorio doesn’t just load all the mods in order once, it loads them in order three times. Three times? Seems excessive, right? Actually, it’s a fantastic idea. The wiki explains this in much more detail, but I’ll quickly explain it here. Each mod, in load order, has a settings stage, then a data stage. The settings stage is pretty self-explanatory, and the data stage is for prototype data, such as items, entities, and recipes. This cycle then repeats two more times. Mods specify what to load at each iteration of the cycle. Modding conventions recommend that prototypes all be added as early in this process as possible. This allows for mods that want to implicitly rely on other mods to do it without needing to know they exist. For example, the base Factorio mod does this for barreling of liquids. This is how the community has the giant overhaul mods that entirely rework all recipes; they just do it in a later data stage to every single recipe in the game. No large lists of mods that need maintenance, no “This mod needs to be loaded last.” This is how I am able to make my mod able to rotate any equipment. I can just move my checks for equipment that needs a rotated version to a later data stage, and it should implicitly cover any equipment in the game. No need for me to name mods X, Y, and Z as dependencies, or for the player to manage anything at their end; it just works. No constant management for name changes, unless there’s a more complex problem that I will enjoy tracking down. With all that in mind, a few days, and a half-finished Krastorio save abandoned, Rotatable Equipment was born. Vanilla equipment and rotated variants. Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started! As next Friday falls on Christmas Day, we decided not to release an issue that week, meaning this is the last issue of Alt-F4 for this year! We’ll be making our glorious return on the first of January with a bit of a special episode looking back at the how the project has developed so far, with perspectives from various team members about the work they’ve been doing. Should be fun.">
<meta property="og:description" content="As the year draws to a close, we picked two mod-related topics for this week’s 18th issue of Alt-F4. First, Hornwitser gives us some insight into the long development progress of Clusterio 2.0 and the challenges that it poses. Then, DedlySpyder talks about their process of developing a simple mod and the compatibility challenges they face. The Road to Clusterio 2.0 Hornwitser I want to tell the story of how I ended up spending a year developing Clusterio 2.0, which still has a long way to go before a release. If you haven’t heard of Clusterio before, it’s open source server software written by Danielv123 (with contributions from around 30 others) that enables mods to interact across servers. It is perhaps best known for the Clusterio 60k event in 2018 where teleport chests were used to transfer items between some 46 Factorio servers in order to build a vanilla-like factory that could do 60k science per minute. These teleportation chests work like active provider and requester chests; one removes items from the game and puts them in shared cloud storage and the other takes items requested from that cloud storage and puts them in the game. &lt;/source&gt; Items being transported across servers using clusterio V1 Iron ore being mined on the server on the left, then sent to the server on the right via Clusterio teleportation chests. Clusterio has always been composed of two parts: the gameplay interactions that are implemented in mod code and run inside the game, and the server-side infrastructure which deals with moving data between the various game servers. In the beginning, the server side was coded around handling the teleportation chests, but as development progressed and more and more features were added the idea of what Clusterio is changed from teleporting chests to a modular server-side platform for making such cross-server gameplay elements. In July 2019, The Gridlock Cluster event was held. Instead of teleportation chests for transporting items between servers, there were trains that could teleport from the edge of one server to the edge of another server using teleporting train stops. The code for teleporting the trains was implemented by Godmave as a plugin to Clusterio. &lt;/source&gt; Train teleporting between servers Train teleporting from the edge of one server to the edge of another. Sadly, the code was plagued with issues, which is where I enter the picture. Humble Beginnings I started out hacking on the Clusterio codebase back in July 2019 as part of trying to help the Gridlock team with the many issues they had. Servers were going down left and right, players were having issues, and new bugs and problems seemed to be cropping up by the hour. It was hectic, but there was also quite a lot of fun to be had. The event had sparked my interest in the code behind Clusterio, and after the event I took it upon myself to improve this code for the next event. That turned out to be a far greater project than I could possibly have imagined. I’ve steadily worked on Clusterio 2.0 for around 16 months now and my estimate for when it’s done is still the same “just a couple of months” that I started out with. Despite this, my motivation to keep working on it remains strong, and one of the things I find particularly motivating is putting all this work to the test by organising my own Clusterio event. I have put out a teaser on Reddit for what I have in mind and right now the aim is to run it early next year. Possibly January, though only time will tell when it’s all ready. But back to where it all began for me. I was installing Clusterio on my server, trying to set up my own test cluster in order to work on fixes for the issues encountered in The Gridlock Cluster. One of the first things I noticed was the one thousand packages it pulled in as dependencies, taking up over 300 MB of disk space. For this project to need that many libraries to function seemed preposterous. Node.js was new to me then, and while I’ve learned now that this isn’t actually such an unreasonable number of dependencies for a Node.js application to have, it’s still a lot. It was an indication of the sort of development style that had been used in the project: a top-down approach of adding features in whichever way was the simplest and quickest to implement there and then. This style of development had led to the accumulation of a lot of technical debt, and I mean a lot. Technical debt is a term often thrown around in software development. It’s the idea that choosing shortcuts in development to save time often creates more work down the line when maintaining and extending the code base. In some ways you could say Clusterio was more a collection of hacks piled on top of each other than a well thought out and structured project. One memorable example of this was the inclusion and usage of four different HTTP clients in the same source file. Usually one such client is more than enough for a whole project, but presumably certain things were easier to do with one client compared to others and as time went on, different clients piled up. So, I got to work on improving and cleaning up the Clusterio codebase. One of the first things I did was slimming down those one thousand or so dependencies. It turned out that most of it wasn’t actually needed to run Clusterio. About half were development tools that didn’t need to be installed in a production environment and a quarter were what I would describe as quick solutions: large libraries pulled in to use a single function from it. Many of these libraries were trivial to remove, either by reimplementing the function locally or by using another library that was already a dependency of the project. In the end I managed to remove the need for some 700 packages (244 MB), though it should be noted most of these were dependencies of dependencies. The next issue I tackled was the automated testing. If you’re unfamiliar with automated testing, it is the idea of writing code to verify that the main code works as it should and doesn’t break with future changes. Automated testing is sort of a cornerstone for writing reliable code and while there were extensive tests set up at some point, they didn’t work when I got into the project. It’s another example of technical debt rearing its ugly head. Maintaining the tests, and adding new tests to cover new code, is extra work; skipping that work is a shortcut. After the tests were fixed, my focus turned to cleaning up the code itself. Doing things like fixing broken code, removing unused or obsolete code, and refactoring bad code into slightly less bad code. One of the changes that started to take shape was moving the code for the teleportation chests out of the main codebase and into a separate plugin. Since Clusterio is first and foremost the server software making cross-server mod interactions possible, having these teleportation chests also called Clusterio is confusing when we’re expecting more and more that Clusterio will be used for other things than those chests. So we also decided to rebrand the item-teleportation-through-magical-chests feature as Subspace Storage. While I was at it, I also decided to replace those wonky sky chest and collection net sprites with something more appropriate to subspace storage. New placeholder sprites for the item, fluid, and electricity inputs and outputs in the Subspace Storage mod. They are still more of a placeholder though, since I’m not much of a 3D artist when it comes to texturing and mechanical modelling. I took the time to set up an automated toolchain with Blender to render, crop and output the sprites into the mod. You know how it is with programmers: automate all the things. Save patching As my work continued, the first major improvement I worked on was save patching, but before I talk about it I want to give some context to the problem it’s trying to solve. The game engine permits modifying the behaviour of the game with Lua code through mods and/or scenarios. Mods are loaded when the game starts and updating them requires restarting the game. Scenarios are Lua code packaged with the game saves and changing to a different scenario code requires only loading a different save. When game-changing behaviour is put into scenario code, it’s often called soft-modding as you don’t need to download any mods and restart Factorio in order to join a server using such scenario code. While it’s easy to update a mod and continue an existing save, it’s not as straight forward with scenario code. There’s essentially three ways to update scenario code in a save, which I will list out roughly in the order of difficulty to implement: For scenarios distributed via a mod it’s possible to add a migration script in the mod that updates the scenario when the mod is updated. While this is quite simple to do, it comes with the major drawback of requiring the mod to be installed to run the migration. You can replace the scenario code stored in the save while the game is not running. This is what I call save patching and it’s relatively simple to do as the saves are regular zip files and the Lua code is stored in them as ordinary text files. You could also use the dynamic nature of Lua to load and execute new code while the game and scenario is running. This option is by far the most complicated but comes with the power of being able to apply fixes to the game while a map is running. The drawback is that it’s complicated to implement and get right, increasing the chances that something will go wrong. Additionally, the only way to send data to a running game is via commands, which gets problematic when they are long. For the Gridlock Cluster the third option was done via a scenario called Hotpatch (also known as Server-side Multi-mod Scenario). Conceptually, Hotpatch is a very cool thing; it lets you load in mod-like code while the game is running, and it’ll execute that code in an environment that emulates the Factorio mod environment. But there were major issues with using Hotpatch: it’s poorly documented, making it hard to use correctly; the implementation was incomplete and buggy; and the most troublesome issue was that the updated scenario code was sent as long commands on start up. This meant that if players joined a server while it was starting up and in the process of sending those long commands to update the scenario, things went haywire, which is just one of the many ways the servers at Gridlock failed. While many of the issues with Hotpatch have been fixed, the complexity and difficulties of working with it have taught me a valuable lesson: having advanced capabilities like being able to fix code at runtime, or technical marvels of any kind for that matter, does not always justify the complexity and issues that such advanced systems face. I got to experience this first hand when trying to fix issues that Hotpatch had a part in: everyone in the crew (myself included) struggled to understand the system and how to solve the issues with it. For that reason, I decided to replace the role Hotpatch had in Clusterio with something simpler: save patching. It’s a less capable solution with more limitations on how code is written, but the simplicity in the way it works more than makes up for it. Breaking Everything After I implemented save patching, it became clear that a major overhaul of the code was needed. A particularly painful point about Clusterio has been the complete lack of remote management. If you want to start a Factorio server that is part of the cluster you have to log in to the computer that hosts it and manually start it through whichever process manager you choose to use, the same goes if you want to change any settings for that server. Managing a cluster in this way is painful and that was a lesson learned the hard way in the Clusterio 60k event. For Gridlock, the Pterodactyl game server management panel was used to manage servers remotely; a good idea that turned out to be the cause of a lot of issues. But that’s a story for another time. Having the ability to remotely manage Factorio servers in Clusterio has been a desired feature for a long time and there have been attempts at implementing it. Those attempts were more of an afterthought though, and due to the way the code was structured (running a single Factorio server per Node.js process) it became very difficult to implement any sensible remote management without doing a major overhaul of the code and breaking everything in the process. So naturally I broke everything and implemented remote management. The way Clusterio 2.0 works is that a slave process is run on each computer you want to host Factorio servers on. These Factorio servers are called instances in Clusterio and the slave process connects to the master server and listens for commands to create and start instances. Multiple instances can run at the same time on a slave, which means you only need to set up one slave for each computer you want to host Factorio servers on, and there’s only one Node.js process to start up on these computers. Another thing that had to change was the way Clusterio communicated between computers. In version 1, this is handled for the most part by the master server hosting an HTTP server and responding to requests on it. This has the problem that the master server can’t send messages to other computers, only respond to requests sent to it from other computers; that’s how HTTP works. To get around this I replaced HTTP with a simple WebSocket based protocol using JSON payloads. WebSocket, unlike HTTP, allows both parties of the connection to send messages to each other at any time. With everything now broken, this sort of became the point where the 2.0 development really began. I used this opportunity to start fresh on a lot of things in the subsequent months. I hope you liked this glimpse into Clusterio 2.0 development. As you might imagine there are many more things about 2.0 that have happened in the past 16 months, certainly enough for more articles on the subject. Please note that 2.0 is not yet ready for production use, though if you’re interested in the development and want to test it out, check out our Discord server and GitHub repository. Moddability: The Birth of a Mod DedlySpyer Something kovarex said in FFF-363 stuck with me: This is an example of a feature, that I just HAD TO DO, because once I realised that the feature could be there, I was almost trying to use it and was annoyed by the fact that it wasn’t there. — kovarex I’ve dipped in and out of playing Factorio for around six years, but since I started modding I’ve always loved tinkering with the game. Sometimes when I play, I end up seeing something new that bothers me just a bit and for which there isn’t a mod to fix it. I’ll get to a point where I just end up modding it myself. Normally, this causes me to discard my current playthrough of Factorio, mostly because, for me, modding scratches the same itch that actually playing the game does. Soon after the 1.0 launch this happened to me again. I picked up the latest version of Krastorio 2, got to the power armor point of the game, and was wondering why I couldn’t rotate equipment. Sure, I could probably shuffle everything around in my armour, but sometimes I just want to hit R and slap something into place with minimal effort. A quick search on the mod portal showed me that there was Rotatable Batteries by GotLag; so it was possible, but it hasn’t been implemented for everything. Making a mod work in every circumstance can be a ton of work sometimes. The safe way to handle every case is to hardcode your changes for every situation. That will definitely work, but requires constant monitoring. Having done something like this in the past, I know that it can get quite unwieldly and hard to read. Plus, if one of those other mods changes something, my implementation either outright breaks or is inconsistent with the “supported” mod. So, I’ve recently become a big fan of trying to make my mods as dynamic as possible to avoid this. It should, in theory, also save tons of time, but this doesn’t always work out. Credit: xkcd #1319 That reality is what I enjoy in Factorio though; the “Oh, but I need to do this thing.” That’s not fun if it’s just adding another mod dependency by adding some string to a list. So, to start a new mod with the aim of being able to rotate any equipment without the need for me to constantly maintain it, I needed to lean on how Factorio loads mods. In other games where you want to add mods, you have some form of a mod-order list. You, the player, or a program created by modders, needs to tell the game in what order the mods are to be loaded, to make sure everything meshes together well enough to not explode. Factorio achieves this ordering via mod dependencies, but it also goes a whole step further. Factorio doesn’t just load all the mods in order once, it loads them in order three times. Three times? Seems excessive, right? Actually, it’s a fantastic idea. The wiki explains this in much more detail, but I’ll quickly explain it here. Each mod, in load order, has a settings stage, then a data stage. The settings stage is pretty self-explanatory, and the data stage is for prototype data, such as items, entities, and recipes. This cycle then repeats two more times. Mods specify what to load at each iteration of the cycle. Modding conventions recommend that prototypes all be added as early in this process as possible. This allows for mods that want to implicitly rely on other mods to do it without needing to know they exist. For example, the base Factorio mod does this for barreling of liquids. This is how the community has the giant overhaul mods that entirely rework all recipes; they just do it in a later data stage to every single recipe in the game. No large lists of mods that need maintenance, no “This mod needs to be loaded last.” This is how I am able to make my mod able to rotate any equipment. I can just move my checks for equipment that needs a rotated version to a later data stage, and it should implicitly cover any equipment in the game. No need for me to name mods X, Y, and Z as dependencies, or for the player to manage anything at their end; it just works. No constant management for name changes, unless there’s a more complex problem that I will enjoy tracking down. With all that in mind, a few days, and a half-finished Krastorio save abandoned, Rotatable Equipment was born. Vanilla equipment and rotated variants. Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started! As next Friday falls on Christmas Day, we decided not to release an issue that week, meaning this is the last issue of Alt-F4 for this year! We’ll be making our glorious return on the first of January with a bit of a special episode looking back at the how the project has developed so far, with perspectives from various team members about the work they’ve been doing. Should be fun.">
<link rel="canonical" href="https://alt-f4.blog/cs/ALTF4-18/">
<meta property="og:url" content="https://alt-f4.blog/ALTF4-18/">
<meta property="og:site_name" content="Alternative Friday Factorio Fan Facts">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-12-18T00:00:00+00:00">
<script type="application/ld+json">
{"headline":"Alt-F4 #18 - The Road to Clusterio 2.0","dateModified":"2020-12-18T00:00:00+00:00","datePublished":"2020-12-18T00:00:00+00:00","description":"As the year draws to a close, we picked two mod-related topics for this week’s 18th issue of Alt-F4. First, Hornwitser gives us some insight into the long development progress of Clusterio 2.0 and the challenges that it poses. Then, DedlySpyder talks about their process of developing a simple mod and the compatibility challenges they face. The Road to Clusterio 2.0 Hornwitser I want to tell the story of how I ended up spending a year developing Clusterio 2.0, which still has a long way to go before a release. If you haven’t heard of Clusterio before, it’s open source server software written by Danielv123 (with contributions from around 30 others) that enables mods to interact across servers. It is perhaps best known for the Clusterio 60k event in 2018 where teleport chests were used to transfer items between some 46 Factorio servers in order to build a vanilla-like factory that could do 60k science per minute. These teleportation chests work like active provider and requester chests; one removes items from the game and puts them in shared cloud storage and the other takes items requested from that cloud storage and puts them in the game. &lt;/source&gt; Items being transported across servers using clusterio V1 Iron ore being mined on the server on the left, then sent to the server on the right via Clusterio teleportation chests. Clusterio has always been composed of two parts: the gameplay interactions that are implemented in mod code and run inside the game, and the server-side infrastructure which deals with moving data between the various game servers. In the beginning, the server side was coded around handling the teleportation chests, but as development progressed and more and more features were added the idea of what Clusterio is changed from teleporting chests to a modular server-side platform for making such cross-server gameplay elements. In July 2019, The Gridlock Cluster event was held. Instead of teleportation chests for transporting items between servers, there were trains that could teleport from the edge of one server to the edge of another server using teleporting train stops. The code for teleporting the trains was implemented by Godmave as a plugin to Clusterio. &lt;/source&gt; Train teleporting between servers Train teleporting from the edge of one server to the edge of another. Sadly, the code was plagued with issues, which is where I enter the picture. Humble Beginnings I started out hacking on the Clusterio codebase back in July 2019 as part of trying to help the Gridlock team with the many issues they had. Servers were going down left and right, players were having issues, and new bugs and problems seemed to be cropping up by the hour. It was hectic, but there was also quite a lot of fun to be had. The event had sparked my interest in the code behind Clusterio, and after the event I took it upon myself to improve this code for the next event. That turned out to be a far greater project than I could possibly have imagined. I’ve steadily worked on Clusterio 2.0 for around 16 months now and my estimate for when it’s done is still the same “just a couple of months” that I started out with. Despite this, my motivation to keep working on it remains strong, and one of the things I find particularly motivating is putting all this work to the test by organising my own Clusterio event. I have put out a teaser on Reddit for what I have in mind and right now the aim is to run it early next year. Possibly January, though only time will tell when it’s all ready. But back to where it all began for me. I was installing Clusterio on my server, trying to set up my own test cluster in order to work on fixes for the issues encountered in The Gridlock Cluster. One of the first things I noticed was the one thousand packages it pulled in as dependencies, taking up over 300 MB of disk space. For this project to need that many libraries to function seemed preposterous. Node.js was new to me then, and while I’ve learned now that this isn’t actually such an unreasonable number of dependencies for a Node.js application to have, it’s still a lot. It was an indication of the sort of development style that had been used in the project: a top-down approach of adding features in whichever way was the simplest and quickest to implement there and then. This style of development had led to the accumulation of a lot of technical debt, and I mean a lot. Technical debt is a term often thrown around in software development. It’s the idea that choosing shortcuts in development to save time often creates more work down the line when maintaining and extending the code base. In some ways you could say Clusterio was more a collection of hacks piled on top of each other than a well thought out and structured project. One memorable example of this was the inclusion and usage of four different HTTP clients in the same source file. Usually one such client is more than enough for a whole project, but presumably certain things were easier to do with one client compared to others and as time went on, different clients piled up. So, I got to work on improving and cleaning up the Clusterio codebase. One of the first things I did was slimming down those one thousand or so dependencies. It turned out that most of it wasn’t actually needed to run Clusterio. About half were development tools that didn’t need to be installed in a production environment and a quarter were what I would describe as quick solutions: large libraries pulled in to use a single function from it. Many of these libraries were trivial to remove, either by reimplementing the function locally or by using another library that was already a dependency of the project. In the end I managed to remove the need for some 700 packages (244 MB), though it should be noted most of these were dependencies of dependencies. The next issue I tackled was the automated testing. If you’re unfamiliar with automated testing, it is the idea of writing code to verify that the main code works as it should and doesn’t break with future changes. Automated testing is sort of a cornerstone for writing reliable code and while there were extensive tests set up at some point, they didn’t work when I got into the project. It’s another example of technical debt rearing its ugly head. Maintaining the tests, and adding new tests to cover new code, is extra work; skipping that work is a shortcut. After the tests were fixed, my focus turned to cleaning up the code itself. Doing things like fixing broken code, removing unused or obsolete code, and refactoring bad code into slightly less bad code. One of the changes that started to take shape was moving the code for the teleportation chests out of the main codebase and into a separate plugin. Since Clusterio is first and foremost the server software making cross-server mod interactions possible, having these teleportation chests also called Clusterio is confusing when we’re expecting more and more that Clusterio will be used for other things than those chests. So we also decided to rebrand the item-teleportation-through-magical-chests feature as Subspace Storage. While I was at it, I also decided to replace those wonky sky chest and collection net sprites with something more appropriate to subspace storage. New placeholder sprites for the item, fluid, and electricity inputs and outputs in the Subspace Storage mod. They are still more of a placeholder though, since I’m not much of a 3D artist when it comes to texturing and mechanical modelling. I took the time to set up an automated toolchain with Blender to render, crop and output the sprites into the mod. You know how it is with programmers: automate all the things. Save patching As my work continued, the first major improvement I worked on was save patching, but before I talk about it I want to give some context to the problem it’s trying to solve. The game engine permits modifying the behaviour of the game with Lua code through mods and/or scenarios. Mods are loaded when the game starts and updating them requires restarting the game. Scenarios are Lua code packaged with the game saves and changing to a different scenario code requires only loading a different save. When game-changing behaviour is put into scenario code, it’s often called soft-modding as you don’t need to download any mods and restart Factorio in order to join a server using such scenario code. While it’s easy to update a mod and continue an existing save, it’s not as straight forward with scenario code. There’s essentially three ways to update scenario code in a save, which I will list out roughly in the order of difficulty to implement: For scenarios distributed via a mod it’s possible to add a migration script in the mod that updates the scenario when the mod is updated. While this is quite simple to do, it comes with the major drawback of requiring the mod to be installed to run the migration. You can replace the scenario code stored in the save while the game is not running. This is what I call save patching and it’s relatively simple to do as the saves are regular zip files and the Lua code is stored in them as ordinary text files. You could also use the dynamic nature of Lua to load and execute new code while the game and scenario is running. This option is by far the most complicated but comes with the power of being able to apply fixes to the game while a map is running. The drawback is that it’s complicated to implement and get right, increasing the chances that something will go wrong. Additionally, the only way to send data to a running game is via commands, which gets problematic when they are long. For the Gridlock Cluster the third option was done via a scenario called Hotpatch (also known as Server-side Multi-mod Scenario). Conceptually, Hotpatch is a very cool thing; it lets you load in mod-like code while the game is running, and it’ll execute that code in an environment that emulates the Factorio mod environment. But there were major issues with using Hotpatch: it’s poorly documented, making it hard to use correctly; the implementation was incomplete and buggy; and the most troublesome issue was that the updated scenario code was sent as long commands on start up. This meant that if players joined a server while it was starting up and in the process of sending those long commands to update the scenario, things went haywire, which is just one of the many ways the servers at Gridlock failed. While many of the issues with Hotpatch have been fixed, the complexity and difficulties of working with it have taught me a valuable lesson: having advanced capabilities like being able to fix code at runtime, or technical marvels of any kind for that matter, does not always justify the complexity and issues that such advanced systems face. I got to experience this first hand when trying to fix issues that Hotpatch had a part in: everyone in the crew (myself included) struggled to understand the system and how to solve the issues with it. For that reason, I decided to replace the role Hotpatch had in Clusterio with something simpler: save patching. It’s a less capable solution with more limitations on how code is written, but the simplicity in the way it works more than makes up for it. Breaking Everything After I implemented save patching, it became clear that a major overhaul of the code was needed. A particularly painful point about Clusterio has been the complete lack of remote management. If you want to start a Factorio server that is part of the cluster you have to log in to the computer that hosts it and manually start it through whichever process manager you choose to use, the same goes if you want to change any settings for that server. Managing a cluster in this way is painful and that was a lesson learned the hard way in the Clusterio 60k event. For Gridlock, the Pterodactyl game server management panel was used to manage servers remotely; a good idea that turned out to be the cause of a lot of issues. But that’s a story for another time. Having the ability to remotely manage Factorio servers in Clusterio has been a desired feature for a long time and there have been attempts at implementing it. Those attempts were more of an afterthought though, and due to the way the code was structured (running a single Factorio server per Node.js process) it became very difficult to implement any sensible remote management without doing a major overhaul of the code and breaking everything in the process. So naturally I broke everything and implemented remote management. The way Clusterio 2.0 works is that a slave process is run on each computer you want to host Factorio servers on. These Factorio servers are called instances in Clusterio and the slave process connects to the master server and listens for commands to create and start instances. Multiple instances can run at the same time on a slave, which means you only need to set up one slave for each computer you want to host Factorio servers on, and there’s only one Node.js process to start up on these computers. Another thing that had to change was the way Clusterio communicated between computers. In version 1, this is handled for the most part by the master server hosting an HTTP server and responding to requests on it. This has the problem that the master server can’t send messages to other computers, only respond to requests sent to it from other computers; that’s how HTTP works. To get around this I replaced HTTP with a simple WebSocket based protocol using JSON payloads. WebSocket, unlike HTTP, allows both parties of the connection to send messages to each other at any time. With everything now broken, this sort of became the point where the 2.0 development really began. I used this opportunity to start fresh on a lot of things in the subsequent months. I hope you liked this glimpse into Clusterio 2.0 development. As you might imagine there are many more things about 2.0 that have happened in the past 16 months, certainly enough for more articles on the subject. Please note that 2.0 is not yet ready for production use, though if you’re interested in the development and want to test it out, check out our Discord server and GitHub repository. Moddability: The Birth of a Mod DedlySpyer Something kovarex said in FFF-363 stuck with me: This is an example of a feature, that I just HAD TO DO, because once I realised that the feature could be there, I was almost trying to use it and was annoyed by the fact that it wasn’t there. — kovarex I’ve dipped in and out of playing Factorio for around six years, but since I started modding I’ve always loved tinkering with the game. Sometimes when I play, I end up seeing something new that bothers me just a bit and for which there isn’t a mod to fix it. I’ll get to a point where I just end up modding it myself. Normally, this causes me to discard my current playthrough of Factorio, mostly because, for me, modding scratches the same itch that actually playing the game does. Soon after the 1.0 launch this happened to me again. I picked up the latest version of Krastorio 2, got to the power armor point of the game, and was wondering why I couldn’t rotate equipment. Sure, I could probably shuffle everything around in my armour, but sometimes I just want to hit R and slap something into place with minimal effort. A quick search on the mod portal showed me that there was Rotatable Batteries by GotLag; so it was possible, but it hasn’t been implemented for everything. Making a mod work in every circumstance can be a ton of work sometimes. The safe way to handle every case is to hardcode your changes for every situation. That will definitely work, but requires constant monitoring. Having done something like this in the past, I know that it can get quite unwieldly and hard to read. Plus, if one of those other mods changes something, my implementation either outright breaks or is inconsistent with the “supported” mod. So, I’ve recently become a big fan of trying to make my mods as dynamic as possible to avoid this. It should, in theory, also save tons of time, but this doesn’t always work out. Credit: xkcd #1319 That reality is what I enjoy in Factorio though; the “Oh, but I need to do this thing.” That’s not fun if it’s just adding another mod dependency by adding some string to a list. So, to start a new mod with the aim of being able to rotate any equipment without the need for me to constantly maintain it, I needed to lean on how Factorio loads mods. In other games where you want to add mods, you have some form of a mod-order list. You, the player, or a program created by modders, needs to tell the game in what order the mods are to be loaded, to make sure everything meshes together well enough to not explode. Factorio achieves this ordering via mod dependencies, but it also goes a whole step further. Factorio doesn’t just load all the mods in order once, it loads them in order three times. Three times? Seems excessive, right? Actually, it’s a fantastic idea. The wiki explains this in much more detail, but I’ll quickly explain it here. Each mod, in load order, has a settings stage, then a data stage. The settings stage is pretty self-explanatory, and the data stage is for prototype data, such as items, entities, and recipes. This cycle then repeats two more times. Mods specify what to load at each iteration of the cycle. Modding conventions recommend that prototypes all be added as early in this process as possible. This allows for mods that want to implicitly rely on other mods to do it without needing to know they exist. For example, the base Factorio mod does this for barreling of liquids. This is how the community has the giant overhaul mods that entirely rework all recipes; they just do it in a later data stage to every single recipe in the game. No large lists of mods that need maintenance, no “This mod needs to be loaded last.” This is how I am able to make my mod able to rotate any equipment. I can just move my checks for equipment that needs a rotated version to a later data stage, and it should implicitly cover any equipment in the game. No need for me to name mods X, Y, and Z as dependencies, or for the player to manage anything at their end; it just works. No constant management for name changes, unless there’s a more complex problem that I will enjoy tracking down. With all that in mind, a few days, and a half-finished Krastorio save abandoned, Rotatable Equipment was born. Vanilla equipment and rotated variants. Contributing As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the Discord to get started! As next Friday falls on Christmas Day, we decided not to release an issue that week, meaning this is the last issue of Alt-F4 for this year! We’ll be making our glorious return on the first of January with a bit of a special episode looking back at the how the project has developed so far, with perspectives from various team members about the work they’ve been doing. Should be fun.","url":"https://alt-f4.blog/ALTF4-18/","@type":"BlogPosting","author":{"@type":"Person","name":"Hornwitser, DedlySpyder"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://alt-f4.blog/ALTF4-18/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
	

	
	  <meta property="og:image" content="https://alt-f4.blog/assets/ALTF4/18/thumbnail.jpg">
	  <meta name="twitter:image" content="https://alt-f4.blog/assets/ALTF4/18/thumbnail.jpg">
	

	<!-- CSS & fonts -->
	<link href="/cs/assets/GLOBAL/css/titillium-web.css" rel="stylesheet">
	<link rel="stylesheet" href="/cs/assets/GLOBAL/css/style.css">
	<link rel="stylesheet" href="/cs/assets/GLOBAL/css/spidertron.css">
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.css" rel="stylesheet" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,400italic%7CSignika:700,300,400,600" rel="stylesheet" type="text/css">

	<link href="/cs/assets/GLOBAL/img/favicon.ico" rel="icon" type="image/x-icon">
	<link href="/cs/assets/GLOBAL/img/favicon.ico" rel="shortcut icon" type="image/x-icon">

	<!-- RSS -->
	<link href="/cs/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed">

	<script src="/assets/GLOBAL/js/spidertron.js"></script>
	<script src="/assets/GLOBAL/js/localization.js"></script>
	<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
</head>


  <body>
    <!-- Navigation Bar -->
    <nav id="top" class="top-bar">
	<div class="top-bar-inner flex flex-space-between">
		<div class="sites links flex">
			<a href="/cs/" class="sites-current">
				<div id="navbar-logo" role="img" aria-label="Alt-F4 Logo"></div>
			</a>
			<a href="https://alt-f4.blog/cs/discord" class="">Discord</a>
			<span class="separator">|</span>
			<a href="https://factorio.com/blog" class="">FFF</a>
		</div>
		<div class="sites links flex hide-tag-line">
			<em>Komunitou tvořené pokračování našich milovaných "Factorio Friday Facts"</em>
		</div>
		<div class="dropdown flex-end">
			<a class="button flex flex-space-between" href="#">
				<i class="fas fa-language"></i>
			</a>
			<div class="submenu">
				
				<a class="button lang-button" href="/../ALTF4-18/" onclick="setLanguage('en')">English</a>
				
				<a class="button button-green lang-button" href="/cs/ALTF4-18/" onclick="setLanguage('cs')">Čeština</a>
				
				<a class="button lang-button" href="/de/ALTF4-18/" onclick="setLanguage('de')">Deutsch</a>
				
				<a class="button lang-button" href="/es/ALTF4-18/" onclick="setLanguage('es')">Español</a>
				
				<a class="button lang-button" href="/fr/ALTF4-18/" onclick="setLanguage('fr')">Français</a>
				
				<a class="button lang-button" href="/it/ALTF4-18/" onclick="setLanguage('it')">Italiano</a>
				
				<a class="button lang-button" href="/nl/ALTF4-18/" onclick="setLanguage('nl')">Nederlands</a>
				
				<a class="button lang-button" href="/pt-br/ALTF4-18/" onclick="setLanguage('pt-br')">Português Brasileiro</a>
				
				<a class="button lang-button" href="/ru/ALTF4-18/" onclick="setLanguage('ru')">Русский</a>
				
				<a class="button lang-button" href="/zh/ALTF4-18/" onclick="setLanguage('zh')">中文</a>
				
			</div>
		</div>
	</div>
</nav>


    <!-- Main content -->
    <div class="container">
      <div class="container-inner">
        <div class="small-center"></div>
        <!-- Posts -->
        <article class="panel blog-post">
	
	<h1 class="page-title-headder">Alt-F4 #18 - The Road to Clusterio 2.0  <author>18-12-2020</author>
</h1>
	
	
	<div class="panel-inset mb0">
		
Napsal <em>Hornwitser, DedlySpyder</em>,



upravil <em>stringweasel, Nanogamer7, Conor_, Therenas, nicgarner, Firerazer</em>








	</div>
	
	<div class="panel-inset-lighter mt0">
		<div class="post-header">
  <div class="panel">
    <div class="outer">
      <img class="inner" src="/assets/ALTF4/18/thumbnail.jpg" alt="" style="margin: 1px;">
    </div>
  </div>
  <details class="panel toc">
    <summary>
      <h2>Obsah</h2>
    </summary>
    <div class="panel-inset mb0">
      <ul>
  <li>
<a href="#the-road-to-clusterio-20-hornwitser">The Road to Clusterio 2.0 <author>Hornwitser</author></a>
    <ul>
      <li><a href="#humble-beginnings">Humble Beginnings</a></li>
      <li><a href="#save-patching">Save patching</a></li>
      <li><a href="#breaking-everything">Breaking Everything</a></li>
    </ul>
  </li>
  <li><a href="#moddability-the-birth-of-a-mod-dedlyspyer">Moddability: The Birth of a Mod <author>DedlySpyer</author></a></li>
  <li><a href="#contributing">Contributing</a></li>
</ul>

    </div>
  </details>
</div>


<div class="center banner">
  <p>Tento článek ještě bohužel nebyl přeložen do češtiny, takže je vám zatím zobrazena anglická verze. Pokud byste měli chuť s překladem pomoci, zastavte se na Alt-F4 <a href="https://alt-f4.blog/cs/discord">Discordu</a>. Děkujeme!</p>

</div>



<p>As the year draws to a close, we picked two mod-related topics for this week’s 18th issue of Alt-F4. First, <em>Hornwitser</em> gives us some insight into the long development progress of Clusterio 2.0 and the challenges that it poses. Then, <em>DedlySpyder</em> talks about their process of developing a simple mod and the compatibility challenges they face.</p>
      <h2 id="the-road-to-clusterio-20-hornwitser">
        
        
            <a href="#the-road-to-clusterio-20-hornwitser" class="anchor" style="text-decoration: none;">The Road to Clusterio 2.0 <author>Hornwitser</author></a>
          
        
      </h2>
    

<p>I want to tell the story of how I ended up spending a year developing Clusterio 2.0, which still has a long way to go before a release. If you haven’t heard of Clusterio before, it’s open source server software written by <em>Danielv123</em> (with <a href="https://github.com/clusterio/factorioClusterio/graphs/contributors">contributions from around 30 others</a>) that enables mods to interact across servers. It is perhaps best known for the Clusterio 60k event in 2018 where teleport chests were used to transfer items between some 46 Factorio servers in order to build a vanilla-like factory that could do 60k science per minute. These teleportation chests work like active provider and requester chests; one removes items from the game and puts them in shared cloud storage and the other takes items requested from that cloud storage and puts them in the game.</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: ; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/18/clusterio-v1.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Items being transported across servers using clusterio V1
    </video>
    <figcaption>Iron ore being mined on the server on the left, then sent to the server on the right via Clusterio teleportation chests.</figcaption>
  </figure>
</p>

<p>Clusterio has always been composed of two parts: the gameplay interactions that are implemented in mod code and run inside the game, and the server-side infrastructure which deals with moving data between the various game servers. In the beginning, the server side was coded around handling the teleportation chests, but as development progressed and more and more features were added the idea of what Clusterio <em>is</em> changed from teleporting chests to a modular server-side platform for making such cross-server gameplay elements.</p>

<p>In July 2019, The Gridlock Cluster event was held. Instead of teleportation chests for transporting items between servers, there were trains that could teleport from the edge of one server to the edge of another server using teleporting train stops. The code for teleporting the trains was implemented by <em>Godmave</em> as a plugin to Clusterio.</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: ; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/18/train.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Train teleporting between servers
    </video>
    <figcaption>Train teleporting from the edge of one server to the edge of another.</figcaption>
  </figure>
</p>

<p>Sadly, the code was plagued with issues, which is where I enter the picture.</p>
      <h3 id="humble-beginnings">
        
        
            <a href="#humble-beginnings" class="anchor" style="text-decoration: none;">Humble Beginnings</a>
          
        
      </h3>
    

<p>I started out hacking on the Clusterio codebase back in July 2019 as part of trying to help the Gridlock team with the many issues they had. Servers were going down left and right, players were having issues, and new bugs and problems seemed to be cropping up by the hour. It was hectic, but there was also quite a lot of fun to be had. The event had sparked my interest in the code behind Clusterio, and after the event I took it upon myself to improve this code for the next event. That turned out to be a far greater project than I could possibly have imagined.</p>

<p>I’ve steadily worked on Clusterio 2.0 for around 16 months now and my estimate for when it’s done is still the same “just a couple of months” that I started out with. Despite this, my motivation to keep working on it remains strong, and one of the things I find particularly motivating is putting all this work to the test by organising my own Clusterio event. I have put out <a href="https://www.reddit.com/r/factorio/comments/jsf21n/the_next_clusterio_event_is_brewing/">a teaser on Reddit</a> for what I have in mind and right now the aim is to run it early next year. Possibly January, though only time will tell when it’s all ready.</p>

<p>But back to where it all began for me. I was installing Clusterio on my server, trying to set up my own test cluster in order to work on fixes for the issues encountered in The Gridlock Cluster. One of the first things I noticed was the one thousand packages it pulled in as dependencies, taking up over 300 MB of disk space. For this project to need that many libraries to function seemed preposterous. Node.js was new to me then, and while I’ve learned now that this isn’t actually such an unreasonable number of dependencies for a Node.js application to have, it’s still a lot. It was an indication of the sort of development style that had been used in the project: a top-down approach of adding features in whichever way was the simplest and quickest to implement there and then.</p>

<p>This style of development had led to the accumulation of a lot of technical debt, and I mean <em>a lot</em>. Technical debt is a term often thrown around in software development. It’s the idea that choosing shortcuts in development to save time often creates more work down the line when maintaining and extending the code base. In some ways you could say Clusterio was more a collection of hacks piled on top of each other than a well thought out and structured project. One memorable example of this was the inclusion and usage of four different HTTP clients in the same source file. Usually one such client is more than enough for a whole project, but presumably certain things were easier to do with one client compared to others and as time went on, different clients piled up.</p>

<p>So, I got to work on improving and cleaning up the Clusterio codebase. One of the first things I did was slimming down those one thousand or so dependencies. It turned out that most of it wasn’t actually needed to run Clusterio. About half were development tools that didn’t need to be installed in a production environment and a quarter were what I would describe as quick solutions: large libraries pulled in to use a single function from it. Many of these libraries were trivial to remove, either by reimplementing the function locally or by using another library that was already a dependency of the project. In the end I managed to remove the need for some 700 packages (244 MB), though it should be noted most of these were dependencies of dependencies.</p>

<p>The next issue I tackled was the automated testing. If you’re unfamiliar with automated testing, it is the idea of writing code to verify that the main code works as it should and doesn’t break with future changes. Automated testing is sort of a cornerstone for writing reliable code and while there were extensive tests set up at some point, they didn’t work when I got into the project. It’s another example of technical debt rearing its ugly head. Maintaining the tests, and adding new tests to cover new code, is extra work; skipping that work is a shortcut.</p>

<p>After the tests were fixed, my focus turned to cleaning up the code itself. Doing things like fixing broken code, removing unused or obsolete code, and refactoring bad code into slightly less bad code. One of the changes that started to take shape was moving the code for the teleportation chests out of the main codebase and into a separate plugin. Since Clusterio is first and foremost the server software making cross-server mod interactions possible, having these teleportation chests also called Clusterio is confusing when we’re expecting more and more that Clusterio will be used for other things than those chests. So we also decided to rebrand the item-teleportation-through-magical-chests feature as Subspace Storage. While I was at it, I also decided to replace those wonky sky chest and collection net sprites with something more appropriate to subspace storage.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/18/subspace-storage-sprites.jpg" alt="Subspace storage placeholder sprites" style="max-width: ; max-height:  ">
        
        <figcaption>New placeholder sprites for the item, fluid, and electricity inputs and outputs in the Subspace Storage mod.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>They are still more of a placeholder though, since I’m not much of a 3D artist when it comes to texturing and mechanical modelling. I took the time to set up an automated toolchain with Blender to render, crop and output the sprites into the mod. You know how it is with programmers: automate all the things.</p>
      <h3 id="save-patching">
        
        
            <a href="#save-patching" class="anchor" style="text-decoration: none;">Save patching</a>
          
        
      </h3>
    

<p>As my work continued, the first major improvement I worked on was save patching, but before I talk about it I want to give some context to the problem it’s trying to solve. The game engine permits modifying the behaviour of the game with Lua code through mods and/or scenarios. Mods are loaded when the game starts and updating them requires restarting the game. Scenarios are Lua code packaged with the game saves and changing to a different scenario code requires only loading a different save.</p>

<p>When game-changing behaviour is put into scenario code, it’s often called soft-modding as you don’t need to download any mods and restart Factorio in order to join a server using such scenario code. While it’s easy to update a mod and continue an existing save, it’s not as straight forward with scenario code. There’s essentially three ways to update scenario code in a save, which I will list out roughly in the order of difficulty to implement:</p>

<ul>
  <li>For scenarios distributed via a mod it’s possible to add a migration script in the mod that updates the scenario when the mod is updated. While this is quite simple to do, it comes with the major drawback of requiring the mod to be installed to run the migration.</li>
  <li>You can replace the scenario code stored in the save while the game is not running. This is what I call save patching and it’s relatively simple to do as the saves are regular zip files and the Lua code is stored in them as ordinary text files.</li>
  <li>You could also use the dynamic nature of Lua to load and execute new code while the game and scenario is running. This option is by far the most complicated but comes with the power of being able to apply fixes to the game while a map is running. The drawback is that it’s complicated to implement and get right, increasing the chances that something will go wrong. Additionally, the only way to send data to a running game is via commands, which gets problematic when they are long.</li>
</ul>

<p>For the Gridlock Cluster the third option was done via a scenario called Hotpatch (also known as Server-side Multi-mod Scenario). Conceptually, Hotpatch is a very cool thing; it lets you load in mod-like code while the game is running, and it’ll execute that code in an environment that emulates the Factorio mod environment. But there were major issues with using Hotpatch: it’s poorly documented, making it hard to use correctly; the implementation was incomplete and buggy; and the most troublesome issue was that the updated scenario code was sent as long commands on start up. This meant that if players joined a server while it was starting up and in the process of sending those long commands to update the scenario, things went haywire, which is just one of the many ways the servers at Gridlock failed.</p>

<p>While many of the issues with Hotpatch have been fixed, the complexity and difficulties of working with it have taught me a valuable lesson: having advanced capabilities like being able to fix code at runtime, or technical marvels of any kind for that matter, does not always justify the complexity and issues that such advanced systems face. I got to experience this first hand when trying to fix issues that Hotpatch had a part in: everyone in the crew (myself included) struggled to understand the system and how to solve the issues with it.</p>

<p>For that reason, I decided to replace the role Hotpatch had in Clusterio with something simpler: save patching. It’s a less capable solution with more limitations on how code is written, but the simplicity in the way it works more than makes up for it.</p>
      <h3 id="breaking-everything">
        
        
            <a href="#breaking-everything" class="anchor" style="text-decoration: none;">Breaking Everything</a>
          
        
      </h3>
    

<p>After I implemented save patching, it became clear that a major overhaul of the code was needed. A particularly painful point about Clusterio has been the complete lack of remote management. If you want to start a Factorio server that is part of the cluster you have to log in to the computer that hosts it and manually start it through whichever process manager you choose to use, the same goes if you want to change any settings for that server. Managing a cluster in this way is painful and that was a lesson learned the hard way in the Clusterio 60k event.</p>

<p>For Gridlock, the Pterodactyl game server management panel was used to manage servers remotely; a good idea that turned out to be the cause of a lot of issues. But that’s a story for another time.</p>

<p>Having the ability to remotely manage Factorio servers in Clusterio has been a desired feature for a long time and there have been attempts at implementing it. Those attempts were more of an afterthought though, and due to the way the code was structured (running a single Factorio server per Node.js process) it became very difficult to implement any sensible remote management without doing a major overhaul of the code and breaking everything in the process.</p>

<p>So naturally I broke everything and implemented remote management.</p>

<p>The way Clusterio 2.0 works is that a slave process is run on each computer you want to host Factorio servers on. These Factorio servers are called instances in Clusterio and the slave process connects to the master server and listens for commands to create and start instances. Multiple instances can run at the same time on a slave, which means you only need to set up one slave for each computer you want to host Factorio servers on, and there’s only one Node.js process to start up on these computers.</p>

<p>Another thing that had to change was the way Clusterio communicated between computers. In version 1, this is handled for the most part by the master server hosting an HTTP server and responding to requests on it. This has the problem that the master server can’t send messages to other computers, only respond to requests sent to it from other computers; that’s how HTTP works. To get around this I replaced HTTP with a simple WebSocket based protocol using JSON payloads. WebSocket, unlike HTTP, allows both parties of the connection to send messages to each other at any time.</p>

<p>With everything now broken, this sort of became the point where the 2.0 development really began. I used this opportunity to start fresh on a lot of things in the subsequent months.</p>

<p>I hope you liked this glimpse into Clusterio 2.0 development. As you might imagine there are many more things about 2.0 that have happened in the past 16 months, certainly enough for more articles on the subject. Please note that 2.0 is not yet ready for production use, though if you’re interested in the development and want to test it out, check out our <a href="https://discord.gg/5XuDkje">Discord server</a> and <a href="https://github.com/clusterio/factorioClusterio">GitHub repository</a>.</p>
      <h2 id="moddability-the-birth-of-a-mod-dedlyspyer">
        
        
            <a href="#moddability-the-birth-of-a-mod-dedlyspyer" class="anchor" style="text-decoration: none;">Moddability: The Birth of a Mod <author>DedlySpyer</author></a>
          
        
      </h2>
    

<p>Something <em>kovarex</em> said in <a href="https://www.factorio.com/blog/post/fff-363">FFF-363</a> stuck with me:</p>

<div class="m0 h100 quote">
  <blockquote cite="">
    <div class="panel-inset-lighter ">
    
      <div class="original">
        <p>This is an example of a feature, that I just HAD TO DO, because once I realised that the feature could be there, I was almost trying to use it and was annoyed by the fact that it wasn’t there.</p>

      </div>
    </div>
    <author>
    — kovarex
    </author>
  </blockquote>
</div>

<p>I’ve dipped in and out of playing Factorio for around six years, but since I started modding I’ve always loved tinkering with the game. Sometimes when I play, I end up seeing something new that bothers me just a bit and for which there isn’t a mod to fix it. I’ll get to a point where I just end up modding it myself. Normally, this causes me to discard my current playthrough of Factorio, mostly because, for me, modding scratches the same itch that actually playing the game does.</p>

<p>Soon after the 1.0 launch this happened to me again. I picked up the latest version of <a href="https://mods.factorio.com/mod/Krastorio2">Krastorio 2</a>, got to the power armor point of the game, and was wondering why I couldn’t rotate equipment. Sure, I could probably shuffle everything around in my armour, but sometimes I just want to hit <code class="language-plaintext highlighter-rouge">R</code> and slap something into place with minimal effort. A quick search on the mod portal showed me that there was <a href="https://mods.factorio.com/mod/RotatableBatteries">Rotatable Batteries</a> by <em>GotLag</em>; so it was possible, but it hasn’t been implemented for everything.</p>

<p>Making a mod work in every circumstance can be a ton of work sometimes. The safe way to handle every case is to hardcode your changes for every situation. That will definitely work, but requires constant monitoring. Having <a href="https://github.com/DedlySpyder/Powered_Entities/blob/0.3.28/mod-compadibility/add-mods.lua">done something like this in the past</a>, I know that it can get quite unwieldly and hard to read. Plus, if one of those other mods changes something, my implementation either outright breaks or is inconsistent with the “supported” mod. So, I’ve recently become a big fan of trying to make my mods as dynamic as possible to avoid this. It should, in theory, also save tons of time, but this doesn’t always work out.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://imgs.xkcd.com/comics/automation.png" alt="xkcd Automation" style="max-width: ; max-height:  ">
        
        <figcaption>Credit: <a href="https://xkcd.com/1319/">xkcd #1319</a></figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>That reality is what I enjoy in Factorio though; the “Oh, but I need to do this thing.” That’s not fun if it’s just adding another mod dependency by adding some string to a list. So, to start a new mod with the aim of being able to rotate <em>any</em> equipment without the need for me to constantly maintain it, I needed to lean on how Factorio loads mods.</p>

<p>In other games where you want to add mods, you have some form of a mod-order list. You, the player, or a program created by modders, needs to tell the game in what order the mods are to be loaded, to make sure everything meshes together well enough to not explode. Factorio achieves this ordering via mod dependencies, but it also goes a whole step further. Factorio doesn’t just load all the mods in order once, it loads them in order <strong>three times</strong>.</p>

<p>Three times? Seems excessive, right? Actually, it’s a fantastic idea. The <a href="https://wiki.factorio.com/Tutorial:Modding_tutorial/Gangsir#How_Factorio_loads_mods">wiki</a> explains this in much more detail, but I’ll quickly explain it here. Each mod, in load order, has a settings stage, then a data stage. The settings stage is pretty self-explanatory, and the data stage is for prototype data, such as items, entities, and recipes. This cycle then repeats two more times. Mods specify what to load at each iteration of the cycle. Modding conventions recommend that prototypes all be added as early in this process as possible. This allows for mods that want to implicitly rely on other mods to do it without needing to know they exist. For example, the base Factorio mod does this for barreling of liquids.</p>

<p>This is how the community has the giant overhaul mods that entirely rework all recipes; they just do it in a later data stage to every single recipe in the game. No large lists of mods that need maintenance, no “This mod <strong>needs</strong> to be loaded last.”</p>

<p>This is how I am able to make my mod able to rotate any equipment. I can just move my checks for equipment that needs a rotated version to a later data stage, and it <em>should</em> implicitly cover any equipment in the game. No need for me to name mods X, Y, and Z as dependencies, or for the player to manage anything at their end; it just works. No constant management for name changes, unless there’s a more complex problem that I will enjoy tracking down.</p>

<p>With all that in mind, a few days, and a half-finished Krastorio save abandoned, <a href="https://mods.factorio.com/mod/Rotatable_Equipment">Rotatable Equipment</a> was born.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/18/moddability-1.jpg" alt="Rotated equipment" style="max-width: ; max-height:  ">
        
        <figcaption>Vanilla equipment and rotated variants.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>
      <h2 id="contributing">
        
        
            <a href="#contributing" class="anchor" style="text-decoration: none;">Contributing</a>
          
        
      </h2>
    

<p>As always, we’re looking for people that want to contribute to Alt-F4, be it by submitting an article or by helping with translation. If you have something interesting in mind that you want to share with the community in a polished way, this is the place to do it. If you’re not too sure about it we’ll gladly help by discussing content ideas and structure questions. If that sounds like something that’s up your alley, join the <a href="https://alt-f4.blog/cs/discord">Discord</a> to get started!</p>

<p>As next Friday falls on Christmas Day, we decided not to release an issue that week, meaning this is the last issue of Alt-F4 for this year! We’ll be making our glorious return on the first of January with a bit of a special episode looking back at the how the project has developed so far, with perspectives from various team members about the work they’ve been doing. Should be fun.</p>





<script>
  (() => {
    if (window.innerWidth >= 720) {
      document.getElementsByClassName('toc')[0].setAttribute('open', '')
    }
  })()

  var slideIndex = 1;
  showSlides(slideIndex);

  function plusSlides(n) {
    showSlides(slideIndex += n);
  }

  function currentSlide(n) {
    showSlides(slideIndex = n);
  }

  function showSlides(n) {
    var i;
    var slides = document.getElementsByClassName("galleryItem");
    var dots = document.getElementsByClassName("galleryPreview");
    var captionText = document.getElementById("caption");
    if (n > slides.length) { slideIndex = 1 }
    if (n < 1) { slideIndex = slides.length }
    for (i = 0; i < slides.length; i++) {
      slides[i].style.display = "none";
    }
    for (i = 0; i < dots.length; i++) {
      dots[i].className = dots[i].className.replace(" active", "");
    }
    slides[slideIndex - 1].style.display = "block";
    dots[slideIndex - 1].className += " active";
    captionText.innerHTML = dots[slideIndex - 1].alt;
  }
</script>

		
<div class="flex flex-column flex-items-center mt8">
  
  <a class="button-green-right m4" style="width: 16em;" href="https://forums.factorio.com/viewtopic.php?f=5&t=93258">
    Diskutujte na Factorio fórech
  </a>
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://www.reddit.com/r/factorio/comments/kfk8v8/altf4_18_the_road_to_clusterio_20/">
    Diskutujte na Redditu
  </a>
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://alt-f4.blog/cs/discord">
    Diskutujte na Discordu
  </a>
  
</div>


	</div>
	<div class="panel-inset mb0 p4 flex">
		<div>
		<!-- Previous Button -->
		
		<a href="/cs/ALTF4-17/" class="button square-sm"><i class="fas fa-angle-double-left"></i></a>
		
		<a class="button square-sm" href="/cs/">
			<i class="fas fa-home"></i>
		</a>

		<!-- Next Button -->
		
		<a href="/cs/ALTF4-19/" class="button square-sm">
			<i class="fas fa-angle-double-right"></i>
		</a>
		
		</div>
	</div>
</article>

      </div>
    </div>


    <!-- Footer -->
    <footer class="footer">
  <div class="footer-inner panel">

    <div class="footer-links panel-inset slots p1 mt0 mb0">
      <a href="/cs/about" class="slot" title="About">
        <div class="slot-button">
          <i class="fas fa-info"></i>
        </div>
      </a>
      <a href="https://github.com/AlternativeFFFF/Alt-F4" class="slot" title="Github">
        <div class="slot-button">
          <i class="fab fa-github"></i>
        </div>
      </a>
      <a href="https://alt-f4.blog/cs/discord" class="slot" title="Discord">
        <div class="slot-button">
          <i class="fab fa-discord"></i>
        </div>
      </a>
      <a href="/cs/atom.xml" type="application/atom+xml" rel="alternate" class="slot" title="ATOM Feed">
        <div class="slot-button">
          <i class="fas fa-rss"></i>
        </div>
      </a>
      <a href="https://www.freelists.org/list/alt-f4" class="slot" title="Email Newsletter">
        <div class="slot-button">
          <i class="fas fa-envelope"></i>
        </div>
      </a>

      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
    </div>
    <div class="footer-rocket panel-inset m0">
      <div class="spidertron-center">
        <div id="spidertron" class="spidertron-home" data-spidertron-scale="0.6" data-spidertron-speed="400"></div>
      </div>
      <div class="shadow-overlay"></div>
      <div class="shadow-overlay-bottom"></div>
    </div>
    <div class="footer-copyright panel-inset m0">
      Tato webová stránka je čistě projektem fanoušků, není nijak přímo spojena s Wube Software
    </div>
  </div>
</footer>

  </body>

</html>
