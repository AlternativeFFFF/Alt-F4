<!DOCTYPE html>
<html lang="de" class="de">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Alt-F4 #61 - Draftsman: Ein Python-Modul um Blaupausen zu erstellen</title>
	<!-- Meta -->
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">

	<!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="Alt-F4 #61 - Draftsman: Ein Python-Modul um Blaupausen zu erstellen">
<meta name="author" content="redruin1">
<meta property="og:locale" content="de">
<meta name="description" content='Für die dieswöchige Ausgabe von ALT-F4 besinnen wir uns auf unsere Wurzeln als FFF-Nachfolger im Geiste zurück und vertiefen uns in ein techisches Nischenthema. redruin1 präsentiert seine neueste Erfindung: Factorio Draftsman. Natürlich gab es bereits andere Projekte, welche versuchten eine Bibliothek für Factorio-Blaupausen-Generation zu bilden, aber Draftsman versucht, der neue Standart zu werden. Motivation, technische Details und einige spaßige Projekte, all das und vieles mehr in dieser Ausgabe von ALT-F4! Draftsman redruin1 Vor einigen Monaten entschied ich mich dazu, mich an einer selbst-expandierenden Fabrik zu versuchen. Ich wurde von einigen beeindruckenden Beispielen inspiriert. Ich hatte bereits einige grundlegenden Ideen für die Logik und wie die Fabrik sich selbst überwachen sollte, und natürlich auch einige große Ideen für Dinge, die die Fabrik selbstständik können würde. Das einzige Problem war, das ich bisher noch nie Kombinatoren verwendet habe und sie eigentlich für die Entscheidungsfindung vorgesah. Das ist aber kein Problem, wir wechseln einfach auf einer Test-Welt in den Editor und probieren einige Sachen aus! 1 / 3 2 / 3 Jeder Versuch die inhaltslosen Notizen zu verstehen endet nur in Enttäuschung und Hass. 3 / 3 ANFÄNGERWERTE ❮ ❯ Ich bin vielleicht etwas vom Fokus abgekommen. Hier ist meine CPU. Sie stellt die siebte Version dar (glaub ich). Sie besitzt ROM, RAM, einen Stack, 256 Register, über 40 Befehle, Breakpoints und Schrittweise Codeexekution, Hardware und Software-Interrupts und ein generisches Schaltkreis-Interface, um mit anderen Maschinen zu kommunizieren. Factorio. Eins der wenigen Spiele, bei dem man schlauer wird, wenn man es nochmal spielt. Ironischerweise soll es aber gar nicht über irgendwas davon gehen. Das ist alles nur Teil der Vorgeschichte. Ich habe die zweite Version des Computers begonnen und wollte kompakteren ROM. Ich kam auf das unten gezeigte Design, welches 4KiB an echten 32-Bit Nummern pro Zeile speichern kann: Alles beginnt irgendwo. Der ROM ist sehr dicht, aber er funktioniert mit einem System, bei dem jeder Wert in zwei 16-Bit Nummern getrennt wird, welche einzeln gespeichert werden und bei der Ausgabe wieder kombiniert werden. ROM’s sind in der Regel sehr aufwändig herzustellen, da jeder Wert in jedem Kombinator von Hand eingestellt werden muss. An diesem Punkt ist mir mein schön Kompaktes System auf die Füße gefallen, da ich jetzt zusätzlich jeden Wert teilen, Bitweise-UND-Verknüpfen und verschieben muss und jeweils zwei Werte an bestimmten Stellen eintragen muss, mit dem korrekten Wert und Signaltyp. So war es schmerzhaft auffällig, das es eine unglaubliche Aufgabe wäre, dutzende, oder sogar hunderte oder tausende Werte einzutragen, um das gesamte System auszunutzen. Die Lösung? Einen Computer diese Arbeit für mich machen lassen. Er kann dies viel schneller und besser als, ohne dabei Flüchtigkeitsfehler zu machen. Factorio’s Blaupausen-Stringimport-Funktion kann jeden korrekt formatierten String verwenden. Meine Aufgabe war es jetzt nur noch, diesen Textstring korrekt mit meinen gewünschten Kombinatoreinstellungen zu erstellen. Dieses Konzept ist prinzipiell nichts neues. Selbst eine einfache Suche aus Interesse bringt bereits mehrere Ergebnisse: factorio-blueprint NPM module von demipixel, justarandomgeek’s Compiler für seinen gigantischen Kombinator-Computer, eine generische Kombinator-Befehlssprache von Jobarion, Bild-zu-Blaupause-Konverter, etc. Die Liste ist lang. Mit all diesen Beispielen hoffte ich, dass ich einige Übereinstimmungen mit einem dieser Systeme finden würde, die ich als Ausgangspunkt für meine Lösung verwenden könnte, ohne die selben Probleme nocheimal zu lösen. Alle diese Lösungen hatten aber eins gemeinsam: Sie hatten alle Probleme! Viele Implementierungen waren sehr spezifisch nur für ihren ursprünglichen Anwendungsfall gemacht; ein Kombinator-Compiler-Script war nicht verwendbar für Anwendungen, welche nicht das Compilieren für einen speziellen Kombinator-Computer waren. Es fehlte eine einheitliche Sprache; viele waren in Lua, einige in Python, eins in JavaScript, eins in C++ geschrieben. Das bedeutet, dass jedes Programm seine eigene Implementierung für gemeinsame Funktionen benötigte, anstatt das einfach einer eine Funktion schreibt und andere sie übernehmen. Viele waren für mittlerweile stark veraltete Factorio-Versionen. Dokumentation für viele dieser Module war rar, was viele Nutzer wie mich davon abhält, sie zu verwenden, da nicht offensichtlich ist, was sie können und was nicht. Ich war mit der Gesamtsituation unzufrieden und musste so in die Fußstapfen derer, die vor mir gekommen sind, folgen und meine eigene Implementierung schreiben. Was ein Spaß! Ich habe innerhalb eines Nachmittags ein Skript geschrieben, welches perfekt funktionierte und genau das tat, was es sollte. Ich habe ein Schablonensystem genutzt und konnte das ganze so innerhalb von einer Woche komplett fertigstellen. Ich übertreibe nicht: Wenn ich ein stärkerer Mensch wäre, hätte ich es so gelassen und etwas anderes mit meinem Leben angefangen. Aber dann habe ich mich gewundert. Es wäre nicht so schwer, ein Modul wie factorio-blueprint für modernes Factorio aufzubereiten, und ich wette, ich kann mir irgendein automatisches System ausdenken, um automatisch Daten aus Factorio auszulesen, so dass ich nicht per Hand Quelldateien in Abhängigkeit von der Version veränderm müsste. Dann dachte ich mir, wo ich doch gerade dabei bin, könnte ich Dokumentation für den komplexen und wenig dokumentierten control_behavior-Schlüssel in Entitäten schreiben, oder eigene Entitätentypen hinzufügen, um Gruppen von Entitäten zu bilden und zu verändern oder sogar Mod-Support hinzuzufügen. Das ist nun drei oder vier Monate her. Nuja, hier ist ein Pythonmodul, was ich geschrieben habe. Ich stelle vor: factorio-draftsman Ich habe dutzende Kombinationen von Titeln ausprobiert, bevor ich mit diesem zufrieden war. Draftsman ist ein Python-Modul, um alle Arten von Factorio-Blaupausenstrings zu erstellen, verändern, modifizieren oder zu ändern. Das Paket erlaubt dir, Blaupausen mit Programmen zu erstellen und zu designen, um dich bei komplexen und sich oft wiederholenden Blaupausen, welche praktisch nicht von Hand erstellt werden können, zu unterstützen. Draftsman versucht alle Schwächen von bisherigen Werkzeugen zu lösen: Draftsman kann es alles. Alle Entitätstypen werden unterstützt, von Teilern bis zu Stapelgreifern. Wenn es im Spiel geht, geht es auch in Draftsman; so das du dich wieder auf dein eigentliches Problem konzentrieren kannst. Draftsman ist sprachübergreifend. Geschrieben in Python macht es sich sehr einfach zum installieren, einfach zu verwenden und gibt dem Benutzer Zugriff auf den gesamten Packaging-Index von Python. Du kannst wahrscheinlich alles in Python mit Draftsman machen, egal was für ein Factorio-Ding du eigentlich tust. Draftsman ist einfach zu verwenden. Da es von Anfang an für ein einfaches und selbst-dokumentierendes Design ausgelegt wurde, erlaubt es dir, Blaupausen und Entitäten mit selbstvervollständigbaren Methoden und Attributen zu manipulieren. Draftsman ist gut dokumentiert. Jede Funktion, Methode, Attribut und Klasse ist dokumentiert und auf seiner readthedocs-Seite verlinkt. Zusätzlich werden Tutorials und zusätzliches Material bereitgestellt, sowie eine große Menge an Beispielprogrammen, um dabei zu helfen, ein Verständnis für die Funktionsweise von Draftsman herzustellen. Draftsman ist stabil. Eine Gruppe rigoroser Tests garantiert, das Draftsman vorhersagbar und korrekt (oder zumindest korrekt genug) funktioniert. Die Tests decken 100% des Codes ab. Draftsman ist auf den aktuellsten Versionen von Python 2 und 3 verifiziert, und belegbar kompatibel mit allen Factorioversionen ab 1.0. Draftsman beschreibt Probleme. Draftsman besitzt “Factorio-safety” als eine zentrale Philosophie, was bedeutet, das jede Änderung an einer Blaupause, welche zu einem Fehler beim Import führen würde, einen Fehler generiert. Draftsman versucht auch “Factorio-Correctness” zu prüfen, was bedeutet, das Werte, die keinen Fehler verursachen würden, aber nicht sinnvoll sind, eine Warnung generieren. Sowohl Fehler als auch Warnungen sind mit ausgiebigen BEschreibungen versehen, so das alle Probleme mit deinem Skript in Sekunden erkannt und verstanden werden können. Draftsman ist nah am Quellmaterial. Draftsman basiert alle seine Daten auf Wube’s factorio-data repository, was bedeutet, das außnahmslos alle Entitäten genau so sind, wie im Spiel zu erwarten. Das macht Draftsman Up-to-date, vereinfacht das updaten auf neue Factorio-Versionen ungemein und eraubt Versionskontrolle zwischen Draftsman und Factorio, falls in Zukunft Fehler auftreten sollten. Draftsman sunterstützt Mods. Draftsman emuliert Factorio’s Data-Lifecycle direkt, was bedeutet, dass der selbe Ladeprozess, wie wenn du das Spiel startest, in einer einzigen Funktion nachgemacht wird. Zusätzlich dazu, das sichergestellt wird, das Draftsman absolut akkurat zu Factorio ist, wird es so auch kompatibel zu Mod-Prototypen, auf die direkt im Skript zugegriffen werden kann, so als währen sie Factorio-eigene Entitäten. Draftsman besitzt besondere Klassen für jede Entität und Prototyp, und alles ist darum designt, möglichst so problemfrei wie möglich mit Blaupausenstrings und anderer Software zusammenzuarbeten. Du kannst einen Blaupausenstring von Factorio importieren und er wird automatisch in einen Draftsman-Blueprint-Objekt umgewandelt, mit alles seinen Funktionen. Dann kannst du deine gewünschten Änderungen vornehmen und dann dieses Blueprint-Objekt zurück in einen importierbaren Blaupausenstring umwandeln. Alternativ kannst du auch einen völlig neuen Blueprint erstellen; Draftsman soll für dich arbeiten, nicht andersherum. Draftsman unterstützt auch eigene "EntityLike"-Objekte, wie beispielsweise Group, welche dir erlauben, eigene Konstruktionen zu erstellen, welche dann zu Blaupausen hinzugefügt werden, um die Lesbarkeit und Modularität zu erhöhen. Du kannst beispielsweise ein Design für einen Schmelzenblock in einer Group erstellen, und diese dann mehrfach in deiner Blaupause verwenden, wenn gewünscht auch gespiegelt oder rotiert. In einem Versuch, diesen Artikel kurz zu halten, werde ich nicht bis in die kleinsten Details hineingehen, und ganz genau erklären, wie jeder Teil des Moduls funktioniert, ich habe stattdessen viel Zeit dafür aufgewendet, Dokumentation zu schreiben. Stattdessen werde ich lieber einige Dinge zeigen, die ich mit Draftsman bisher gemacht habe, sowie einige Dinge, die damit vielleicht in Zukunft angestellt werden könnten und versuche zu zeigen, warum ich dafür so viel Zeit aufgewendet habe. Automatische Item-Stapelgrößen Oft willst du herausfinden, wie viel Lagerplatz du für eine bestimmte Menge an Items benötigst. Allerdings basiert Lagerung in Factorio nicht auf Mengen sondern Stapeln, so dass der benötigte Lagerplatz nicht nur von der gewünschten Menge sondern auch von der Stapelgröße des gewünschten Itemtyp abhängt. Du kannst dafür eine Kombinatorschaltung errichten, um dies herauszufinden, allerdings benötigst du dort eine große Menge an Kombinatoren um die Ergebnisse zu speichern. Diese Schaltung ist langweilig zu errichten und einfach überfordert, wenn ein neues Item hinzukommt oder sich eine Stapelgröße ändert. Für so eine einfache und sich oft wiederholende Aufgabe ist ein Skript ganz klar besser geeignet: # Schaffe ein N x 5 Gitter an verbundenen Kombinatoren für Konstanten, mit jedem Item und der jeweiligen Stapelgröße from draftsman.blueprintable import Blueprint from draftsman.constants import Direction from draftsman.data import items from draftsman.entity import ConstantCombinator COMBINATOR_HEIGHT = 5 def main(): blueprint = Blueprint() signals_added = 0 signal_index = 0 combinators_added = 0 x = 0 y = 0 combinator = ConstantCombinator(direction=Direction.SOUTH) # Iterier über jedes Item in der richtigen Reihenfolge: for item in items.raw: # Irgnoriere verborgene Items/Entitäten if "flags" in items.raw[item]: if "hidden" in items.raw[item]["flags"]: continue # Zähle, wie viele Signale wir bereits verarbeitet haben signals_added += 1 # Schreibe das Stapelgrößensignal stack_size = items.raw[item]["stack_size"] combinator.set_signal(signal_index, item, stack_size) signal_index += 1 # Wenn wir die Anzahl an Signalen überschreiten, die ein einzelner Kombinator verarbeiten kann, wird er platziert und von vorn begonnen if signal_index == combinator.item_slot_count: # Füge den Kombinator der Blaupause hinzu combinator.id = "{}_{}".format(x, y) blueprint.entities.append(combinator) # Setzte den Kombinator zurück combinators_added += 1 y = combinators_added % COMBINATOR_HEIGHT x = int(combinators_added / COMBINATOR_HEIGHT) combinator.set_signals(None) # setzte die Signale zurück combinator.tile_position = (x, y) signal_index = 0 # Füge den letzten Kombinator hinzu, wenn nicht vollständig gefüllt if len(combinator.signals) &gt; 0: combinator.id = "{}_{}".format(x, y) blueprint.entities.append(combinator) # Füge Verbindungen zu den jeweiligen Nachbarn hinzu for cx in range(x): for cy in range(COMBINATOR_HEIGHT): here = "{}_{}".format(cx, cy) right = "{}_{}".format(cx + 1, cy) below = "{}_{}".format(cx, cy + 1) try: blueprint.add_circuit_connection("red", here, right) except KeyError: pass try: blueprint.add_circuit_connection("red", here, below) except KeyError: pass print("Number of items added:", signal_count) print(blueprint.to_string()) if __name__ == "__main__": main() Dieses Skript ist kompakt und einfach zu folgen, aber das wirklich gute an Draftsman ist, das dieses Skript dynamisch ist und anpassbar ist, egal für welche Factorio-Version. Neue Items, fehlende Items, geänderte Stapelgrößen, egal wer diese Änderungen gemacht hat, werden sie mit diesem Skript abgedeckt. Zur Illustration ist oben links der dargestellt, was das Skript in Vanilla erzeugt, oben rechts der Ausgang für eine mittelgroße Mod wie Space Exploration und unten die Ausgabe für ein Bobs + Pyanodon Mega-Modpack: Dies trifft aber nicht nur auf Items zu. Alle Entitäten, Instrumente, Signale, Rezepte, Module und Fliesen werden im Simulierten Spielladeprozess geladen und gespeichert, um dann von Draftsman verarbeitet zu werden. Jedes Skript kann so designt werden, das es in diesen Kategorien komplett flexibel arbeitet; extra Instumente in programmierbaren Lautsprechern, neue Modultypen für nur bestimmte Maschinen, eine komplette virtuelle Signalliste, etc., alles wird von Draftsman korrekt interpretiert. Durch das interne Speichern der Modkonfiguration für später, bedeutet dies, das du die Daten nur einmal neuladen musst, immer nur wenn du die Modkonfiguration änderst. Bild zu Blaupausen-Konverter Das ist etwas, was ich mal aus Spaß gemacht habe. Es verwendet die Pillow-Bibliothek um ein Bild zu laden und in eine Blaupause zu verwandeln, welche dann von der Karte aus sichtbar ist, in unter 150 Zeilen Code: Ein besonderer Mann mit einer komisch großen Flasche. Es könnten dazu noch viele Verbersserungen gemacht werden: Dithering ist nur in 1x1 Tiles implementiert, da ich Probleme hatte, den Algotithmus auf größere Gebiete auszudehnen. Multi-Tile-Entitäten können die Fehlermetrik nicht korrekt verändern; Palettization funktioniert nur schlecht, wenn die Pixel verschiedene Größen haben. Einige Multi-Tile-Entitäten haben verschiedene Rotierungen. Eine bessere Implementierung würde prüfen, welche Orientierung die wenigsten Fehler produziert, anstatt nur die Standart-Orientierung zu platzieren. Die Farben sind hardgecodet, es wäre schön sie dynamisch aus dem Spiel zu laden, besonders bei durch Mods veränderten Kartenfarben… Trotz dieser Probleme sieht das Ergebnis ganz gut aus, wenn man bedenkt, wie schnell es zusammengeschustert wurde. Das zeigt, das Draftsman flexibel genug ist, um komplexen Anforderungen gerecht zu werden. Jay Bauman, berüchtigter Betrüger, Großkrimineller. Bewaffnet und gefährlich. Wiederauferstehung des Factorio-Movie-Players Vor einer Weile, auf der Suche nach Beispielen für diesen Artikel, kam ich auf den Klassiker Factorio Sandstorm. Ein perfektes Projekt für mein Vorhaben; oder hätte es zumindest sein können, wenn ich die Karte im Spiel hätte öffnen können! Die originale Map-Version war mit einem antiken 0.14.20 datiert. Zusätzlich dazu wurden über die lange Zeit viele Veränderungen vorgenommen, die der Funktionalität des Skriptes, welche Bilder in Blaupausen umwandelt, im Wege standen. Auch die Karte selber hatte einige Probleme, so dass es nicht gereicht hätte, einfach eine alte Factorio-Version zu öffnen und das Skript anzuwenden. Beispielsweise nannte das build.lua-Skript, was für das Encoding zuständig ist, automation-science-pack und logistic-science-pack noch science-pack-1 und science-pack-2. Das sollte einen ungefähren Eindruck davon vermitteln können, wie alt diese Karte ist! Es störte mich, so einen ikonischen Teil der Factorio-Geschichte verfallen zu sehen. Ich nahm mir also die Zeit um die Fehler zu beheben und das ganze auf Version 1.1.57 zu bringen: &lt;/source&gt; Video von feel the beat Gezeigt wird ein Teil von Feel the Beat, um die Tradition von Darude-Musikvideos zu erhalten. Das Build-Script zu ändern, war problemlos per Hand möglich, aber das raw-wood-Signal, welches die Maschine intern verwendet hat, gibt es nicht mehr in neueren Factorio-Versionen. Um dies zu beheben, habe ich jedes Vorkommen dieses Signales mit artillery-wagon ersetzt (da ich sicher sein konnte, das es noch nicht verwendet wurde). Das Updaten der Karte erfolgte in einem Draftsman-Skript. Ich habe auch einige andere Skripte hinzugefügt, um die Bilder aus der Quelle zu extrahieren und Bildschirmfotos zu machen, welche dann automatisch zu einem Video zusammengefügt wurden, was in Python relativ einfach war. Ich habe diese Scripts verwendet, um das oben verlinkte Video zu erstellen. Ich habe auch mit der Idee rumgespielt, Draftsman zu verwenden um eine Blaupausenbasierte Version den Bau-Skrips zu erstellen, anstatt der originalen Konsolenversion. Das würde dir ganz klar zeigen, welche SPeicherorte du mit einer drübergelegten Blaupause veränderst und würde es simpel machen, den Speicher zu erweitern (der vorhandene Speicher ist nur groß genug für 4800 Frames). Ich fand es wichtiger, das auf den neuesten Stand zu bringen, was bisher da war, insbesondere wenn ich wusste, das der vorhandene Code funktioniert. Die Informationsdichte eines Blaupausenstrings ist möglicherweise auch geringer als die eines Konsolenbefehls, welche so groß sind, das sie bei der Verwendung in Textdateien gespeichert werden. Herauszufinden, ob eine Blaupause für diesen Anwendungsfall geeignet ist, kann warten, bis ich später mal Zeit dafür finde. Für mehr Informationen darüber, was neu ist, und auch die neue Weltdatei, verweise ich hier auf meine Fork. Was nun? Ich habe bereits einige Dinge mit diesem Modul gemacht, aber mein ursprüngliches Ziel war es ja, das jeder ganz einfach damit etwas machen kann. Einige Ideen, die ich machen wollte, aber bisher noch keine Zeit dazu gefunden habe, habe ich im Folgenden als Anreize/Ideengeber mal zusammengestellt: Viele Kombinator-Computer-Kompiler sind als Skript geschrieben. Vielleicht könnte man ein LLVM-Äquivalent; einen generische Compiler; schaffen, dem man mitteilt, welche Befehle der Computer bearbeiten kann und der daraufhin Code einer etablierten, High-Level-Sprache, beispielsweise C, compiliert. Vielleicht könnte man sogar LLVM selbst nuten? Ausnutzen von Sonderfällen für spezielle Optimierungsprobleme. Wusstest du, das man jedes Item und nicht nur Module als Angefordert in einer Entität einstellen kann? Du kannst nur Items anfordern, wenn sie errichtet wird, was den Nutzen etwas einschränkt, aber Roboter werden den Auftrag erfüllen. So ist es in einigen Fällen möglich, die Produktion in Gang zu setzten. Mit sowas wie der Recursive-Blueprints-Mod kann man, indem man Montagemaschinen mit Item-Anforderungen platziert und wieder abreißt, wenn sie ihre Items hergestellt haben, eine vollautomatische Fabrik nur mit Baurobotern errichten. Vielleicht kann so die Micro Factory weiter verbessert werden? Ein neues Ziel könnte auch sein, die geringste Entitätenzahl ohne Nutzereingabe zu erreichen, um eine Rakete zu starten. Eine vielleicht generellere Anwendung ist diese Blaupause. Ein einzelner GEschützturm, welcher 200 panzerbrechende Munition anfordert, wenn er errichtet wird. Dies ist besonders nützlich in offensiven Aktionen in großen Beißernestern, da du schnell viele Geschütztürme verteilen kannst und sich die Roboter um die Errichtung und Versorgung mit Munition kümmern, damit du dich drauf konzentrieren kannst, dich nicht in der Beißerpampe aufzulösen. &lt;/source&gt; Darstellung der Geschützturmblaupause in Aktion Streckenfindungsprobleme. Übergebe eine Menge an Außenpostenpunkten und verwende einen Algorithmus um sie automatisch auf kürzester Strecke/mit dem wenigssten Kreuzungen/etc. zu verbinden. Vielleicht könnte man dies sogar direkt aus den Speicherständen auslesen? Kombinatorschaltungen sind in der Regel sehr Komlex und für den Leien unintuitiv und schwer zu verstehen, wie ich in meiner, in der Einführung beschriebenen, ausgiebigen Probierereien herausgefunden habe. Das liegt an der Dichte der Schaltungen, den versteckten Operationen der einzelnen Kombinatoren und dem unverständlichen Haufen Kabel, der keinen Platz zum durchlaufen oder für Verständnis lässt. Es wäre schön ein Programm zu haben, dem man einen Blaupausenstring übergibt und dem Nutzer dann Labelmöglichkeiten oder ähnliches gibt, damit er eine einfach zu verstehende Dokumentation für komplexe Schaltungen schaffen kann. Ich fände es klasse, soetwas zu verwenden um vektorbasierte Schaltpläne für meinen Computer zu erstellen. Sollte ich ihn jemals fertigstellen. Verwende Constraint-Satisfaction um Blaupausen zu erstellen. Ich habe damit in der Vergangenheit experimentiert, und es sollte theoretisch möglich sein, vorrausgesetzt man bekommt die Komplexität von O(MFG) herunter. Falls ich nochmal einen Artikel für Alt-F4 schreibe, wird er vielleicht darüber sein. Man kann auch neuronale Netze für dieses Ziel verwenden, es ist schließlich Python!Ich frage mich, ob man damit tatsächlich verwendbare Blaupausen erhalten kann. Vielleicht könnte man es mit den gesamten Daten aus factorio.school trainieren… Hoffentlich hat dies den kreativen unter euch einige Ideen geliefert. Und vielleicht, aber nur vielleicht, kann jemand, der sich mit einem Skript etwas Zeit sparen möchte, etwas Zeit sparen, anstatt drei bis vier Monate darauf zu verwenden, dafür ein Python-Modul zu schreiben. Es hat zumindest etwas Spaß gemacht. Und man hat ein oder zwei Dinge gelernt. &lt;/source&gt; Es funktioniert! Gott sei Dank. Nun, endlich zurück an die Arbeit. Beitragen Wie immer suchen wir nach Leuten, die zu Alt-F4 beitragen wollen, sei es mit einem Artikel oder durch Hilfe bei Übersetzungen. Wenn du etwas Interessantes im Kopf hast, das du mit der Community in einer eleganten Art teilen möchtest, hier kannst du das tun. Falls du dir unsicher bist, beantworten wir gerne Fragen zu Inhalt und Struktur. Falls das nach etwas klingt, woran du interessiert bist, tritt unserem Discord bei, um es nicht zu verpassen!'>
<meta property="og:description" content='Für die dieswöchige Ausgabe von ALT-F4 besinnen wir uns auf unsere Wurzeln als FFF-Nachfolger im Geiste zurück und vertiefen uns in ein techisches Nischenthema. redruin1 präsentiert seine neueste Erfindung: Factorio Draftsman. Natürlich gab es bereits andere Projekte, welche versuchten eine Bibliothek für Factorio-Blaupausen-Generation zu bilden, aber Draftsman versucht, der neue Standart zu werden. Motivation, technische Details und einige spaßige Projekte, all das und vieles mehr in dieser Ausgabe von ALT-F4! Draftsman redruin1 Vor einigen Monaten entschied ich mich dazu, mich an einer selbst-expandierenden Fabrik zu versuchen. Ich wurde von einigen beeindruckenden Beispielen inspiriert. Ich hatte bereits einige grundlegenden Ideen für die Logik und wie die Fabrik sich selbst überwachen sollte, und natürlich auch einige große Ideen für Dinge, die die Fabrik selbstständik können würde. Das einzige Problem war, das ich bisher noch nie Kombinatoren verwendet habe und sie eigentlich für die Entscheidungsfindung vorgesah. Das ist aber kein Problem, wir wechseln einfach auf einer Test-Welt in den Editor und probieren einige Sachen aus! 1 / 3 2 / 3 Jeder Versuch die inhaltslosen Notizen zu verstehen endet nur in Enttäuschung und Hass. 3 / 3 ANFÄNGERWERTE ❮ ❯ Ich bin vielleicht etwas vom Fokus abgekommen. Hier ist meine CPU. Sie stellt die siebte Version dar (glaub ich). Sie besitzt ROM, RAM, einen Stack, 256 Register, über 40 Befehle, Breakpoints und Schrittweise Codeexekution, Hardware und Software-Interrupts und ein generisches Schaltkreis-Interface, um mit anderen Maschinen zu kommunizieren. Factorio. Eins der wenigen Spiele, bei dem man schlauer wird, wenn man es nochmal spielt. Ironischerweise soll es aber gar nicht über irgendwas davon gehen. Das ist alles nur Teil der Vorgeschichte. Ich habe die zweite Version des Computers begonnen und wollte kompakteren ROM. Ich kam auf das unten gezeigte Design, welches 4KiB an echten 32-Bit Nummern pro Zeile speichern kann: Alles beginnt irgendwo. Der ROM ist sehr dicht, aber er funktioniert mit einem System, bei dem jeder Wert in zwei 16-Bit Nummern getrennt wird, welche einzeln gespeichert werden und bei der Ausgabe wieder kombiniert werden. ROM’s sind in der Regel sehr aufwändig herzustellen, da jeder Wert in jedem Kombinator von Hand eingestellt werden muss. An diesem Punkt ist mir mein schön Kompaktes System auf die Füße gefallen, da ich jetzt zusätzlich jeden Wert teilen, Bitweise-UND-Verknüpfen und verschieben muss und jeweils zwei Werte an bestimmten Stellen eintragen muss, mit dem korrekten Wert und Signaltyp. So war es schmerzhaft auffällig, das es eine unglaubliche Aufgabe wäre, dutzende, oder sogar hunderte oder tausende Werte einzutragen, um das gesamte System auszunutzen. Die Lösung? Einen Computer diese Arbeit für mich machen lassen. Er kann dies viel schneller und besser als, ohne dabei Flüchtigkeitsfehler zu machen. Factorio’s Blaupausen-Stringimport-Funktion kann jeden korrekt formatierten String verwenden. Meine Aufgabe war es jetzt nur noch, diesen Textstring korrekt mit meinen gewünschten Kombinatoreinstellungen zu erstellen. Dieses Konzept ist prinzipiell nichts neues. Selbst eine einfache Suche aus Interesse bringt bereits mehrere Ergebnisse: factorio-blueprint NPM module von demipixel, justarandomgeek’s Compiler für seinen gigantischen Kombinator-Computer, eine generische Kombinator-Befehlssprache von Jobarion, Bild-zu-Blaupause-Konverter, etc. Die Liste ist lang. Mit all diesen Beispielen hoffte ich, dass ich einige Übereinstimmungen mit einem dieser Systeme finden würde, die ich als Ausgangspunkt für meine Lösung verwenden könnte, ohne die selben Probleme nocheimal zu lösen. Alle diese Lösungen hatten aber eins gemeinsam: Sie hatten alle Probleme! Viele Implementierungen waren sehr spezifisch nur für ihren ursprünglichen Anwendungsfall gemacht; ein Kombinator-Compiler-Script war nicht verwendbar für Anwendungen, welche nicht das Compilieren für einen speziellen Kombinator-Computer waren. Es fehlte eine einheitliche Sprache; viele waren in Lua, einige in Python, eins in JavaScript, eins in C++ geschrieben. Das bedeutet, dass jedes Programm seine eigene Implementierung für gemeinsame Funktionen benötigte, anstatt das einfach einer eine Funktion schreibt und andere sie übernehmen. Viele waren für mittlerweile stark veraltete Factorio-Versionen. Dokumentation für viele dieser Module war rar, was viele Nutzer wie mich davon abhält, sie zu verwenden, da nicht offensichtlich ist, was sie können und was nicht. Ich war mit der Gesamtsituation unzufrieden und musste so in die Fußstapfen derer, die vor mir gekommen sind, folgen und meine eigene Implementierung schreiben. Was ein Spaß! Ich habe innerhalb eines Nachmittags ein Skript geschrieben, welches perfekt funktionierte und genau das tat, was es sollte. Ich habe ein Schablonensystem genutzt und konnte das ganze so innerhalb von einer Woche komplett fertigstellen. Ich übertreibe nicht: Wenn ich ein stärkerer Mensch wäre, hätte ich es so gelassen und etwas anderes mit meinem Leben angefangen. Aber dann habe ich mich gewundert. Es wäre nicht so schwer, ein Modul wie factorio-blueprint für modernes Factorio aufzubereiten, und ich wette, ich kann mir irgendein automatisches System ausdenken, um automatisch Daten aus Factorio auszulesen, so dass ich nicht per Hand Quelldateien in Abhängigkeit von der Version veränderm müsste. Dann dachte ich mir, wo ich doch gerade dabei bin, könnte ich Dokumentation für den komplexen und wenig dokumentierten control_behavior-Schlüssel in Entitäten schreiben, oder eigene Entitätentypen hinzufügen, um Gruppen von Entitäten zu bilden und zu verändern oder sogar Mod-Support hinzuzufügen. Das ist nun drei oder vier Monate her. Nuja, hier ist ein Pythonmodul, was ich geschrieben habe. Ich stelle vor: factorio-draftsman Ich habe dutzende Kombinationen von Titeln ausprobiert, bevor ich mit diesem zufrieden war. Draftsman ist ein Python-Modul, um alle Arten von Factorio-Blaupausenstrings zu erstellen, verändern, modifizieren oder zu ändern. Das Paket erlaubt dir, Blaupausen mit Programmen zu erstellen und zu designen, um dich bei komplexen und sich oft wiederholenden Blaupausen, welche praktisch nicht von Hand erstellt werden können, zu unterstützen. Draftsman versucht alle Schwächen von bisherigen Werkzeugen zu lösen: Draftsman kann es alles. Alle Entitätstypen werden unterstützt, von Teilern bis zu Stapelgreifern. Wenn es im Spiel geht, geht es auch in Draftsman; so das du dich wieder auf dein eigentliches Problem konzentrieren kannst. Draftsman ist sprachübergreifend. Geschrieben in Python macht es sich sehr einfach zum installieren, einfach zu verwenden und gibt dem Benutzer Zugriff auf den gesamten Packaging-Index von Python. Du kannst wahrscheinlich alles in Python mit Draftsman machen, egal was für ein Factorio-Ding du eigentlich tust. Draftsman ist einfach zu verwenden. Da es von Anfang an für ein einfaches und selbst-dokumentierendes Design ausgelegt wurde, erlaubt es dir, Blaupausen und Entitäten mit selbstvervollständigbaren Methoden und Attributen zu manipulieren. Draftsman ist gut dokumentiert. Jede Funktion, Methode, Attribut und Klasse ist dokumentiert und auf seiner readthedocs-Seite verlinkt. Zusätzlich werden Tutorials und zusätzliches Material bereitgestellt, sowie eine große Menge an Beispielprogrammen, um dabei zu helfen, ein Verständnis für die Funktionsweise von Draftsman herzustellen. Draftsman ist stabil. Eine Gruppe rigoroser Tests garantiert, das Draftsman vorhersagbar und korrekt (oder zumindest korrekt genug) funktioniert. Die Tests decken 100% des Codes ab. Draftsman ist auf den aktuellsten Versionen von Python 2 und 3 verifiziert, und belegbar kompatibel mit allen Factorioversionen ab 1.0. Draftsman beschreibt Probleme. Draftsman besitzt “Factorio-safety” als eine zentrale Philosophie, was bedeutet, das jede Änderung an einer Blaupause, welche zu einem Fehler beim Import führen würde, einen Fehler generiert. Draftsman versucht auch “Factorio-Correctness” zu prüfen, was bedeutet, das Werte, die keinen Fehler verursachen würden, aber nicht sinnvoll sind, eine Warnung generieren. Sowohl Fehler als auch Warnungen sind mit ausgiebigen BEschreibungen versehen, so das alle Probleme mit deinem Skript in Sekunden erkannt und verstanden werden können. Draftsman ist nah am Quellmaterial. Draftsman basiert alle seine Daten auf Wube’s factorio-data repository, was bedeutet, das außnahmslos alle Entitäten genau so sind, wie im Spiel zu erwarten. Das macht Draftsman Up-to-date, vereinfacht das updaten auf neue Factorio-Versionen ungemein und eraubt Versionskontrolle zwischen Draftsman und Factorio, falls in Zukunft Fehler auftreten sollten. Draftsman sunterstützt Mods. Draftsman emuliert Factorio’s Data-Lifecycle direkt, was bedeutet, dass der selbe Ladeprozess, wie wenn du das Spiel startest, in einer einzigen Funktion nachgemacht wird. Zusätzlich dazu, das sichergestellt wird, das Draftsman absolut akkurat zu Factorio ist, wird es so auch kompatibel zu Mod-Prototypen, auf die direkt im Skript zugegriffen werden kann, so als währen sie Factorio-eigene Entitäten. Draftsman besitzt besondere Klassen für jede Entität und Prototyp, und alles ist darum designt, möglichst so problemfrei wie möglich mit Blaupausenstrings und anderer Software zusammenzuarbeten. Du kannst einen Blaupausenstring von Factorio importieren und er wird automatisch in einen Draftsman-Blueprint-Objekt umgewandelt, mit alles seinen Funktionen. Dann kannst du deine gewünschten Änderungen vornehmen und dann dieses Blueprint-Objekt zurück in einen importierbaren Blaupausenstring umwandeln. Alternativ kannst du auch einen völlig neuen Blueprint erstellen; Draftsman soll für dich arbeiten, nicht andersherum. Draftsman unterstützt auch eigene "EntityLike"-Objekte, wie beispielsweise Group, welche dir erlauben, eigene Konstruktionen zu erstellen, welche dann zu Blaupausen hinzugefügt werden, um die Lesbarkeit und Modularität zu erhöhen. Du kannst beispielsweise ein Design für einen Schmelzenblock in einer Group erstellen, und diese dann mehrfach in deiner Blaupause verwenden, wenn gewünscht auch gespiegelt oder rotiert. In einem Versuch, diesen Artikel kurz zu halten, werde ich nicht bis in die kleinsten Details hineingehen, und ganz genau erklären, wie jeder Teil des Moduls funktioniert, ich habe stattdessen viel Zeit dafür aufgewendet, Dokumentation zu schreiben. Stattdessen werde ich lieber einige Dinge zeigen, die ich mit Draftsman bisher gemacht habe, sowie einige Dinge, die damit vielleicht in Zukunft angestellt werden könnten und versuche zu zeigen, warum ich dafür so viel Zeit aufgewendet habe. Automatische Item-Stapelgrößen Oft willst du herausfinden, wie viel Lagerplatz du für eine bestimmte Menge an Items benötigst. Allerdings basiert Lagerung in Factorio nicht auf Mengen sondern Stapeln, so dass der benötigte Lagerplatz nicht nur von der gewünschten Menge sondern auch von der Stapelgröße des gewünschten Itemtyp abhängt. Du kannst dafür eine Kombinatorschaltung errichten, um dies herauszufinden, allerdings benötigst du dort eine große Menge an Kombinatoren um die Ergebnisse zu speichern. Diese Schaltung ist langweilig zu errichten und einfach überfordert, wenn ein neues Item hinzukommt oder sich eine Stapelgröße ändert. Für so eine einfache und sich oft wiederholende Aufgabe ist ein Skript ganz klar besser geeignet: # Schaffe ein N x 5 Gitter an verbundenen Kombinatoren für Konstanten, mit jedem Item und der jeweiligen Stapelgröße from draftsman.blueprintable import Blueprint from draftsman.constants import Direction from draftsman.data import items from draftsman.entity import ConstantCombinator COMBINATOR_HEIGHT = 5 def main(): blueprint = Blueprint() signals_added = 0 signal_index = 0 combinators_added = 0 x = 0 y = 0 combinator = ConstantCombinator(direction=Direction.SOUTH) # Iterier über jedes Item in der richtigen Reihenfolge: for item in items.raw: # Irgnoriere verborgene Items/Entitäten if "flags" in items.raw[item]: if "hidden" in items.raw[item]["flags"]: continue # Zähle, wie viele Signale wir bereits verarbeitet haben signals_added += 1 # Schreibe das Stapelgrößensignal stack_size = items.raw[item]["stack_size"] combinator.set_signal(signal_index, item, stack_size) signal_index += 1 # Wenn wir die Anzahl an Signalen überschreiten, die ein einzelner Kombinator verarbeiten kann, wird er platziert und von vorn begonnen if signal_index == combinator.item_slot_count: # Füge den Kombinator der Blaupause hinzu combinator.id = "{}_{}".format(x, y) blueprint.entities.append(combinator) # Setzte den Kombinator zurück combinators_added += 1 y = combinators_added % COMBINATOR_HEIGHT x = int(combinators_added / COMBINATOR_HEIGHT) combinator.set_signals(None) # setzte die Signale zurück combinator.tile_position = (x, y) signal_index = 0 # Füge den letzten Kombinator hinzu, wenn nicht vollständig gefüllt if len(combinator.signals) &gt; 0: combinator.id = "{}_{}".format(x, y) blueprint.entities.append(combinator) # Füge Verbindungen zu den jeweiligen Nachbarn hinzu for cx in range(x): for cy in range(COMBINATOR_HEIGHT): here = "{}_{}".format(cx, cy) right = "{}_{}".format(cx + 1, cy) below = "{}_{}".format(cx, cy + 1) try: blueprint.add_circuit_connection("red", here, right) except KeyError: pass try: blueprint.add_circuit_connection("red", here, below) except KeyError: pass print("Number of items added:", signal_count) print(blueprint.to_string()) if __name__ == "__main__": main() Dieses Skript ist kompakt und einfach zu folgen, aber das wirklich gute an Draftsman ist, das dieses Skript dynamisch ist und anpassbar ist, egal für welche Factorio-Version. Neue Items, fehlende Items, geänderte Stapelgrößen, egal wer diese Änderungen gemacht hat, werden sie mit diesem Skript abgedeckt. Zur Illustration ist oben links der dargestellt, was das Skript in Vanilla erzeugt, oben rechts der Ausgang für eine mittelgroße Mod wie Space Exploration und unten die Ausgabe für ein Bobs + Pyanodon Mega-Modpack: Dies trifft aber nicht nur auf Items zu. Alle Entitäten, Instrumente, Signale, Rezepte, Module und Fliesen werden im Simulierten Spielladeprozess geladen und gespeichert, um dann von Draftsman verarbeitet zu werden. Jedes Skript kann so designt werden, das es in diesen Kategorien komplett flexibel arbeitet; extra Instumente in programmierbaren Lautsprechern, neue Modultypen für nur bestimmte Maschinen, eine komplette virtuelle Signalliste, etc., alles wird von Draftsman korrekt interpretiert. Durch das interne Speichern der Modkonfiguration für später, bedeutet dies, das du die Daten nur einmal neuladen musst, immer nur wenn du die Modkonfiguration änderst. Bild zu Blaupausen-Konverter Das ist etwas, was ich mal aus Spaß gemacht habe. Es verwendet die Pillow-Bibliothek um ein Bild zu laden und in eine Blaupause zu verwandeln, welche dann von der Karte aus sichtbar ist, in unter 150 Zeilen Code: Ein besonderer Mann mit einer komisch großen Flasche. Es könnten dazu noch viele Verbersserungen gemacht werden: Dithering ist nur in 1x1 Tiles implementiert, da ich Probleme hatte, den Algotithmus auf größere Gebiete auszudehnen. Multi-Tile-Entitäten können die Fehlermetrik nicht korrekt verändern; Palettization funktioniert nur schlecht, wenn die Pixel verschiedene Größen haben. Einige Multi-Tile-Entitäten haben verschiedene Rotierungen. Eine bessere Implementierung würde prüfen, welche Orientierung die wenigsten Fehler produziert, anstatt nur die Standart-Orientierung zu platzieren. Die Farben sind hardgecodet, es wäre schön sie dynamisch aus dem Spiel zu laden, besonders bei durch Mods veränderten Kartenfarben… Trotz dieser Probleme sieht das Ergebnis ganz gut aus, wenn man bedenkt, wie schnell es zusammengeschustert wurde. Das zeigt, das Draftsman flexibel genug ist, um komplexen Anforderungen gerecht zu werden. Jay Bauman, berüchtigter Betrüger, Großkrimineller. Bewaffnet und gefährlich. Wiederauferstehung des Factorio-Movie-Players Vor einer Weile, auf der Suche nach Beispielen für diesen Artikel, kam ich auf den Klassiker Factorio Sandstorm. Ein perfektes Projekt für mein Vorhaben; oder hätte es zumindest sein können, wenn ich die Karte im Spiel hätte öffnen können! Die originale Map-Version war mit einem antiken 0.14.20 datiert. Zusätzlich dazu wurden über die lange Zeit viele Veränderungen vorgenommen, die der Funktionalität des Skriptes, welche Bilder in Blaupausen umwandelt, im Wege standen. Auch die Karte selber hatte einige Probleme, so dass es nicht gereicht hätte, einfach eine alte Factorio-Version zu öffnen und das Skript anzuwenden. Beispielsweise nannte das build.lua-Skript, was für das Encoding zuständig ist, automation-science-pack und logistic-science-pack noch science-pack-1 und science-pack-2. Das sollte einen ungefähren Eindruck davon vermitteln können, wie alt diese Karte ist! Es störte mich, so einen ikonischen Teil der Factorio-Geschichte verfallen zu sehen. Ich nahm mir also die Zeit um die Fehler zu beheben und das ganze auf Version 1.1.57 zu bringen: &lt;/source&gt; Video von feel the beat Gezeigt wird ein Teil von Feel the Beat, um die Tradition von Darude-Musikvideos zu erhalten. Das Build-Script zu ändern, war problemlos per Hand möglich, aber das raw-wood-Signal, welches die Maschine intern verwendet hat, gibt es nicht mehr in neueren Factorio-Versionen. Um dies zu beheben, habe ich jedes Vorkommen dieses Signales mit artillery-wagon ersetzt (da ich sicher sein konnte, das es noch nicht verwendet wurde). Das Updaten der Karte erfolgte in einem Draftsman-Skript. Ich habe auch einige andere Skripte hinzugefügt, um die Bilder aus der Quelle zu extrahieren und Bildschirmfotos zu machen, welche dann automatisch zu einem Video zusammengefügt wurden, was in Python relativ einfach war. Ich habe diese Scripts verwendet, um das oben verlinkte Video zu erstellen. Ich habe auch mit der Idee rumgespielt, Draftsman zu verwenden um eine Blaupausenbasierte Version den Bau-Skrips zu erstellen, anstatt der originalen Konsolenversion. Das würde dir ganz klar zeigen, welche SPeicherorte du mit einer drübergelegten Blaupause veränderst und würde es simpel machen, den Speicher zu erweitern (der vorhandene Speicher ist nur groß genug für 4800 Frames). Ich fand es wichtiger, das auf den neuesten Stand zu bringen, was bisher da war, insbesondere wenn ich wusste, das der vorhandene Code funktioniert. Die Informationsdichte eines Blaupausenstrings ist möglicherweise auch geringer als die eines Konsolenbefehls, welche so groß sind, das sie bei der Verwendung in Textdateien gespeichert werden. Herauszufinden, ob eine Blaupause für diesen Anwendungsfall geeignet ist, kann warten, bis ich später mal Zeit dafür finde. Für mehr Informationen darüber, was neu ist, und auch die neue Weltdatei, verweise ich hier auf meine Fork. Was nun? Ich habe bereits einige Dinge mit diesem Modul gemacht, aber mein ursprüngliches Ziel war es ja, das jeder ganz einfach damit etwas machen kann. Einige Ideen, die ich machen wollte, aber bisher noch keine Zeit dazu gefunden habe, habe ich im Folgenden als Anreize/Ideengeber mal zusammengestellt: Viele Kombinator-Computer-Kompiler sind als Skript geschrieben. Vielleicht könnte man ein LLVM-Äquivalent; einen generische Compiler; schaffen, dem man mitteilt, welche Befehle der Computer bearbeiten kann und der daraufhin Code einer etablierten, High-Level-Sprache, beispielsweise C, compiliert. Vielleicht könnte man sogar LLVM selbst nuten? Ausnutzen von Sonderfällen für spezielle Optimierungsprobleme. Wusstest du, das man jedes Item und nicht nur Module als Angefordert in einer Entität einstellen kann? Du kannst nur Items anfordern, wenn sie errichtet wird, was den Nutzen etwas einschränkt, aber Roboter werden den Auftrag erfüllen. So ist es in einigen Fällen möglich, die Produktion in Gang zu setzten. Mit sowas wie der Recursive-Blueprints-Mod kann man, indem man Montagemaschinen mit Item-Anforderungen platziert und wieder abreißt, wenn sie ihre Items hergestellt haben, eine vollautomatische Fabrik nur mit Baurobotern errichten. Vielleicht kann so die Micro Factory weiter verbessert werden? Ein neues Ziel könnte auch sein, die geringste Entitätenzahl ohne Nutzereingabe zu erreichen, um eine Rakete zu starten. Eine vielleicht generellere Anwendung ist diese Blaupause. Ein einzelner GEschützturm, welcher 200 panzerbrechende Munition anfordert, wenn er errichtet wird. Dies ist besonders nützlich in offensiven Aktionen in großen Beißernestern, da du schnell viele Geschütztürme verteilen kannst und sich die Roboter um die Errichtung und Versorgung mit Munition kümmern, damit du dich drauf konzentrieren kannst, dich nicht in der Beißerpampe aufzulösen. &lt;/source&gt; Darstellung der Geschützturmblaupause in Aktion Streckenfindungsprobleme. Übergebe eine Menge an Außenpostenpunkten und verwende einen Algorithmus um sie automatisch auf kürzester Strecke/mit dem wenigssten Kreuzungen/etc. zu verbinden. Vielleicht könnte man dies sogar direkt aus den Speicherständen auslesen? Kombinatorschaltungen sind in der Regel sehr Komlex und für den Leien unintuitiv und schwer zu verstehen, wie ich in meiner, in der Einführung beschriebenen, ausgiebigen Probierereien herausgefunden habe. Das liegt an der Dichte der Schaltungen, den versteckten Operationen der einzelnen Kombinatoren und dem unverständlichen Haufen Kabel, der keinen Platz zum durchlaufen oder für Verständnis lässt. Es wäre schön ein Programm zu haben, dem man einen Blaupausenstring übergibt und dem Nutzer dann Labelmöglichkeiten oder ähnliches gibt, damit er eine einfach zu verstehende Dokumentation für komplexe Schaltungen schaffen kann. Ich fände es klasse, soetwas zu verwenden um vektorbasierte Schaltpläne für meinen Computer zu erstellen. Sollte ich ihn jemals fertigstellen. Verwende Constraint-Satisfaction um Blaupausen zu erstellen. Ich habe damit in der Vergangenheit experimentiert, und es sollte theoretisch möglich sein, vorrausgesetzt man bekommt die Komplexität von O(MFG) herunter. Falls ich nochmal einen Artikel für Alt-F4 schreibe, wird er vielleicht darüber sein. Man kann auch neuronale Netze für dieses Ziel verwenden, es ist schließlich Python!Ich frage mich, ob man damit tatsächlich verwendbare Blaupausen erhalten kann. Vielleicht könnte man es mit den gesamten Daten aus factorio.school trainieren… Hoffentlich hat dies den kreativen unter euch einige Ideen geliefert. Und vielleicht, aber nur vielleicht, kann jemand, der sich mit einem Skript etwas Zeit sparen möchte, etwas Zeit sparen, anstatt drei bis vier Monate darauf zu verwenden, dafür ein Python-Modul zu schreiben. Es hat zumindest etwas Spaß gemacht. Und man hat ein oder zwei Dinge gelernt. &lt;/source&gt; Es funktioniert! Gott sei Dank. Nun, endlich zurück an die Arbeit. Beitragen Wie immer suchen wir nach Leuten, die zu Alt-F4 beitragen wollen, sei es mit einem Artikel oder durch Hilfe bei Übersetzungen. Wenn du etwas Interessantes im Kopf hast, das du mit der Community in einer eleganten Art teilen möchtest, hier kannst du das tun. Falls du dir unsicher bist, beantworten wir gerne Fragen zu Inhalt und Struktur. Falls das nach etwas klingt, woran du interessiert bist, tritt unserem Discord bei, um es nicht zu verpassen!'>
<link rel="canonical" href="https://alt-f4.blog/de/ALTF4-61/">
<meta property="og:url" content="https://alt-f4.blog/ALTF4-61/">
<meta property="og:site_name" content="Alternative Friday Factorio Fan Facts">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-05-27T00:00:00+00:00">
<script type="application/ld+json">
{"headline":"Alt-F4 #61 - Draftsman: Ein Python-Modul um Blaupausen zu erstellen","dateModified":"2022-05-27T00:00:00+00:00","datePublished":"2022-05-27T00:00:00+00:00","description":"Für die dieswöchige Ausgabe von ALT-F4 besinnen wir uns auf unsere Wurzeln als FFF-Nachfolger im Geiste zurück und vertiefen uns in ein techisches Nischenthema. redruin1 präsentiert seine neueste Erfindung: Factorio Draftsman. Natürlich gab es bereits andere Projekte, welche versuchten eine Bibliothek für Factorio-Blaupausen-Generation zu bilden, aber Draftsman versucht, der neue Standart zu werden. Motivation, technische Details und einige spaßige Projekte, all das und vieles mehr in dieser Ausgabe von ALT-F4! Draftsman redruin1 Vor einigen Monaten entschied ich mich dazu, mich an einer selbst-expandierenden Fabrik zu versuchen. Ich wurde von einigen beeindruckenden Beispielen inspiriert. Ich hatte bereits einige grundlegenden Ideen für die Logik und wie die Fabrik sich selbst überwachen sollte, und natürlich auch einige große Ideen für Dinge, die die Fabrik selbstständik können würde. Das einzige Problem war, das ich bisher noch nie Kombinatoren verwendet habe und sie eigentlich für die Entscheidungsfindung vorgesah. Das ist aber kein Problem, wir wechseln einfach auf einer Test-Welt in den Editor und probieren einige Sachen aus! 1 / 3 2 / 3 Jeder Versuch die inhaltslosen Notizen zu verstehen endet nur in Enttäuschung und Hass. 3 / 3 ANFÄNGERWERTE &#10094; &#10095; Ich bin vielleicht etwas vom Fokus abgekommen. Hier ist meine CPU. Sie stellt die siebte Version dar (glaub ich). Sie besitzt ROM, RAM, einen Stack, 256 Register, über 40 Befehle, Breakpoints und Schrittweise Codeexekution, Hardware und Software-Interrupts und ein generisches Schaltkreis-Interface, um mit anderen Maschinen zu kommunizieren. Factorio. Eins der wenigen Spiele, bei dem man schlauer wird, wenn man es nochmal spielt. Ironischerweise soll es aber gar nicht über irgendwas davon gehen. Das ist alles nur Teil der Vorgeschichte. Ich habe die zweite Version des Computers begonnen und wollte kompakteren ROM. Ich kam auf das unten gezeigte Design, welches 4KiB an echten 32-Bit Nummern pro Zeile speichern kann: Alles beginnt irgendwo. Der ROM ist sehr dicht, aber er funktioniert mit einem System, bei dem jeder Wert in zwei 16-Bit Nummern getrennt wird, welche einzeln gespeichert werden und bei der Ausgabe wieder kombiniert werden. ROM’s sind in der Regel sehr aufwändig herzustellen, da jeder Wert in jedem Kombinator von Hand eingestellt werden muss. An diesem Punkt ist mir mein schön Kompaktes System auf die Füße gefallen, da ich jetzt zusätzlich jeden Wert teilen, Bitweise-UND-Verknüpfen und verschieben muss und jeweils zwei Werte an bestimmten Stellen eintragen muss, mit dem korrekten Wert und Signaltyp. So war es schmerzhaft auffällig, das es eine unglaubliche Aufgabe wäre, dutzende, oder sogar hunderte oder tausende Werte einzutragen, um das gesamte System auszunutzen. Die Lösung? Einen Computer diese Arbeit für mich machen lassen. Er kann dies viel schneller und besser als, ohne dabei Flüchtigkeitsfehler zu machen. Factorio’s Blaupausen-Stringimport-Funktion kann jeden korrekt formatierten String verwenden. Meine Aufgabe war es jetzt nur noch, diesen Textstring korrekt mit meinen gewünschten Kombinatoreinstellungen zu erstellen. Dieses Konzept ist prinzipiell nichts neues. Selbst eine einfache Suche aus Interesse bringt bereits mehrere Ergebnisse: factorio-blueprint NPM module von demipixel, justarandomgeek’s Compiler für seinen gigantischen Kombinator-Computer, eine generische Kombinator-Befehlssprache von Jobarion, Bild-zu-Blaupause-Konverter, etc. Die Liste ist lang. Mit all diesen Beispielen hoffte ich, dass ich einige Übereinstimmungen mit einem dieser Systeme finden würde, die ich als Ausgangspunkt für meine Lösung verwenden könnte, ohne die selben Probleme nocheimal zu lösen. Alle diese Lösungen hatten aber eins gemeinsam: Sie hatten alle Probleme! Viele Implementierungen waren sehr spezifisch nur für ihren ursprünglichen Anwendungsfall gemacht; ein Kombinator-Compiler-Script war nicht verwendbar für Anwendungen, welche nicht das Compilieren für einen speziellen Kombinator-Computer waren. Es fehlte eine einheitliche Sprache; viele waren in Lua, einige in Python, eins in JavaScript, eins in C++ geschrieben. Das bedeutet, dass jedes Programm seine eigene Implementierung für gemeinsame Funktionen benötigte, anstatt das einfach einer eine Funktion schreibt und andere sie übernehmen. Viele waren für mittlerweile stark veraltete Factorio-Versionen. Dokumentation für viele dieser Module war rar, was viele Nutzer wie mich davon abhält, sie zu verwenden, da nicht offensichtlich ist, was sie können und was nicht. Ich war mit der Gesamtsituation unzufrieden und musste so in die Fußstapfen derer, die vor mir gekommen sind, folgen und meine eigene Implementierung schreiben. Was ein Spaß! Ich habe innerhalb eines Nachmittags ein Skript geschrieben, welches perfekt funktionierte und genau das tat, was es sollte. Ich habe ein Schablonensystem genutzt und konnte das ganze so innerhalb von einer Woche komplett fertigstellen. Ich übertreibe nicht: Wenn ich ein stärkerer Mensch wäre, hätte ich es so gelassen und etwas anderes mit meinem Leben angefangen. Aber dann habe ich mich gewundert. Es wäre nicht so schwer, ein Modul wie factorio-blueprint für modernes Factorio aufzubereiten, und ich wette, ich kann mir irgendein automatisches System ausdenken, um automatisch Daten aus Factorio auszulesen, so dass ich nicht per Hand Quelldateien in Abhängigkeit von der Version veränderm müsste. Dann dachte ich mir, wo ich doch gerade dabei bin, könnte ich Dokumentation für den komplexen und wenig dokumentierten control_behavior-Schlüssel in Entitäten schreiben, oder eigene Entitätentypen hinzufügen, um Gruppen von Entitäten zu bilden und zu verändern oder sogar Mod-Support hinzuzufügen. Das ist nun drei oder vier Monate her. Nuja, hier ist ein Pythonmodul, was ich geschrieben habe. Ich stelle vor: factorio-draftsman Ich habe dutzende Kombinationen von Titeln ausprobiert, bevor ich mit diesem zufrieden war. Draftsman ist ein Python-Modul, um alle Arten von Factorio-Blaupausenstrings zu erstellen, verändern, modifizieren oder zu ändern. Das Paket erlaubt dir, Blaupausen mit Programmen zu erstellen und zu designen, um dich bei komplexen und sich oft wiederholenden Blaupausen, welche praktisch nicht von Hand erstellt werden können, zu unterstützen. Draftsman versucht alle Schwächen von bisherigen Werkzeugen zu lösen: Draftsman kann es alles. Alle Entitätstypen werden unterstützt, von Teilern bis zu Stapelgreifern. Wenn es im Spiel geht, geht es auch in Draftsman; so das du dich wieder auf dein eigentliches Problem konzentrieren kannst. Draftsman ist sprachübergreifend. Geschrieben in Python macht es sich sehr einfach zum installieren, einfach zu verwenden und gibt dem Benutzer Zugriff auf den gesamten Packaging-Index von Python. Du kannst wahrscheinlich alles in Python mit Draftsman machen, egal was für ein Factorio-Ding du eigentlich tust. Draftsman ist einfach zu verwenden. Da es von Anfang an für ein einfaches und selbst-dokumentierendes Design ausgelegt wurde, erlaubt es dir, Blaupausen und Entitäten mit selbstvervollständigbaren Methoden und Attributen zu manipulieren. Draftsman ist gut dokumentiert. Jede Funktion, Methode, Attribut und Klasse ist dokumentiert und auf seiner readthedocs-Seite verlinkt. Zusätzlich werden Tutorials und zusätzliches Material bereitgestellt, sowie eine große Menge an Beispielprogrammen, um dabei zu helfen, ein Verständnis für die Funktionsweise von Draftsman herzustellen. Draftsman ist stabil. Eine Gruppe rigoroser Tests garantiert, das Draftsman vorhersagbar und korrekt (oder zumindest korrekt genug) funktioniert. Die Tests decken 100% des Codes ab. Draftsman ist auf den aktuellsten Versionen von Python 2 und 3 verifiziert, und belegbar kompatibel mit allen Factorioversionen ab 1.0. Draftsman beschreibt Probleme. Draftsman besitzt “Factorio-safety” als eine zentrale Philosophie, was bedeutet, das jede Änderung an einer Blaupause, welche zu einem Fehler beim Import führen würde, einen Fehler generiert. Draftsman versucht auch “Factorio-Correctness” zu prüfen, was bedeutet, das Werte, die keinen Fehler verursachen würden, aber nicht sinnvoll sind, eine Warnung generieren. Sowohl Fehler als auch Warnungen sind mit ausgiebigen BEschreibungen versehen, so das alle Probleme mit deinem Skript in Sekunden erkannt und verstanden werden können. Draftsman ist nah am Quellmaterial. Draftsman basiert alle seine Daten auf Wube’s factorio-data repository, was bedeutet, das außnahmslos alle Entitäten genau so sind, wie im Spiel zu erwarten. Das macht Draftsman Up-to-date, vereinfacht das updaten auf neue Factorio-Versionen ungemein und eraubt Versionskontrolle zwischen Draftsman und Factorio, falls in Zukunft Fehler auftreten sollten. Draftsman sunterstützt Mods. Draftsman emuliert Factorio’s Data-Lifecycle direkt, was bedeutet, dass der selbe Ladeprozess, wie wenn du das Spiel startest, in einer einzigen Funktion nachgemacht wird. Zusätzlich dazu, das sichergestellt wird, das Draftsman absolut akkurat zu Factorio ist, wird es so auch kompatibel zu Mod-Prototypen, auf die direkt im Skript zugegriffen werden kann, so als währen sie Factorio-eigene Entitäten. Draftsman besitzt besondere Klassen für jede Entität und Prototyp, und alles ist darum designt, möglichst so problemfrei wie möglich mit Blaupausenstrings und anderer Software zusammenzuarbeten. Du kannst einen Blaupausenstring von Factorio importieren und er wird automatisch in einen Draftsman-Blueprint-Objekt umgewandelt, mit alles seinen Funktionen. Dann kannst du deine gewünschten Änderungen vornehmen und dann dieses Blueprint-Objekt zurück in einen importierbaren Blaupausenstring umwandeln. Alternativ kannst du auch einen völlig neuen Blueprint erstellen; Draftsman soll für dich arbeiten, nicht andersherum. Draftsman unterstützt auch eigene &quot;EntityLike&quot;-Objekte, wie beispielsweise Group, welche dir erlauben, eigene Konstruktionen zu erstellen, welche dann zu Blaupausen hinzugefügt werden, um die Lesbarkeit und Modularität zu erhöhen. Du kannst beispielsweise ein Design für einen Schmelzenblock in einer Group erstellen, und diese dann mehrfach in deiner Blaupause verwenden, wenn gewünscht auch gespiegelt oder rotiert. In einem Versuch, diesen Artikel kurz zu halten, werde ich nicht bis in die kleinsten Details hineingehen, und ganz genau erklären, wie jeder Teil des Moduls funktioniert, ich habe stattdessen viel Zeit dafür aufgewendet, Dokumentation zu schreiben. Stattdessen werde ich lieber einige Dinge zeigen, die ich mit Draftsman bisher gemacht habe, sowie einige Dinge, die damit vielleicht in Zukunft angestellt werden könnten und versuche zu zeigen, warum ich dafür so viel Zeit aufgewendet habe. Automatische Item-Stapelgrößen Oft willst du herausfinden, wie viel Lagerplatz du für eine bestimmte Menge an Items benötigst. Allerdings basiert Lagerung in Factorio nicht auf Mengen sondern Stapeln, so dass der benötigte Lagerplatz nicht nur von der gewünschten Menge sondern auch von der Stapelgröße des gewünschten Itemtyp abhängt. Du kannst dafür eine Kombinatorschaltung errichten, um dies herauszufinden, allerdings benötigst du dort eine große Menge an Kombinatoren um die Ergebnisse zu speichern. Diese Schaltung ist langweilig zu errichten und einfach überfordert, wenn ein neues Item hinzukommt oder sich eine Stapelgröße ändert. Für so eine einfache und sich oft wiederholende Aufgabe ist ein Skript ganz klar besser geeignet: # Schaffe ein N x 5 Gitter an verbundenen Kombinatoren für Konstanten, mit jedem Item und der jeweiligen Stapelgröße from draftsman.blueprintable import Blueprint from draftsman.constants import Direction from draftsman.data import items from draftsman.entity import ConstantCombinator COMBINATOR_HEIGHT = 5 def main(): blueprint = Blueprint() signals_added = 0 signal_index = 0 combinators_added = 0 x = 0 y = 0 combinator = ConstantCombinator(direction=Direction.SOUTH) # Iterier über jedes Item in der richtigen Reihenfolge: for item in items.raw: # Irgnoriere verborgene Items/Entitäten if &quot;flags&quot; in items.raw[item]: if &quot;hidden&quot; in items.raw[item][&quot;flags&quot;]: continue # Zähle, wie viele Signale wir bereits verarbeitet haben signals_added += 1 # Schreibe das Stapelgrößensignal stack_size = items.raw[item][&quot;stack_size&quot;] combinator.set_signal(signal_index, item, stack_size) signal_index += 1 # Wenn wir die Anzahl an Signalen überschreiten, die ein einzelner Kombinator verarbeiten kann, wird er platziert und von vorn begonnen if signal_index == combinator.item_slot_count: # Füge den Kombinator der Blaupause hinzu combinator.id = &quot;{}_{}&quot;.format(x, y) blueprint.entities.append(combinator) # Setzte den Kombinator zurück combinators_added += 1 y = combinators_added % COMBINATOR_HEIGHT x = int(combinators_added / COMBINATOR_HEIGHT) combinator.set_signals(None) # setzte die Signale zurück combinator.tile_position = (x, y) signal_index = 0 # Füge den letzten Kombinator hinzu, wenn nicht vollständig gefüllt if len(combinator.signals) &gt; 0: combinator.id = &quot;{}_{}&quot;.format(x, y) blueprint.entities.append(combinator) # Füge Verbindungen zu den jeweiligen Nachbarn hinzu for cx in range(x): for cy in range(COMBINATOR_HEIGHT): here = &quot;{}_{}&quot;.format(cx, cy) right = &quot;{}_{}&quot;.format(cx + 1, cy) below = &quot;{}_{}&quot;.format(cx, cy + 1) try: blueprint.add_circuit_connection(&quot;red&quot;, here, right) except KeyError: pass try: blueprint.add_circuit_connection(&quot;red&quot;, here, below) except KeyError: pass print(&quot;Number of items added:&quot;, signal_count) print(blueprint.to_string()) if __name__ == &quot;__main__&quot;: main() Dieses Skript ist kompakt und einfach zu folgen, aber das wirklich gute an Draftsman ist, das dieses Skript dynamisch ist und anpassbar ist, egal für welche Factorio-Version. Neue Items, fehlende Items, geänderte Stapelgrößen, egal wer diese Änderungen gemacht hat, werden sie mit diesem Skript abgedeckt. Zur Illustration ist oben links der dargestellt, was das Skript in Vanilla erzeugt, oben rechts der Ausgang für eine mittelgroße Mod wie Space Exploration und unten die Ausgabe für ein Bobs + Pyanodon Mega-Modpack: Dies trifft aber nicht nur auf Items zu. Alle Entitäten, Instrumente, Signale, Rezepte, Module und Fliesen werden im Simulierten Spielladeprozess geladen und gespeichert, um dann von Draftsman verarbeitet zu werden. Jedes Skript kann so designt werden, das es in diesen Kategorien komplett flexibel arbeitet; extra Instumente in programmierbaren Lautsprechern, neue Modultypen für nur bestimmte Maschinen, eine komplette virtuelle Signalliste, etc., alles wird von Draftsman korrekt interpretiert. Durch das interne Speichern der Modkonfiguration für später, bedeutet dies, das du die Daten nur einmal neuladen musst, immer nur wenn du die Modkonfiguration änderst. Bild zu Blaupausen-Konverter Das ist etwas, was ich mal aus Spaß gemacht habe. Es verwendet die Pillow-Bibliothek um ein Bild zu laden und in eine Blaupause zu verwandeln, welche dann von der Karte aus sichtbar ist, in unter 150 Zeilen Code: Ein besonderer Mann mit einer komisch großen Flasche. Es könnten dazu noch viele Verbersserungen gemacht werden: Dithering ist nur in 1x1 Tiles implementiert, da ich Probleme hatte, den Algotithmus auf größere Gebiete auszudehnen. Multi-Tile-Entitäten können die Fehlermetrik nicht korrekt verändern; Palettization funktioniert nur schlecht, wenn die Pixel verschiedene Größen haben. Einige Multi-Tile-Entitäten haben verschiedene Rotierungen. Eine bessere Implementierung würde prüfen, welche Orientierung die wenigsten Fehler produziert, anstatt nur die Standart-Orientierung zu platzieren. Die Farben sind hardgecodet, es wäre schön sie dynamisch aus dem Spiel zu laden, besonders bei durch Mods veränderten Kartenfarben… Trotz dieser Probleme sieht das Ergebnis ganz gut aus, wenn man bedenkt, wie schnell es zusammengeschustert wurde. Das zeigt, das Draftsman flexibel genug ist, um komplexen Anforderungen gerecht zu werden. Jay Bauman, berüchtigter Betrüger, Großkrimineller. Bewaffnet und gefährlich. Wiederauferstehung des Factorio-Movie-Players Vor einer Weile, auf der Suche nach Beispielen für diesen Artikel, kam ich auf den Klassiker Factorio Sandstorm. Ein perfektes Projekt für mein Vorhaben; oder hätte es zumindest sein können, wenn ich die Karte im Spiel hätte öffnen können! Die originale Map-Version war mit einem antiken 0.14.20 datiert. Zusätzlich dazu wurden über die lange Zeit viele Veränderungen vorgenommen, die der Funktionalität des Skriptes, welche Bilder in Blaupausen umwandelt, im Wege standen. Auch die Karte selber hatte einige Probleme, so dass es nicht gereicht hätte, einfach eine alte Factorio-Version zu öffnen und das Skript anzuwenden. Beispielsweise nannte das build.lua-Skript, was für das Encoding zuständig ist, automation-science-pack und logistic-science-pack noch science-pack-1 und science-pack-2. Das sollte einen ungefähren Eindruck davon vermitteln können, wie alt diese Karte ist! Es störte mich, so einen ikonischen Teil der Factorio-Geschichte verfallen zu sehen. Ich nahm mir also die Zeit um die Fehler zu beheben und das ganze auf Version 1.1.57 zu bringen: &lt;/source&gt; Video von feel the beat Gezeigt wird ein Teil von Feel the Beat, um die Tradition von Darude-Musikvideos zu erhalten. Das Build-Script zu ändern, war problemlos per Hand möglich, aber das raw-wood-Signal, welches die Maschine intern verwendet hat, gibt es nicht mehr in neueren Factorio-Versionen. Um dies zu beheben, habe ich jedes Vorkommen dieses Signales mit artillery-wagon ersetzt (da ich sicher sein konnte, das es noch nicht verwendet wurde). Das Updaten der Karte erfolgte in einem Draftsman-Skript. Ich habe auch einige andere Skripte hinzugefügt, um die Bilder aus der Quelle zu extrahieren und Bildschirmfotos zu machen, welche dann automatisch zu einem Video zusammengefügt wurden, was in Python relativ einfach war. Ich habe diese Scripts verwendet, um das oben verlinkte Video zu erstellen. Ich habe auch mit der Idee rumgespielt, Draftsman zu verwenden um eine Blaupausenbasierte Version den Bau-Skrips zu erstellen, anstatt der originalen Konsolenversion. Das würde dir ganz klar zeigen, welche SPeicherorte du mit einer drübergelegten Blaupause veränderst und würde es simpel machen, den Speicher zu erweitern (der vorhandene Speicher ist nur groß genug für 4800 Frames). Ich fand es wichtiger, das auf den neuesten Stand zu bringen, was bisher da war, insbesondere wenn ich wusste, das der vorhandene Code funktioniert. Die Informationsdichte eines Blaupausenstrings ist möglicherweise auch geringer als die eines Konsolenbefehls, welche so groß sind, das sie bei der Verwendung in Textdateien gespeichert werden. Herauszufinden, ob eine Blaupause für diesen Anwendungsfall geeignet ist, kann warten, bis ich später mal Zeit dafür finde. Für mehr Informationen darüber, was neu ist, und auch die neue Weltdatei, verweise ich hier auf meine Fork. Was nun? Ich habe bereits einige Dinge mit diesem Modul gemacht, aber mein ursprüngliches Ziel war es ja, das jeder ganz einfach damit etwas machen kann. Einige Ideen, die ich machen wollte, aber bisher noch keine Zeit dazu gefunden habe, habe ich im Folgenden als Anreize/Ideengeber mal zusammengestellt: Viele Kombinator-Computer-Kompiler sind als Skript geschrieben. Vielleicht könnte man ein LLVM-Äquivalent; einen generische Compiler; schaffen, dem man mitteilt, welche Befehle der Computer bearbeiten kann und der daraufhin Code einer etablierten, High-Level-Sprache, beispielsweise C, compiliert. Vielleicht könnte man sogar LLVM selbst nuten? Ausnutzen von Sonderfällen für spezielle Optimierungsprobleme. Wusstest du, das man jedes Item und nicht nur Module als Angefordert in einer Entität einstellen kann? Du kannst nur Items anfordern, wenn sie errichtet wird, was den Nutzen etwas einschränkt, aber Roboter werden den Auftrag erfüllen. So ist es in einigen Fällen möglich, die Produktion in Gang zu setzten. Mit sowas wie der Recursive-Blueprints-Mod kann man, indem man Montagemaschinen mit Item-Anforderungen platziert und wieder abreißt, wenn sie ihre Items hergestellt haben, eine vollautomatische Fabrik nur mit Baurobotern errichten. Vielleicht kann so die Micro Factory weiter verbessert werden? Ein neues Ziel könnte auch sein, die geringste Entitätenzahl ohne Nutzereingabe zu erreichen, um eine Rakete zu starten. Eine vielleicht generellere Anwendung ist diese Blaupause. Ein einzelner GEschützturm, welcher 200 panzerbrechende Munition anfordert, wenn er errichtet wird. Dies ist besonders nützlich in offensiven Aktionen in großen Beißernestern, da du schnell viele Geschütztürme verteilen kannst und sich die Roboter um die Errichtung und Versorgung mit Munition kümmern, damit du dich drauf konzentrieren kannst, dich nicht in der Beißerpampe aufzulösen. &lt;/source&gt; Darstellung der Geschützturmblaupause in Aktion Streckenfindungsprobleme. Übergebe eine Menge an Außenpostenpunkten und verwende einen Algorithmus um sie automatisch auf kürzester Strecke/mit dem wenigssten Kreuzungen/etc. zu verbinden. Vielleicht könnte man dies sogar direkt aus den Speicherständen auslesen? Kombinatorschaltungen sind in der Regel sehr Komlex und für den Leien unintuitiv und schwer zu verstehen, wie ich in meiner, in der Einführung beschriebenen, ausgiebigen Probierereien herausgefunden habe. Das liegt an der Dichte der Schaltungen, den versteckten Operationen der einzelnen Kombinatoren und dem unverständlichen Haufen Kabel, der keinen Platz zum durchlaufen oder für Verständnis lässt. Es wäre schön ein Programm zu haben, dem man einen Blaupausenstring übergibt und dem Nutzer dann Labelmöglichkeiten oder ähnliches gibt, damit er eine einfach zu verstehende Dokumentation für komplexe Schaltungen schaffen kann. Ich fände es klasse, soetwas zu verwenden um vektorbasierte Schaltpläne für meinen Computer zu erstellen. Sollte ich ihn jemals fertigstellen. Verwende Constraint-Satisfaction um Blaupausen zu erstellen. Ich habe damit in der Vergangenheit experimentiert, und es sollte theoretisch möglich sein, vorrausgesetzt man bekommt die Komplexität von O(MFG) herunter. Falls ich nochmal einen Artikel für Alt-F4 schreibe, wird er vielleicht darüber sein. Man kann auch neuronale Netze für dieses Ziel verwenden, es ist schließlich Python!Ich frage mich, ob man damit tatsächlich verwendbare Blaupausen erhalten kann. Vielleicht könnte man es mit den gesamten Daten aus factorio.school trainieren… Hoffentlich hat dies den kreativen unter euch einige Ideen geliefert. Und vielleicht, aber nur vielleicht, kann jemand, der sich mit einem Skript etwas Zeit sparen möchte, etwas Zeit sparen, anstatt drei bis vier Monate darauf zu verwenden, dafür ein Python-Modul zu schreiben. Es hat zumindest etwas Spaß gemacht. Und man hat ein oder zwei Dinge gelernt. &lt;/source&gt; Es funktioniert! Gott sei Dank. Nun, endlich zurück an die Arbeit. Beitragen Wie immer suchen wir nach Leuten, die zu Alt-F4 beitragen wollen, sei es mit einem Artikel oder durch Hilfe bei Übersetzungen. Wenn du etwas Interessantes im Kopf hast, das du mit der Community in einer eleganten Art teilen möchtest, hier kannst du das tun. Falls du dir unsicher bist, beantworten wir gerne Fragen zu Inhalt und Struktur. Falls das nach etwas klingt, woran du interessiert bist, tritt unserem Discord bei, um es nicht zu verpassen!","url":"https://alt-f4.blog/ALTF4-61/","@type":"BlogPosting","author":{"@type":"Person","name":"redruin1"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://alt-f4.blog/ALTF4-61/"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
	

	
	  <meta property="og:image" content="https://alt-f4.blog/assets/ALTF4/61/thumbnail.jpg">
	  <meta name="twitter:image" content="https://alt-f4.blog/assets/ALTF4/61/thumbnail.jpg">
	

	<!-- CSS & fonts -->
	<link href="/de/assets/GLOBAL/css/titillium-web.css" rel="stylesheet">
	<link rel="stylesheet" href="/de/assets/GLOBAL/css/style.css">
	<link rel="stylesheet" href="/de/assets/GLOBAL/css/spidertron.css">
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.css" rel="stylesheet" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,400italic%7CSignika:700,300,400,600" rel="stylesheet" type="text/css">

	<link href="/de/assets/GLOBAL/img/favicon.ico" rel="icon" type="image/x-icon">
	<link href="/de/assets/GLOBAL/img/favicon.ico" rel="shortcut icon" type="image/x-icon">

	<!-- RSS -->
	<link href="/de/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed">

	<script src="/assets/GLOBAL/js/spidertron.js"></script>
	<script src="/assets/GLOBAL/js/localization.js"></script>
	<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
</head>


  <body>
    <!-- Navigation Bar -->
    <nav id="top" class="top-bar">
	<div class="top-bar-inner flex flex-space-between">
		<div class="sites links flex">
			<a href="/de/" class="sites-current">
				<div id="navbar-logo" role="img" aria-label="Alt-F4 Logo"></div>
			</a>
			<a href="https://alt-f4.blog/de/discord" class="">Discord</a>
			<span class="separator">|</span>
			<a href="https://factorio.com/blog" class="">FFF</a>
		</div>
		<div class="sites links flex hide-tag-line">
			<em>Der communityproduzierte Nachfolger zu den geliebten Factorio Friday Facts</em>
		</div>
		<div class="dropdown flex-end">
			<a class="button flex flex-space-between" href="#">
				<i class="fas fa-language"></i>
			</a>
			<div class="submenu">
				
				<a class="button lang-button" href="/../ALTF4-61/" onclick="setLanguage('en')">English</a>
				
				<a class="button lang-button" href="/cs/ALTF4-61/" onclick="setLanguage('cs')">Čeština</a>
				
				<a class="button button-green lang-button" href="/de/ALTF4-61/" onclick="setLanguage('de')">Deutsch</a>
				
				<a class="button lang-button" href="/es/ALTF4-61/" onclick="setLanguage('es')">Español</a>
				
				<a class="button lang-button" href="/fr/ALTF4-61/" onclick="setLanguage('fr')">Français</a>
				
				<a class="button lang-button" href="/it/ALTF4-61/" onclick="setLanguage('it')">Italiano</a>
				
				<a class="button lang-button" href="/nl/ALTF4-61/" onclick="setLanguage('nl')">Nederlands</a>
				
				<a class="button lang-button" href="/pt-br/ALTF4-61/" onclick="setLanguage('pt-br')">Português Brasileiro</a>
				
				<a class="button lang-button" href="/ru/ALTF4-61/" onclick="setLanguage('ru')">Русский</a>
				
				<a class="button lang-button" href="/zh/ALTF4-61/" onclick="setLanguage('zh')">中文</a>
				
			</div>
		</div>
	</div>
</nav>


    <!-- Main content -->
    <div class="container">
      <div class="container-inner">
        <div class="small-center"></div>
        <!-- Posts -->
        <article class="panel blog-post">
	
	<h1 class="page-title-headder">Alt-F4 #61 - Draftsman: Ein Python-Modul um Blaupausen zu erstellen  <author>27.05.2022</author>
</h1>
	
	
	<div class="panel-inset mb0">
		
Geschrieben von <em>redruin1</em>,



editiert von <em>Nanogamer7, stringweasel, Conor_, Therenas, MyNameIsTrez, Firerazer</em>,



<br>übersetzt von <em>EDLEXUS</em>






	</div>
	
	<div class="panel-inset-lighter mt0">
		<div class="post-header">
  <div class="panel">
    <div class="outer">
      <img class="inner" src="/assets/ALTF4/61/thumbnail.jpg" alt="" style="margin: 1px;">
    </div>
  </div>
  <details class="panel toc">
    <summary>
      <h2>Inhaltsverzeichnis</h2>
    </summary>
    <div class="panel-inset mb0">
      <ul>
  <li>
<a href="#draftsman-redruin1">Draftsman <author>redruin1</author></a>
    <ul>
      <li><a href="#ich-stelle-vor-factorio-draftsman">Ich stelle vor: <code class="language-plaintext highlighter-rouge">factorio-draftsman</code></a></li>
      <li><a href="#automatische-item-stapelgr%C3%B6%C3%9Fen">Automatische Item-Stapelgrößen</a></li>
      <li><a href="#bild-zu-blaupausen-konverter">Bild zu Blaupausen-Konverter</a></li>
      <li><a href="#wiederauferstehung-des-factorio-movie-players">Wiederauferstehung des Factorio-Movie-Players</a></li>
      <li><a href="#was-nun">Was nun?</a></li>
    </ul>
  </li>
  <li><a href="#beitragen">Beitragen</a></li>
</ul>

    </div>
  </details>
</div>




<p>Für die dieswöchige Ausgabe von ALT-F4 besinnen wir uns auf unsere Wurzeln als FFF-Nachfolger im Geiste zurück und vertiefen uns in ein techisches Nischenthema. <em>redruin1</em> präsentiert seine neueste Erfindung: Factorio Draftsman. Natürlich gab es bereits andere Projekte, welche versuchten eine Bibliothek für Factorio-Blaupausen-Generation zu bilden, aber Draftsman versucht, der neue Standart zu werden. Motivation, technische Details und einige spaßige Projekte, all das und vieles mehr in dieser Ausgabe von ALT-F4!</p>
      <h2 id="draftsman-redruin1">
        
        
            <a href="#draftsman-redruin1" class="anchor" style="text-decoration: none;">Draftsman <author>redruin1</author></a>
          
        
      </h2>
    

<p>Vor einigen Monaten entschied ich mich dazu, mich an einer <strong>selbst-expandierenden Fabrik</strong> zu versuchen. Ich wurde von einigen <a href="https://www.youtube.com/watch?v=xF--1XdcOeM">beeindruckenden</a> <a href="https://alt-f4.blog/de/ALTF4-39/">Beispielen</a> inspiriert. Ich hatte bereits einige grundlegenden Ideen für die Logik und wie die Fabrik sich selbst überwachen sollte, und natürlich auch einige große Ideen für Dinge, die die Fabrik selbstständik können würde. Das einzige Problem war, das ich bisher noch nie Kombinatoren verwendet habe und sie eigentlich für die Entscheidungsfindung vorgesah.</p>

<p>Das ist aber kein Problem, wir wechseln einfach auf einer Test-Welt in den Editor und probieren einige Sachen aus!</p>

<!---->

<!---->

<div class="flex flex-column panel-inset">
  <div class="gallery">

    <!---->
    
    
    <div class="galleryItem">
      <div class="numbertext">1 / 3</div>
      <img src="https://media.alt-f4.blog/ALTF4/61/map_view_of_madness.jpg" alt="Tod" style="width:100%">
      <!---->
      <p style="text-align: center; margin-top:8px; margin-bottom:8px"></p>
    </div>
    
    
    <div class="galleryItem">
      <div class="numbertext">2 / 3</div>
      <img src="https://media.alt-f4.blog/ALTF4/61/madness.jpg" alt="Noch mehr Tod" style="width:100%">
      <!---->
      <p style="text-align: center; margin-top:8px; margin-bottom:8px">Jeder Versuch die inhaltslosen Notizen zu verstehen endet nur in Enttäuschung und Hass.</p>
    </div>
    
    
    <div class="galleryItem">
      <div class="numbertext">3 / 3</div>
      <img src="https://media.alt-f4.blog/ALTF4/61/play_time.jpg" alt="zu viel Spielzeit" style="width:100%">
      <!---->
      <p style="text-align: center; margin-top:8px; margin-bottom:8px">ANFÄNGERWERTE</p>
    </div>
    

    <!---->
    <a class="prev" onclick="plusSlides(-1)">❮</a>
    <a class="next" onclick="plusSlides(1)">❯</a>

    <!---->
    <div class="row">
      
      
      <div class="column">
        <img class="galleryPreview" src="https://media.alt-f4.blog/ALTF4/61/map_view_of_madness.jpg" alt="Tod" onclick="currentSlide(1)" style="width:100%; cursor: pointer;">
      </div>
      
      
      <div class="column">
        <img class="galleryPreview" src="https://media.alt-f4.blog/ALTF4/61/madness.jpg" alt="Noch mehr Tod" onclick="currentSlide(2)" style="width:100%; cursor: pointer;">
      </div>
      
      
      <div class="column">
        <img class="galleryPreview" src="https://media.alt-f4.blog/ALTF4/61/play_time.jpg" alt="zu viel Spielzeit" onclick="currentSlide(3)" style="width:100%; cursor: pointer;">
      </div>
      
    </div>
  </div>
  <!---->
  
</div>

<p>Ich bin vielleicht etwas vom Fokus abgekommen.</p>

<p>Hier ist meine CPU. Sie stellt die siebte Version dar (glaub ich). Sie besitzt ROM, RAM, einen Stack, 256 Register, über 40 Befehle, Breakpoints und Schrittweise Codeexekution, Hardware und Software-Interrupts und ein generisches Schaltkreis-Interface, um mit anderen Maschinen zu kommunizieren.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/mk1_computer.jpg" alt="Bild meines ersten CPU-Designs" style="max-width: ; max-height:  ">
        
        <figcaption>Factorio. Eins der wenigen Spiele, bei dem man schlauer wird, wenn man es nochmal spielt.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Ironischerweise soll es aber gar nicht über irgendwas davon gehen. Das ist alles nur Teil der Vorgeschichte.</p>

<p>Ich habe die zweite Version des Computers begonnen und wollte kompakteren ROM. Ich kam auf das unten gezeigte Design, welches 4KiB an echten 32-Bit Nummern pro Zeile speichern kann:</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/ROM_design.jpg" alt="Bild meines ROM" style="max-width: ; max-height:  ">
        
        <figcaption>Alles beginnt irgendwo.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Der ROM ist <em>sehr</em> dicht, aber er funktioniert mit einem System, bei dem jeder Wert in zwei 16-Bit Nummern getrennt wird, welche einzeln gespeichert werden und bei der Ausgabe wieder kombiniert werden. ROM’s sind in der Regel sehr aufwändig herzustellen, da jeder Wert in jedem Kombinator von Hand eingestellt werden muss. An diesem Punkt ist mir mein schön Kompaktes System auf die Füße gefallen, da ich jetzt zusätzlich jeden Wert teilen, Bitweise-UND-Verknüpfen und verschieben muss und jeweils zwei Werte an bestimmten Stellen eintragen muss, mit dem korrekten Wert <em>und</em> Signaltyp. So war es schmerzhaft auffällig, das es eine unglaubliche Aufgabe wäre, dutzende, oder sogar hunderte oder tausende Werte einzutragen, um das gesamte System auszunutzen.</p>

<p>Die Lösung? Einen Computer diese Arbeit für mich machen lassen. Er kann dies viel schneller und besser als, ohne dabei Flüchtigkeitsfehler zu machen. Factorio’s Blaupausen-Stringimport-Funktion kann jeden korrekt formatierten String verwenden. Meine Aufgabe war es jetzt nur noch, diesen Textstring korrekt mit meinen gewünschten Kombinatoreinstellungen zu erstellen.</p>

<p>Dieses Konzept ist prinzipiell nichts neues. Selbst eine einfache Suche aus Interesse bringt bereits mehrere Ergebnisse: <a href="https://github.com/demipixel/factorio-blueprint"><code class="language-plaintext highlighter-rouge">factorio-blueprint</code> NPM module von demipixel</a>, <a href="https://github.com/justarandomgeek/factorio-computer">justarandomgeek’s Compiler für seinen gigantischen Kombinator-Computer</a>, <a href="https://github.com/Jobarion/factoriogen/">eine generische Kombinator-Befehlssprache von Jobarion</a>, <a href="https://github.com/EFLFE/Artorio">Bild-zu-Blaupause-Konverter</a>, etc. Die Liste ist lang.</p>

<p>Mit all diesen Beispielen hoffte ich, dass ich einige Übereinstimmungen mit einem dieser Systeme finden würde, die ich als Ausgangspunkt für meine Lösung verwenden könnte, ohne die selben Probleme nocheimal zu lösen. Alle diese Lösungen hatten aber eins gemeinsam: Sie hatten alle Probleme!</p>

<ul>
  <li>Viele Implementierungen waren sehr spezifisch nur für ihren ursprünglichen Anwendungsfall gemacht; ein Kombinator-Compiler-Script war nicht verwendbar für Anwendungen, welche nicht das Compilieren für einen speziellen Kombinator-Computer waren.</li>
  <li>Es fehlte eine einheitliche Sprache; viele waren in Lua, einige in Python, eins in JavaScript, eins in C++ geschrieben. Das bedeutet, dass jedes Programm seine eigene Implementierung für gemeinsame Funktionen benötigte, anstatt das einfach einer eine Funktion schreibt und andere sie übernehmen.</li>
  <li>Viele waren für mittlerweile stark veraltete Factorio-Versionen.</li>
  <li>Dokumentation für viele dieser Module war rar, was viele Nutzer wie mich davon abhält, sie zu verwenden, da nicht offensichtlich ist, was sie können und was nicht.</li>
</ul>

<p>Ich war mit der Gesamtsituation unzufrieden und musste so in die Fußstapfen derer, die vor mir gekommen sind, folgen und meine eigene Implementierung schreiben. Was ein Spaß!</p>

<p>Ich habe innerhalb eines Nachmittags ein Skript geschrieben, welches perfekt funktionierte und genau das tat, was es sollte. Ich habe ein Schablonensystem genutzt und konnte das ganze so innerhalb von einer Woche komplett fertigstellen.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/populated_ROM.jpg" alt="fertiges Endergebnis" style="max-width: ; max-height:  ">
        
        <figcaption>Ich übertreibe nicht: Wenn ich ein stärkerer Mensch wäre, hätte ich es so gelassen und etwas anderes mit meinem Leben angefangen.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Aber dann habe ich mich gewundert. Es wäre nicht so schwer, ein Modul wie <code class="language-plaintext highlighter-rouge">factorio-blueprint</code> für modernes Factorio aufzubereiten, und ich wette, ich kann mir irgendein automatisches System ausdenken, um automatisch Daten aus Factorio auszulesen, so dass ich nicht per Hand Quelldateien in Abhängigkeit von der Version veränderm müsste. Dann dachte ich mir, wo ich doch gerade dabei bin, könnte ich Dokumentation für den komplexen und wenig dokumentierten <code class="language-plaintext highlighter-rouge">control_behavior</code>-Schlüssel in Entitäten schreiben, oder eigene Entitätentypen hinzufügen, um Gruppen von Entitäten zu bilden und zu verändern oder sogar <em>Mod-Support</em> hinzuzufügen. Das ist nun drei oder vier Monate her.</p>

<p>Nuja, hier ist ein Pythonmodul, was ich geschrieben habe.</p>
      <h3 id="ich-stelle-vor-factorio-draftsman">
        
        
            <a href="#ich-stelle-vor-factorio-draftsman" class="anchor" style="text-decoration: none;">Ich stelle vor: <code class="language-plaintext highlighter-rouge">factorio-draftsman</code></a>
          
        
      </h3>
    

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/draftsman_logo.jpg" alt="Draftsman-Logo, gezeigt im Spiel und über ein Skript gezeichnet." style="max-width: ; max-height:  ">
        
        <figcaption>Ich habe dutzende Kombinationen von Titeln ausprobiert, bevor ich mit diesem zufrieden war.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p><a href="https://github.com/redruin1/factorio-draftsman">Draftsman</a> ist ein Python-Modul, um alle Arten von Factorio-Blaupausenstrings zu erstellen, verändern, modifizieren oder zu ändern. Das Paket erlaubt dir, Blaupausen mit Programmen zu erstellen und zu designen, um dich bei komplexen und sich oft wiederholenden Blaupausen, welche praktisch nicht von Hand erstellt werden können, zu unterstützen. Draftsman versucht alle Schwächen von bisherigen Werkzeugen zu lösen:</p>

<ul>
  <li>
<strong>Draftsman kann es alles.</strong> Alle Entitätstypen werden unterstützt, von Teilern bis zu Stapelgreifern. Wenn es im Spiel geht, geht es auch in Draftsman; so das du dich wieder auf dein eigentliches Problem konzentrieren kannst.</li>
  <li>
<strong>Draftsman ist sprachübergreifend.</strong> Geschrieben in Python macht es sich sehr einfach zum installieren, einfach zu verwenden und gibt dem Benutzer Zugriff auf den gesamten Packaging-Index von Python. Du kannst wahrscheinlich alles in Python mit Draftsman machen, egal <em>was</em> für ein Factorio-Ding du eigentlich tust.</li>
  <li>
<strong>Draftsman ist einfach zu verwenden.</strong> Da es von Anfang an für ein einfaches und selbst-dokumentierendes Design ausgelegt wurde, erlaubt es dir, Blaupausen und Entitäten mit selbstvervollständigbaren Methoden und Attributen zu manipulieren.</li>
  <li>
<strong>Draftsman ist gut dokumentiert.</strong> Jede Funktion, Methode, Attribut und Klasse ist dokumentiert und auf seiner <a href="https://factorio-draftsman.readthedocs.io/en/latest/?badge=latest">readthedocs-Seite</a> verlinkt. Zusätzlich werden Tutorials und zusätzliches Material bereitgestellt, sowie eine große Menge an <a href="https://github.com/redruin1/factorio-draftsman/tree/main/examples">Beispielprogrammen</a>, um dabei zu helfen, ein Verständnis für die Funktionsweise von Draftsman herzustellen.</li>
  <li>
<strong>Draftsman ist stabil.</strong> Eine Gruppe rigoroser Tests garantiert, das Draftsman vorhersagbar und korrekt (oder zumindest korrekt genug) funktioniert. Die Tests decken 100% des Codes ab. Draftsman ist auf den aktuellsten Versionen von Python 2 und 3 verifiziert, und belegbar kompatibel mit allen Factorioversionen ab 1.0.</li>
  <li>
<strong>Draftsman beschreibt Probleme.</strong> Draftsman besitzt “Factorio-safety” als eine zentrale Philosophie, was bedeutet, das jede Änderung an einer Blaupause, welche zu einem Fehler beim Import führen würde, einen Fehler generiert. Draftsman versucht auch “Factorio-Correctness” zu prüfen, was bedeutet, das Werte, die keinen Fehler verursachen würden, aber nicht sinnvoll sind, eine Warnung generieren. Sowohl Fehler als auch Warnungen sind mit ausgiebigen BEschreibungen versehen, so das alle Probleme mit deinem Skript in Sekunden erkannt und verstanden werden können.</li>
  <li>
<strong>Draftsman ist nah am Quellmaterial.</strong> Draftsman basiert alle seine Daten auf <a href="https://github.com/wube/factorio-data">Wube’s <code class="language-plaintext highlighter-rouge">factorio-data</code> repository</a>, was bedeutet, das außnahmslos alle Entitäten genau so sind, wie im Spiel zu erwarten. Das macht Draftsman Up-to-date, vereinfacht das updaten auf neue Factorio-Versionen ungemein und eraubt Versionskontrolle zwischen Draftsman und Factorio, falls in Zukunft Fehler auftreten sollten.</li>
  <li>
<strong>Draftsman sunterstützt Mods.</strong> Draftsman emuliert <a href="https://lua-api.factorio.com/latest/Data-Lifecycle.html">Factorio’s Data-Lifecycle</a> direkt, was bedeutet, dass der selbe Ladeprozess, wie wenn du das Spiel startest, in einer einzigen Funktion nachgemacht wird. Zusätzlich dazu, das sichergestellt wird, das Draftsman absolut akkurat zu Factorio ist, wird es so auch kompatibel zu Mod-Prototypen, auf die direkt im Skript zugegriffen werden kann, so als währen sie Factorio-eigene Entitäten.</li>
</ul>

<p>Draftsman besitzt besondere Klassen für jede Entität und Prototyp, und alles ist darum designt, möglichst so problemfrei wie möglich mit Blaupausenstrings und anderer Software zusammenzuarbeten. Du kannst einen Blaupausenstring von Factorio importieren und er wird automatisch in einen Draftsman-<code class="language-plaintext highlighter-rouge">Blueprint</code>-Objekt umgewandelt, mit alles seinen Funktionen. Dann kannst du deine gewünschten Änderungen vornehmen und dann dieses <code class="language-plaintext highlighter-rouge">Blueprint</code>-Objekt zurück in einen importierbaren Blaupausenstring umwandeln. Alternativ kannst du auch einen völlig neuen <code class="language-plaintext highlighter-rouge">Blueprint</code> erstellen; Draftsman soll für dich arbeiten, nicht andersherum.</p>

<p>Draftsman unterstützt auch eigene <code class="language-plaintext highlighter-rouge">"EntityLike"</code>-Objekte, wie beispielsweise <code class="language-plaintext highlighter-rouge">Group</code>, welche dir erlauben, eigene Konstruktionen zu erstellen, welche dann zu Blaupausen hinzugefügt werden, um die Lesbarkeit und Modularität zu erhöhen. Du kannst beispielsweise ein Design für einen Schmelzenblock in einer <code class="language-plaintext highlighter-rouge">Group</code> erstellen, und diese dann mehrfach in deiner Blaupause verwenden, wenn gewünscht auch gespiegelt oder rotiert.</p>

<p>In einem Versuch, diesen Artikel kurz zu halten, werde ich nicht bis in die kleinsten Details hineingehen, und ganz genau erklären, wie jeder Teil des Moduls funktioniert, ich habe stattdessen viel Zeit dafür aufgewendet, Dokumentation zu schreiben. Stattdessen werde ich lieber einige Dinge zeigen, die ich mit Draftsman bisher gemacht habe, sowie einige Dinge, die damit vielleicht in Zukunft angestellt werden könnten und versuche zu zeigen, warum ich dafür so viel Zeit aufgewendet habe.</p>
      <h3 id="automatische-item-stapelgrößen">
        
        
            <a href="#automatische-item-stapelgr%C3%B6%C3%9Fen" class="anchor" style="text-decoration: none;">Automatische Item-Stapelgrößen</a>
          
        
      </h3>
    

<p>Oft willst du herausfinden, wie viel Lagerplatz du für eine bestimmte Menge an Items benötigst. Allerdings basiert Lagerung in Factorio nicht auf Mengen sondern Stapeln, so dass der benötigte Lagerplatz nicht nur von der gewünschten Menge sondern auch von der Stapelgröße des gewünschten Itemtyp abhängt. Du kannst dafür eine <a href="https://factorioprints.com/view/-LwH68dlvOEIKWkU5JqR">Kombinatorschaltung</a> errichten, um dies herauszufinden, allerdings benötigst du dort eine große Menge an Kombinatoren um die Ergebnisse zu speichern. Diese Schaltung ist langweilig zu errichten und einfach überfordert, wenn ein neues Item hinzukommt oder sich eine Stapelgröße ändert. Für so eine einfache und sich oft wiederholende Aufgabe ist ein Skript ganz klar besser geeignet:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Schaffe ein N x 5 Gitter an verbundenen Kombinatoren für Konstanten, mit jedem Item und der jeweiligen Stapelgröße
</span>
<span class="kn">from</span> <span class="nn">draftsman.blueprintable</span> <span class="kn">import</span> <span class="n">Blueprint</span>
<span class="kn">from</span> <span class="nn">draftsman.constants</span> <span class="kn">import</span> <span class="n">Direction</span>
<span class="kn">from</span> <span class="nn">draftsman.data</span> <span class="kn">import</span> <span class="n">items</span>
<span class="kn">from</span> <span class="nn">draftsman.entity</span> <span class="kn">import</span> <span class="n">ConstantCombinator</span>

<span class="n">COMBINATOR_HEIGHT</span> <span class="o">=</span> <span class="mi">5</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">blueprint</span> <span class="o">=</span> <span class="n">Blueprint</span><span class="p">()</span>

    <span class="n">signals_added</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">signal_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">combinators_added</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">combinator</span> <span class="o">=</span> <span class="n">ConstantCombinator</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">Direction</span><span class="p">.</span><span class="n">SOUTH</span><span class="p">)</span>

    <span class="c1"># Iterier über jedes Item in der richtigen Reihenfolge:
</span>    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">.</span><span class="n">raw</span><span class="p">:</span>
        <span class="c1"># Irgnoriere verborgene Items/Entitäten
</span>        <span class="k">if</span> <span class="s">"flags"</span> <span class="ow">in</span> <span class="n">items</span><span class="p">.</span><span class="n">raw</span><span class="p">[</span><span class="n">item</span><span class="p">]:</span>
            <span class="k">if</span> <span class="s">"hidden"</span> <span class="ow">in</span> <span class="n">items</span><span class="p">.</span><span class="n">raw</span><span class="p">[</span><span class="n">item</span><span class="p">][</span><span class="s">"flags"</span><span class="p">]:</span>
                <span class="k">continue</span>
        <span class="c1"># Zähle, wie viele Signale wir bereits verarbeitet haben
</span>        <span class="n">signals_added</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Schreibe das Stapelgrößensignal
</span>        <span class="n">stack_size</span> <span class="o">=</span> <span class="n">items</span><span class="p">.</span><span class="n">raw</span><span class="p">[</span><span class="n">item</span><span class="p">][</span><span class="s">"stack_size"</span><span class="p">]</span>
        <span class="n">combinator</span><span class="p">.</span><span class="n">set_signal</span><span class="p">(</span><span class="n">signal_index</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">)</span>
        <span class="n">signal_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Wenn wir die Anzahl an Signalen überschreiten, die ein einzelner Kombinator verarbeiten kann, wird er platziert und von vorn begonnen
</span>        <span class="k">if</span> <span class="n">signal_index</span> <span class="o">==</span> <span class="n">combinator</span><span class="p">.</span><span class="n">item_slot_count</span><span class="p">:</span>
            <span class="c1"># Füge den Kombinator der Blaupause hinzu
</span>            <span class="n">combinator</span><span class="p">.</span><span class="nb">id</span> <span class="o">=</span> <span class="s">"{}_{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">blueprint</span><span class="p">.</span><span class="n">entities</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">combinator</span><span class="p">)</span>
            <span class="c1"># Setzte den Kombinator zurück
</span>            <span class="n">combinators_added</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">combinators_added</span> <span class="o">%</span> <span class="n">COMBINATOR_HEIGHT</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">combinators_added</span> <span class="o">/</span> <span class="n">COMBINATOR_HEIGHT</span><span class="p">)</span>
            <span class="n">combinator</span><span class="p">.</span><span class="n">set_signals</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span> <span class="c1"># setzte die Signale zurück
</span>            <span class="n">combinator</span><span class="p">.</span><span class="n">tile_position</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">signal_index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Füge den letzten Kombinator hinzu, wenn nicht vollständig gefüllt
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">combinator</span><span class="p">.</span><span class="n">signals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
	<span class="n">combinator</span><span class="p">.</span><span class="nb">id</span> <span class="o">=</span> <span class="s">"{}_{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
	<span class="n">blueprint</span><span class="p">.</span><span class="n">entities</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">combinator</span><span class="p">)</span>

    <span class="c1"># Füge Verbindungen zu den jeweiligen Nachbarn hinzu
</span>    <span class="k">for</span> <span class="n">cx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">cy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">COMBINATOR_HEIGHT</span><span class="p">):</span>
            <span class="n">here</span> <span class="o">=</span> <span class="s">"{}_{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="s">"{}_{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cy</span><span class="p">)</span>
            <span class="n">below</span> <span class="o">=</span> <span class="s">"{}_{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">blueprint</span><span class="p">.</span><span class="n">add_circuit_connection</span><span class="p">(</span><span class="s">"red"</span><span class="p">,</span> <span class="n">here</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">blueprint</span><span class="p">.</span><span class="n">add_circuit_connection</span><span class="p">(</span><span class="s">"red"</span><span class="p">,</span> <span class="n">here</span><span class="p">,</span> <span class="n">below</span><span class="p">)</span>
            <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Number of items added:"</span><span class="p">,</span> <span class="n">signal_count</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">blueprint</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>Dieses Skript ist kompakt und einfach zu folgen, aber das wirklich gute an Draftsman ist, das dieses Skript dynamisch ist und anpassbar ist, egal für welche Factorio-Version. Neue Items, fehlende Items, geänderte Stapelgrößen, egal wer diese Änderungen gemacht hat, werden sie mit diesem Skript abgedeckt. Zur Illustration ist oben links der dargestellt, was das Skript in Vanilla erzeugt, oben rechts der Ausgang für eine mittelgroße Mod wie <a href="https://mods.factorio.com/mod/space-exploration">Space Exploration</a> und unten die Ausgabe für ein <a href="https://mods.factorio.com/user/Bobingabout">Bobs</a> + <a href="https://mods.factorio.com/user/pyanodon">Pyanodon</a> Mega-Modpack:</p>

<p><img src="https://media.alt-f4.blog/ALTF4/61/item_stack_size_output.jpg" alt="Ergebnissse"></p>

<p>Dies trifft aber nicht nur auf Items zu. Alle Entitäten, Instrumente, Signale, Rezepte, Module und Fliesen werden im Simulierten Spielladeprozess geladen und gespeichert, um dann von Draftsman verarbeitet zu werden. Jedes Skript kann so designt werden, das es in diesen Kategorien komplett flexibel arbeitet; extra Instumente in programmierbaren Lautsprechern, neue Modultypen für nur bestimmte Maschinen, eine komplette virtuelle Signalliste, etc., alles wird von Draftsman korrekt interpretiert. Durch das interne Speichern der Modkonfiguration für später, bedeutet dies, das du die Daten nur einmal neuladen musst, immer nur wenn du die Modkonfiguration änderst.</p>
      <h3 id="bild-zu-blaupausen-konverter">
        
        
            <a href="#bild-zu-blaupausen-konverter" class="anchor" style="text-decoration: none;">Bild zu Blaupausen-Konverter</a>
          
        
      </h3>
    

<p><a href="https://github.com/redruin1/factorio-draftsman/blob/main/examples/image_converter.py">Das ist etwas, was ich mal aus Spaß gemacht habe.</a> Es verwendet die <code class="language-plaintext highlighter-rouge">Pillow</code>-Bibliothek um ein Bild zu laden und in eine Blaupause zu verwandeln, welche dann von der Karte aus sichtbar ist, in unter 150 Zeilen Code:</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/mike_stoklasa.jpg" alt="Portrait von Mike" style="max-width: ; max-height:  ">
        
        <figcaption>Ein besonderer Mann mit einer komisch großen Flasche.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Es könnten dazu noch viele Verbersserungen gemacht werden:</p>

<ul>
  <li>Dithering ist nur in 1x1 Tiles implementiert, da ich Probleme hatte, den Algotithmus auf größere Gebiete auszudehnen.</li>
  <li>Multi-Tile-Entitäten können die Fehlermetrik nicht korrekt verändern; Palettization funktioniert nur schlecht, wenn die Pixel verschiedene Größen haben.</li>
  <li>Einige Multi-Tile-Entitäten haben verschiedene Rotierungen. Eine bessere Implementierung würde prüfen, welche Orientierung die wenigsten Fehler produziert, anstatt nur die Standart-Orientierung zu platzieren.</li>
  <li>Die Farben sind hardgecodet, es wäre schön sie dynamisch aus dem Spiel zu laden, besonders bei durch Mods veränderten Kartenfarben…</li>
</ul>

<p>Trotz dieser Probleme sieht das Ergebnis ganz gut aus, wenn man bedenkt, wie schnell es zusammengeschustert wurde. Das zeigt, das Draftsman flexibel genug ist, um komplexen Anforderungen gerecht zu werden.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
    
      <figure>
        <img src="https://media.alt-f4.blog/ALTF4/61/jay_bauman.jpg" alt="Portrait von Jay" style="max-width: ; max-height:  ">
        
        <figcaption>Jay Bauman, berüchtigter Betrüger, Großkrimineller. Bewaffnet und gefährlich.</figcaption>
      </figure>
      
      
</div>
<p></p>
<p><!-- Spacing --></p>
      <h3 id="wiederauferstehung-des-factorio-movie-players">
        
        
            <a href="#wiederauferstehung-des-factorio-movie-players" class="anchor" style="text-decoration: none;">Wiederauferstehung des Factorio-Movie-Players</a>
          
        
      </h3>
    

<p>Vor einer Weile, auf der Suche nach Beispielen für diesen Artikel, kam ich auf den Klassiker <a href="https://www.youtube.com/watch?v=mgfwwqwxdxY">Factorio Sandstorm</a>. Ein perfektes Projekt für mein Vorhaben; oder hätte es zumindest sein können, wenn ich die Karte im Spiel hätte öffnen können! Die originale Map-Version war mit einem antiken <code class="language-plaintext highlighter-rouge">0.14.20</code> datiert. Zusätzlich dazu wurden über die lange Zeit viele Veränderungen vorgenommen, die der Funktionalität des Skriptes, welche Bilder in Blaupausen umwandelt, im Wege standen. Auch die Karte selber hatte einige Probleme, so dass es nicht gereicht hätte, einfach eine alte Factorio-Version zu öffnen und das Skript anzuwenden. Beispielsweise nannte das <code class="language-plaintext highlighter-rouge">build.lua</code>-Skript, was für das Encoding zuständig ist, <code class="language-plaintext highlighter-rouge">automation-science-pack</code> und <code class="language-plaintext highlighter-rouge">logistic-science-pack</code> noch <code class="language-plaintext highlighter-rouge">science-pack-1</code> und <code class="language-plaintext highlighter-rouge">science-pack-2</code>. Das sollte einen ungefähren Eindruck davon vermitteln können, wie alt diese Karte ist!</p>

<p>Es störte mich, so einen ikonischen Teil der Factorio-Geschichte verfallen zu sehen. Ich nahm mir also die Zeit um die Fehler zu beheben und das ganze auf Version 1.1.57 zu bringen:</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 1200px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/61/cut_and_shrunk.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Video von feel the beat
    </video>
    <figcaption>Gezeigt wird ein Teil von <a href="https://youtu.be/aLZQ-0dHbiU?t=38">Feel the Beat</a>, um die Tradition von Darude-Musikvideos zu erhalten.</figcaption>
  </figure>
</p>

<p>Das Build-Script zu ändern, war problemlos per Hand möglich, aber das <code class="language-plaintext highlighter-rouge">raw-wood</code>-Signal, welches die Maschine intern verwendet hat, gibt es nicht mehr in neueren Factorio-Versionen. Um dies zu beheben, habe ich jedes Vorkommen dieses Signales mit <code class="language-plaintext highlighter-rouge">artillery-wagon</code> ersetzt (da ich sicher sein konnte, das es noch nicht verwendet wurde). Das Updaten der Karte erfolgte in einem Draftsman-Skript. Ich habe auch einige andere Skripte hinzugefügt, um die Bilder aus der Quelle zu extrahieren und Bildschirmfotos zu machen, welche dann automatisch zu einem Video zusammengefügt wurden, was in Python relativ einfach war. Ich habe diese Scripts verwendet, um das oben verlinkte Video zu erstellen.</p>

<p>Ich habe auch mit der Idee rumgespielt, Draftsman zu verwenden um eine Blaupausenbasierte Version den Bau-Skrips zu erstellen, anstatt der originalen Konsolenversion. Das würde dir ganz klar zeigen, welche SPeicherorte du mit einer drübergelegten Blaupause veränderst und würde es simpel machen, den Speicher zu erweitern (der vorhandene Speicher ist nur groß genug für 4800 Frames). Ich fand es wichtiger, das auf den neuesten Stand zu bringen, was bisher da war, insbesondere wenn ich wusste, das der vorhandene Code funktioniert. Die Informationsdichte eines Blaupausenstrings ist möglicherweise auch geringer als die eines Konsolenbefehls, welche so groß sind, das sie bei der Verwendung in Textdateien gespeichert werden. Herauszufinden, ob eine Blaupause für diesen Anwendungsfall geeignet ist, kann warten, bis ich später mal Zeit dafür finde.</p>

<p>Für mehr Informationen darüber, was neu ist, und auch die neue Weltdatei, <a href="https://github.com/redruin1/factorio-movie-maker">verweise ich hier auf meine Fork</a>.</p>
      <h3 id="was-nun">
        
        
            <a href="#was-nun" class="anchor" style="text-decoration: none;">Was nun?</a>
          
        
      </h3>
    

<p>Ich habe bereits einige Dinge mit diesem Modul gemacht, aber mein ursprüngliches Ziel war es ja, das jeder ganz einfach damit etwas machen kann. Einige Ideen, die ich machen wollte, aber bisher noch keine Zeit dazu gefunden habe, habe ich im Folgenden als Anreize/Ideengeber mal zusammengestellt:</p>

<ul>
  <li>
    <p>Viele Kombinator-Computer-Kompiler sind als Skript geschrieben. Vielleicht könnte man ein LLVM-Äquivalent; einen generische Compiler; schaffen, dem man mitteilt, welche Befehle der Computer bearbeiten kann und der daraufhin Code einer etablierten, High-Level-Sprache, beispielsweise C, compiliert. Vielleicht könnte man sogar LLVM selbst nuten?</p>
  </li>
  <li>
    <p>Ausnutzen von Sonderfällen für spezielle Optimierungsprobleme. <a href="https://forums.factorio.com/viewtopic.php?t=57198">Wusstest du, das man jedes Item und nicht nur Module als Angefordert in einer Entität einstellen kann</a>? Du kannst nur Items anfordern, wenn sie errichtet wird, was den Nutzen etwas einschränkt, aber Roboter werden den Auftrag erfüllen. So ist es in einigen Fällen möglich, die Produktion in Gang zu setzten. Mit sowas wie der <a href="https://mods.factorio.com/mod/recursive-blueprints">Recursive-Blueprints-Mod</a> kann man, indem man Montagemaschinen mit Item-Anforderungen platziert und wieder abreißt, wenn sie ihre Items hergestellt haben, eine vollautomatische Fabrik nur mit Baurobotern errichten. Vielleicht kann so die <a href="https://www.youtube.com/watch?v=9dzQge6pe2o">Micro Factory</a> weiter verbessert werden? Ein neues Ziel könnte auch sein, die geringste Entitätenzahl ohne Nutzereingabe zu erreichen, um eine Rakete zu starten.</p>
  </li>
</ul>

<p>Eine vielleicht generellere Anwendung ist <a href="https://factoriobin.com/post/p38zvEAP">diese Blaupause</a>. Ein einzelner GEschützturm, welcher 200 panzerbrechende Munition anfordert, wenn er errichtet wird. Dies ist besonders nützlich in offensiven Aktionen in großen Beißernestern, da du schnell viele Geschütztürme verteilen kannst und sich die Roboter um die Errichtung und Versorgung mit Munition kümmern, damit du dich drauf konzentrieren kannst, dich nicht in der Beißerpampe aufzulösen.</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 800px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/61/preloaded_turret_short.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Darstellung der Geschützturmblaupause in Aktion
    </video>
    <figcaption></figcaption>
  </figure>
</p>

<ul>
  <li>
    <p>Streckenfindungsprobleme. Übergebe eine Menge an Außenpostenpunkten und verwende einen Algorithmus um sie automatisch auf kürzester Strecke/mit dem wenigssten Kreuzungen/etc. zu verbinden. Vielleicht könnte man dies sogar direkt aus den Speicherständen auslesen?</p>
  </li>
  <li>
    <p>Kombinatorschaltungen sind in der Regel sehr Komlex und für den Leien unintuitiv und schwer zu verstehen, wie ich in meiner, in der Einführung beschriebenen, ausgiebigen Probierereien herausgefunden habe. Das liegt an der Dichte der Schaltungen, den versteckten Operationen der einzelnen Kombinatoren und dem unverständlichen Haufen Kabel, der keinen Platz zum durchlaufen oder für Verständnis lässt. Es wäre schön ein Programm zu haben, dem man einen Blaupausenstring übergibt und dem Nutzer dann Labelmöglichkeiten oder ähnliches gibt, damit er eine einfach zu verstehende Dokumentation für komplexe Schaltungen schaffen kann. Ich fände es klasse, soetwas zu verwenden um vektorbasierte Schaltpläne für meinen Computer zu erstellen. Sollte ich ihn jemals fertigstellen.</p>
  </li>
  <li>
    <p>Verwende <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction">Constraint-Satisfaction</a> um Blaupausen zu erstellen. Ich habe damit in der Vergangenheit experimentiert, und es sollte theoretisch möglich sein, vorrausgesetzt man bekommt die Komplexität von <code class="language-plaintext highlighter-rouge">O(MFG)</code> herunter. Falls ich nochmal einen Artikel für Alt-F4 schreibe, wird er vielleicht darüber sein.</p>
  </li>
  <li>
    <p>Man kann auch neuronale Netze für dieses Ziel verwenden, es ist schließlich Python!Ich frage mich, ob man damit tatsächlich verwendbare Blaupausen erhalten kann. Vielleicht könnte man es mit den gesamten Daten aus <a href="https://www.factorio.school/">factorio.school</a> trainieren…</p>
  </li>
</ul>

<p>Hoffentlich hat dies den kreativen unter euch einige Ideen geliefert. Und vielleicht, aber nur <em>vielleicht</em>, kann jemand, der sich mit einem Skript etwas Zeit sparen möchte, etwas Zeit sparen, anstatt drei bis vier Monate darauf zu verwenden, dafür ein Python-Modul zu schreiben.</p>

<p>Es hat zumindest etwas Spaß gemacht. Und man hat ein oder zwei Dinge gelernt.</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 1276px; max-height: " playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/61/it_works.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Es funktioniert!
    </video>
    <figcaption>Gott sei Dank.</figcaption>
  </figure>
</p>

<p>Nun, endlich zurück an die <em>Arbeit</em>.</p>
      <h2 id="beitragen">
        
        
            <a href="#beitragen" class="anchor" style="text-decoration: none;">Beitragen</a>
          
        
      </h2>
    

<p>Wie immer suchen wir nach Leuten, die zu Alt-F4 beitragen wollen, sei es mit einem Artikel oder durch Hilfe bei Übersetzungen. Wenn du etwas Interessantes im Kopf hast, das du mit der Community in einer eleganten Art teilen möchtest, hier kannst du das tun. Falls du dir unsicher bist, beantworten wir gerne Fragen zu Inhalt und Struktur. Falls das nach  etwas klingt, woran du interessiert bist, tritt unserem <a href="https://discord.gg/nxnCFkb">Discord</a> bei, um es nicht zu verpassen!</p>





<script>
  (() => {
    if (window.innerWidth >= 720) {
      document.getElementsByClassName('toc')[0].setAttribute('open', '')
    }
  })()

  var slideIndex = 1;
  showSlides(slideIndex);

  function plusSlides(n) {
    showSlides(slideIndex += n);
  }

  function currentSlide(n) {
    showSlides(slideIndex = n);
  }

  function showSlides(n) {
    var i;
    var slides = document.getElementsByClassName("galleryItem");
    var dots = document.getElementsByClassName("galleryPreview");
    var captionText = document.getElementById("caption");
    if (n > slides.length) { slideIndex = 1 }
    if (n < 1) { slideIndex = slides.length }
    for (i = 0; i < slides.length; i++) {
      slides[i].style.display = "none";
    }
    for (i = 0; i < dots.length; i++) {
      dots[i].className = dots[i].className.replace(" active", "");
    }
    slides[slideIndex - 1].style.display = "block";
    dots[slideIndex - 1].className += " active";
    captionText.innerHTML = dots[slideIndex - 1].alt;
  }
</script>

		
<div class="flex flex-column flex-items-center mt8">
  
  <a class="button-green-right m4" style="width: 16em;" href="https://forums.factorio.com/viewtopic.php?f=5&t=102518">
    Im Factorio-Forum diskutieren
  </a>
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://www.reddit.com/r/factorio/comments/uyypgw/altf4_61_draftsman_a_python_module_for_creating/">
    Auf Reddit diskutieren
  </a>
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://alt-f4.blog/de/discord">
    Auf Discord diskutieren
  </a>
  
</div>


	</div>
	<div class="panel-inset mb0 p4 flex">
		<div>
		<!-- Previous Button -->
		
		<a href="/de/ALTF4-60/" class="button square-sm"><i class="fas fa-angle-double-left"></i></a>
		
		<a class="button square-sm" href="/de/">
			<i class="fas fa-home"></i>
		</a>

		<!-- Next Button -->
		
		<a class="button square-sm  disabled">
			<i class="fas fa-angle-double-right"></i>
		</a>
		
		</div>
	</div>
</article>

      </div>
    </div>


    <!-- Footer -->
    <footer class="footer">
  <div class="footer-inner panel">

    <div class="footer-links panel-inset slots p1 mt0 mb0">
      <a href="/de/about" class="slot" title="About">
        <div class="slot-button">
          <i class="fas fa-info"></i>
        </div>
      </a>
      <a href="https://github.com/AlternativeFFFF/Alt-F4" class="slot" title="Github">
        <div class="slot-button">
          <i class="fab fa-github"></i>
        </div>
      </a>
      <a href="https://alt-f4.blog/de/discord" class="slot" title="Discord">
        <div class="slot-button">
          <i class="fab fa-discord"></i>
        </div>
      </a>
      <a href="/de/atom.xml" type="application/atom+xml" rel="alternate" class="slot" title="ATOM Feed">
        <div class="slot-button">
          <i class="fas fa-rss"></i>
        </div>
      </a>
      <a href="https://www.freelists.org/list/alt-f4" class="slot" title="Email Newsletter">
        <div class="slot-button">
          <i class="fas fa-envelope"></i>
        </div>
      </a>

      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
    </div>
    <div class="footer-rocket panel-inset m0">
      <div class="spidertron-center">
        <div id="spidertron" class="spidertron-home" data-spidertron-scale="0.6" data-spidertron-speed="400"></div>
      </div>
      <div class="shadow-overlay"></div>
      <div class="shadow-overlay-bottom"></div>
    </div>
    <div class="footer-copyright panel-inset m0">
      Diese Webseite ist ein Fan-Projekt und steht nicht in direkter Verbindung zu Wube Software
    </div>
  </div>
</footer>

  </body>

</html>
