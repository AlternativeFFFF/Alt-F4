<!DOCTYPE html>
<html lang="fr" class="fr">
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-177230094-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'UA-177230094-1');
</script>


	<title>Alt-F4 #15 - Exploration de la version 1.1</title>
	<!-- Meta -->
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="generator" content="Jekyll">

	<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Alt-F4 #15 - Exploration de la version 1.1 | Alternative Friday Factorio Fan Facts</title>
<meta name="generator" content="Jekyll v4.1.1">
<meta property="og:title" content="Alt-F4 #15 - Exploration de la version 1.1">
<meta name="author" content="Conor_, Therenas">
<meta property="og:locale" content="fr">
<meta name="description" content="Cette semaine, alors que la version expérimentale 1.1 vient de sortir, nous nous penchons sur deux des éléments qu’elle introduit. Tout d’abord, Conor_ étudie ce que la nouvelle limite d’arrêt de trains lui permet de faire dans son usine utilisant le mod TSM. Ensuite, Therenas explore ce que signifie la mise à jour des convoyeurs en multithread, à la fois en théorie et en pratique. Attention, vous pourriez bien apprendre quelque chose ! Limites d’arrêt de train Conor_ Quand il a été proposé de parler des changements qu’apporte la version 1.1, il fallait évidement que je parle de la nouvelle fonction de limitation de l’arrêt de trains, car j’adore les trains ! Dans ce qui suit, j’examine quel problème cette fonctionnalité résout, et comment je le traitais auparavant. Une simple erreur d’un Conor_ plus jeune et plus naïf Il y a quelque temps, je construisais l’une de mes premières grandes bases pour essayer de vaincre le mod SpaceX en multipliant par 5 les coûts des recherches (parce que Pourquoi pas ?) lorsque j’ai remarqué des problèmes dans mon réseau de trains spaghetti™. En raison de l’ignorance de ma jeunesse, j’avais décidé que les arrêts pour un matériau donné devaient avoir le même nom, en déployant un grand nombre de trains pour circuler entre ces arrêts afin de s’assurer qu’ils soient tous utilisés. Ce n’était pas une bonne idée. Ce système simple à mettre en œuvre a entraîné des douleurs et des souffrances, comme je n’en avais plus connues depuis mes tentatives de comprendre le traitement du pétrole. Cela avait bien fonctionné pour moi sur de petites bases avec seulement quelques arrêts répartis sur une courte distance, mais à grande échelle, les trains n’allaient tout simplement pas vers les avant-postes plus éloignés. Certains arrêts étaient bloqués et provoquaient des embouteillages, tandis que d’autres étaient déserts. J’ai décidé qu’il devait y avoir une meilleure solution, et comme le bon ingénieur que je suis, j’ai travaillé dur pour rechercher et développer une meilleure solution au problème demandé à Reddit. Quelqu’un connaît-il un mode de transport qui répartit équitablement les trains entre les arrêts de même nom, quelle que soit la différence de distance. Par exemple, tous les arrêts de déchargement du fer sont appelés de la même façon, mais un nombre égal de trains se rendent à chacun des différents arrêts. Does anyone knows of a mod that will equally distribute trains between stops of the same name, irrelevant of the distance difference. E.g. All iron unload stops called one thing but an equal number of trains go to each of the different stops. — Conor_ (Août 2019) Quel beau rêve de puissance j’ai eu là. Au lieu de ce que je demandais, on m’a dirigé à juste titre vers TSM et LTN, puis on m’a dit de poursuivre ma route. Mais avec la version 1.1, les développeurs ont crié depuis les hauteurs, “Nous avons une nouvelle fonctionnalité pour le train !” OK développeurs, je vous écoute… Que sont les limites d’arrêt de train ? La limite d’arrêt de trains, telle que décrite dans le FFF-361, vous permet de régler le nombre de trains à un arrêt donné. Les détails techniques de ce système sont beaucoup plus détaillés dans le FFF (qui vaut certainement la peine d’être lu), mais en résumé, un train ne devrait se rendre à un arrêt que s’il y a de la place pour le recevoir, ce qui est exactement ce que voulait le jeune Conor_. Mais est-ce que cela tient la route par rapport à mon nouvel amour, TSM ? Origine : FFF-361 Qu’est-ce que TSM et pourquoi devrais-je m’en inquiéter ? Train Supply Manager (TSM) est un mod qui permet aux arrêts de trains de demander un train lorsque certaines conditions logiques sont remplies. Un exemple pertinent pour une telle condition serait de demander un train lorsque moins d’un certain nombre de trains sont en route vers l’arrêt. Il vous permet également de faire de la magie logique plus complexe, par exemple en ne demandant un train que lorsqu’il y a assez de matériau pour le remplir réellement, bien que je n’aie jamais utilisé cette fonctionnalité. Le rêve de TSM est de mettre pleinement en œuvre un système logistique basé sur la demande plutôt que sur l’offre, comme c’est le cas pour des configurations plus élémentaires. La stratégie habituelle de l’offre est celle que l’on retrouve dans de nombreuses petites usines où les trains sont remplis à l’avant-poste, puis évacués, pour patienter à la destination. Avec un système de demande, les trains sont toujours prêts à livrer ou à être chargés, et ne sont appelés que lorsque des ressources sont nécessaires. La différence réside dans le choix du moment où les trains sont mis en marche ; dans le cas d’un système basé sur l’offre, le moment est fixé par la vitesse à laquelle les arrêts peuvent remplir les trains et les mettre en route, indépendamment du nombre de ressources dont l’usine a besoin. En passant à un système basé sur la demande, le moment est déterminé par les arrêts de destination, ce qui leur permet de ne demander des trains que lorsqu’ils sont réellement nécessaires. Cela vous permet de réduire massivement le nombre de trains en mouvement sur un réseau donné et de contrôler où les trains attendent pour s’assurer qu’ils ne provoquent pas de congestion. Bien que cela soit également possible avec le jeu de base en utilisant de grandes zones d’attente pour les trains, en planifiant soigneusement où les trains en attente doivent s’arrêter, ce n’est pas très idéal ni pratique. Dans ce système, les trains sont attendus à la fois aux arrêts de récupération et de livraison, ce qui est particulièrement important pour les grandes bases et c’est la raison pour laquelle j’aime tant TSM. &lt;/source&gt; Vidéo de TSM en fonctionnement Dans la vidéo, les arrêts de chargement et de déchargement n’ont jamais eu qu’un seul train arrêté, ce qui permet d’éviter les encombrements. Lorsqu’un arrêt est vide, un train est envoyé du dépôt par TSM pour réapprovisionner l’arrêt qui en a un besoin le plus urgent. Les limites d’arrêt de trains peuvent-elles remplacer TSM ? Pour comprendre quand il faudra utiliser TSM plutôt que la nouvelle fonction de limitation des arrêts de train, j’ai recréé la fonctionnalité de TSM dans le jeu normal en 1.1, sans TSM, avec beaucoup de succès ! &lt;/source&gt; Vidéo de la même installation utilisant les limites d’arrêt de trains Cette vidéo montre la même configuration de trains de cuivre en train de charger et de décharger, toujours avec un seul train aux arrêts de chargement et de déchargement, tandis que les autres attendent au dépôt. La raison pour laquelle ce système fonctionne à merveille et remplace si bien TSM, c’est que les trains attendent à l’arrêt du dépôt jusqu’à ce qu’il y ait de la place dans la gare de chargement ou de déchargement. Si les trains devaient attendre au point de chargement, cela provoquerait des encombrements et limiterait le débit du producteur. L’utilisation des arrêts de dépôt permet aux trains de disposer d’une sorte de “zone d’attente” à l’écart du reste du réseau ferroviaire, le temps qu’ils deviennent à nouveau nécessaires. Comme nous pouvons le voir, l’ensemble de ce système peut être recréé avec la nouvelle fonction du jeu, probablement avec de meilleures performances en raison de son intégration directe au jeu. Cela ne tient même pas compte de la plus grande simplicité de la limite d’arrêt de trains par rapport à la compréhension de TSM, qui a une courbe d’apprentissage assez raide et une documentation qui est loin d’être parfaite. TSM peut encore être utile dans certains cas, par exemple lorsque le joueur souhaite obtenir des informations sur les demandes actuellement non satisfaites que TSM fournit via son interface, bien que personnellement je n’utilise que rarement ces fonctionnalités. Conclusion Il arrive souvent que les développeurs de jeux avec possibilité de mods remarquent une fonctionnalité intéressante et l’implémentent dans le jeu de base. Cela peut être un peu douloureux pour les créateurs de mods car cela rend leur mod pour la plupart obsolète, mais au final, ils ont réussi à améliorer le jeu. Leur mod est maintenant indirectement intégré dans le jeu qu’ils aiment, ce qui signifie que plus de gens peuvent l’utiliser, ce qui est formidable. Je remercie tout particulièrement sorahn du serveur Discord de Factorio d’avoir repéré mes questions et d’avoir fait tout son possible pour m’aider, en réalisant la carte que j’ai modifiée ci-dessus pour illustrer comment TSM peut fonctionner dans la configuration “double requête”, ainsi que pour avoir vérifié l’équilibre mental de mes idées avant que je ne les construise. Cette fonction sera étonnante pour les nouveaux joueurs (comme le Conor_ jeune et naïf) qui pourront ainsi construire plus facilement des réseaux de trains plus vastes et plus élaborés. Elle offre une autre fonction facile à apprendre et difficile à maîtriser, que les joueurs expérimentés pourront utiliser et explorer, tout en aidant les débutants à s’amuser. Améliorations des performances avec la version 1.1 Therenas La dernière version expérimentale de Factorio a apporté de nombreux changements, dont un que je souhaite examiner de plus près aujourd’hui. Il se cache discrètement dans le journal des modifications de la version 1.1.0 et n’a été mentionné dans aucune des éditions des FFF précédant la sortie. Ce n’est que quelques mots : Mise à jour de la logique des convoyeurs en multithread. Je suis ici pour découvrir ce que cela signifie et quel est son impact réel. Comment cette optimisation fonctionne-t-elle sur le plan technique ? Maintenant, vous n’avez peut-être pas la moindre idée de ce que signifie la logique des jeux en multithread. Pourquoi ne pas simplement tout mettre en œuvre en multithread, afin que le jeu puisse tirer parti de tous les processeurs de votre PC ? Eh bien, il s’avère que ce n’est pas si simple. En général, le jeu doit mettre à jour toutes les machines, convoyeurs, tuyaux, etc. à chaque tick. C’est ainsi que le temps progresse réellement dans le jeu, ce qui vous permet de jouer, en premier lieu. L’ordre dans lequel cela se produit est important. D’abord, les convoyeurs déplacent les objets dans la direction du convoyeur, puis un bras en prend un et le met dans une machine, puis cette machine l’utilise pour fabriquer quelque chose. Le problème fondamental que pose le multithread est qu’il ne permet pas de garantir l’ordre dans lequel les choses se déroulent. Dans l’exemple précédent, il se peut que la machine essaie de fabriquer quelque chose avant que le bras n’insère l’objet. Dans ce cas, la machine n’aurait pas pu fonctionner car il lui manquait l’ingrédient. Si l’insertion se faisait en premier, la machine pourrait alors travailler. C’est un problème parce que ce n’est pas déterministe. En fonction de la logique du traitement informatique, la machine peut fabriquer un objet ou non, ce qui brise la simulation. Cet exemple n’est bien sûr qu’une illustration du problème. Les problèmes réels qui apparaissent sont plus compliqués et de nature technique. De plus, les actions que j’ai utilisées comme exemples ne se produisent naturellement pas toutes en un tick pour une machine spécifique ; elles sont une analogie pour illustrer le problème en question. Elles ne correspondent pas nécessairement à la façon dont le jeu organise réellement les choses. Donc, à première vue, il semble qu’on ne puisse pas faire du multithread dans un jeu comme Factorio parce que cela briserait la simulation. Tout dépend de tout, n’est-ce pas ? Eh bien, pas tout à fait. En effet, il y aura toujours des étapes qui devront être exécutées de manière strictement linéaire, mais vous pouvez trouver des parties de l’ensemble qui sont vraiment indépendantes les unes des autres si vous y regardez de plus près. La logique du convoyeur en est une. Quand on y pense, chaque convoyeur n’est pas lié à tous les autres sur la carte. Bien sûr, il y a des réseaux de convoyeurs géants qui sont interconnectés, comme dans un bus principal, mais il y a aussi des lignes de convoyeurs qui ne sont pas du tout reliées entre elles. En fait, il y en a beaucoup, car les trains ou les réseaux de machines ont tendance à briser les lignes de convoyeurs. Dans cette capture d’écran, les convoyeurs bleu et rouge font partie de lignes de convoyeurs distinctes. Remarquez comment elles se faufilent les unes dans les autres, sans jamais vraiment interagir. Remarquez également comment la machine leur permet d’interagir indirectement tout en préservant leur séparation à des fins de multithread. Cela nous permet de paralléliser (c’est-à-dire travailler en multithread) la logique de mise à jour des convoyeurs. Nous devons maintenant être prudents ; cela ne signifie pas que nous pouvons simplement mettre à jour les convoyeurs à n’importe quel moment pendant le tick. Il faut encore passer par les étapes consistant à déplacer les objets, à laisser le bras les ramasser, à faire fabriquer un objet par la machine, et ce dans cet ordre. La chose que nous pouvons faire est de séparer le déplacement des objets. Lorsque nous arrivons à ce point, nous répartissons la tâche de manière à ce que chaque ligne de convoyeurs isolée ait son propre processus. Chaque processus déplace ensuite les objets sur la ligne de convoyeurs qui lui a été attribuée, de sorte qu’ils se déplacent tous en même temps, c’est-à-dire qu’ils sont traités en parallèle. Si nous prenons soin de ne séparer que les lignes de convoyeurs qui n’interagissent pas avec d’autres, nous pouvons les mettre à jour en toute sécurité de manière autonome. Cette illustration montre comment on gagne en performance. Au lieu de devoir attendre le temps de mise à jour total de toutes les lignes de convoyeurs, le jeu n’a plus qu’à attendre celle qui prend le plus de temps (la n°2 dans ce cas). Cela peut conduire à de grandes améliorations, car en réalité il y a bien plus que trois lignes de convoyeurs séparées. Cette approche est très similaire à la façon dont la logique de mise à jour des fluides a été améliorée, comme indiqué dans le FFF n°271. Cet article du blog donne un aperçu de la manière dont la disposition de la mémoire a été modifiée pour améliorer l’efficacité de la cache, mais ce n’est pas le sujet de cet article. Il y a aussi un fil de discussion Reddit très intéressant de Varen/Raven qui parle de la refonte de Factorio en ayant la logique en multithread à l’esprit dès le départ. Lisez-le pour obtenir des informations techniques supplémentaires sur ce sujet. Au travail maintenant : quelle est la différence en pratique ? Toute cette théorie est bien belle, mais vous vous demandez quel est l’impact réel sur les performances. Eh bien inutile de vous poser ces questions, j’ai apporté des graphiques ! À titre d’avertissement, ces mesures ont été effectuées sur les versions 1.0.0 et 1.1.1 respectivement. J’ai utilisé la console de jeu pour augmenter la vitesse du jeu, ce qui m’a permis d’obtenir un UPS de plus de 60. Les chiffres n’ont pas été mesurés avec des méthodes très rigoureuses, ce qui signifie qu’ils ont une marge d’erreur non négligeable. Il faut également tenir compte du fait que les performances de mise à jour de l’entité ont également été augmentées selon les notes de correctifs. Ceci est également inclus, bien que je ne pense pas que mes mesures soient suffisamment précises pour tirer des conclusions définitives. J’ai comparé trois sauvegardes différentes avec des caractéristiques différentes, bien qu’elles utilisent toutes beaucoup de convoyeurs. On ne peut pas améliorer les performances de celles qui n’existent pas, après tout. Rencontrons nos concurrents, qui sont tous issus de l’étonnant site web FactorioBox qui propose une petite collection de cartes utiles pour la comparaison des performances. Tout d’abord, j’ai testé la base à 10 000 SPM de Stevetrov. Elle utilise des configurations vraiment optimisées en termes de performances, reposant presque entièrement sur des convoyeurs. Aucun train n’est en service, les robots n’étant utilisés que dans des circonstances très spécifiques où ils s’avèrent plus performants que les convoyeurs. Cela en fait un candidat idéal pour montrer l’impact que ce changement peut avoir. L’effet ne sera pas aussi prononcé dans d’autres cas, car les coûts de performance sont davantage répartis sur d’autres éléments comme les trains ou les robots. Comme le montrent ces graphiques, pour notre premier exemple, quelque peu idéalisé, l’amélioration du temps de mise à jour du convoyeur est assez importante puisque nous constatons une amélioration d’environ 150 % ! Sur cette carte, l’amélioration des UPS est d’environ 26 %, ce qui est considérable si l’on considère que seul le code relatif aux convoyeurs a changé. Il est intéressant de noter que le temps de mise à jour des entités a légèrement augmenté, mais cela reste dans la marge d’erreur de notre mesure, et nous ne pouvons donc pas en tirer de conclusions. Ensuite, j’ai testé une base dont la disposition est plus proche de ce que vous ou moi pourrions construire. Elle s’appelle simplement cam6 sans aucune indication quant à son origine. Elle repose principalement sur des convoyeurs, avec quelques trains et robots en plus. Elle produit également de l’électricité à l’aide de réacteurs nucléaires, qui ont tendance à couper une part non négligeable du gâteau des performances. Comme je l’ai dit, elle a tout ce que l’on peut attendre d’une carte habituelle de Factorio, ce qui en fait une bonne représentation de l’impact que vous pouvez attendre sur votre usine. En examinant ces graphiques pour notre carte plus traditionnelle, nous constatons une amélioration des temps de mise à jour des convoyeurs d’environ 100 %, ce qui est un peu moins que sur la mégabase à 10 000 SPM, mais reste une amélioration considérable. L’UPS augmente d’environ 16 %. Là encore, la modification des temps de mise à jour des entités se situe dans la marge d’erreur. Enfin, j’ai jeté un coup d’œil sur un candidat quelque peu inhabituel : une gigantesque carte désordonnée intitulée Besenovsky Pajzel, qui est probablement le nom de son créateur. Elle est décrite comme une “énorme carte (13300x7400 tuiles) avec une production inefficace allant de 2400 à 4000 SPM”. Cette carte utilise donc un mélange de tous ces éléments, la différence la plus significative avec les deux précédentes étant l’utilisation intensive des trains. Ce que nous en attendons, c’est que l’impact des optimisations de la version 1.1 soit moins important, car ce qui a été amélioré est moins pertinent sur cette carte. L’étude de ce dernier ensemble de graphiques pour notre sauvegarde plus désordonnée montre une augmentation des performances des temps de mise à jour des convoyeurs encore plus importante que celle de la mégabase, soit environ 170 %. Cela conduit à une amélioration de 37 % des UPS, qui semble être favorisée par les mises à jour des performances des entités, qui représentent en fait une différence de 38 % sur cette carte. Si nous faisons la moyenne de ces trois critères très approximatifs, nous obtenons une amélioration moyenne de 140 % des performances des convoyeurs, avec une augmentation moyenne de 26 % pour les UPS. Cela n’est pas représentatif de la moyenne de toutes les sauvegardes possibles en utilisation, bien sûr, car nous n’avons pris en compte que ces trois cartes spéciales. Dans l’ensemble, l’amélioration avec la version 1.1 dépend quelque peu de la configuration de votre base, mais c’est une belle amélioration générale. Après tout, peu importe qu’une amélioration particulière des performances ait un effet important ; c’est la somme de toutes les petites améliorations qui font que le jeu tourne plus vite d’un ordre de grandeur. Nous avons étudié cet effet il y a quelques semaines dans le Alt-F4 n°13, et je m’attends à ce que cette base obtienne une amélioration supplémentaire des performances. Contribuer Comme toujours, nous attendons vos contributions pour les Alt-F4, que cela soit par la soumission d’un article ou en aidant pour les traductions. Si vous avez quelque chose d’intéressant en tête que vous souhaitez partager avec la communauté, vous êtes au bon endroit. Si vous n’êtes pas sûr, nous serons heureux de vous aider en discutant structure, contenu et idées. Donc si vous voulez vous impliquer dans les Alt-F4, rejoignez-le Discord pour ne rien rater !">
<meta property="og:description" content="Cette semaine, alors que la version expérimentale 1.1 vient de sortir, nous nous penchons sur deux des éléments qu’elle introduit. Tout d’abord, Conor_ étudie ce que la nouvelle limite d’arrêt de trains lui permet de faire dans son usine utilisant le mod TSM. Ensuite, Therenas explore ce que signifie la mise à jour des convoyeurs en multithread, à la fois en théorie et en pratique. Attention, vous pourriez bien apprendre quelque chose ! Limites d’arrêt de train Conor_ Quand il a été proposé de parler des changements qu’apporte la version 1.1, il fallait évidement que je parle de la nouvelle fonction de limitation de l’arrêt de trains, car j’adore les trains ! Dans ce qui suit, j’examine quel problème cette fonctionnalité résout, et comment je le traitais auparavant. Une simple erreur d’un Conor_ plus jeune et plus naïf Il y a quelque temps, je construisais l’une de mes premières grandes bases pour essayer de vaincre le mod SpaceX en multipliant par 5 les coûts des recherches (parce que Pourquoi pas ?) lorsque j’ai remarqué des problèmes dans mon réseau de trains spaghetti™. En raison de l’ignorance de ma jeunesse, j’avais décidé que les arrêts pour un matériau donné devaient avoir le même nom, en déployant un grand nombre de trains pour circuler entre ces arrêts afin de s’assurer qu’ils soient tous utilisés. Ce n’était pas une bonne idée. Ce système simple à mettre en œuvre a entraîné des douleurs et des souffrances, comme je n’en avais plus connues depuis mes tentatives de comprendre le traitement du pétrole. Cela avait bien fonctionné pour moi sur de petites bases avec seulement quelques arrêts répartis sur une courte distance, mais à grande échelle, les trains n’allaient tout simplement pas vers les avant-postes plus éloignés. Certains arrêts étaient bloqués et provoquaient des embouteillages, tandis que d’autres étaient déserts. J’ai décidé qu’il devait y avoir une meilleure solution, et comme le bon ingénieur que je suis, j’ai travaillé dur pour rechercher et développer une meilleure solution au problème demandé à Reddit. Quelqu’un connaît-il un mode de transport qui répartit équitablement les trains entre les arrêts de même nom, quelle que soit la différence de distance. Par exemple, tous les arrêts de déchargement du fer sont appelés de la même façon, mais un nombre égal de trains se rendent à chacun des différents arrêts. Does anyone knows of a mod that will equally distribute trains between stops of the same name, irrelevant of the distance difference. E.g. All iron unload stops called one thing but an equal number of trains go to each of the different stops. — Conor_ (Août 2019) Quel beau rêve de puissance j’ai eu là. Au lieu de ce que je demandais, on m’a dirigé à juste titre vers TSM et LTN, puis on m’a dit de poursuivre ma route. Mais avec la version 1.1, les développeurs ont crié depuis les hauteurs, “Nous avons une nouvelle fonctionnalité pour le train !” OK développeurs, je vous écoute… Que sont les limites d’arrêt de train ? La limite d’arrêt de trains, telle que décrite dans le FFF-361, vous permet de régler le nombre de trains à un arrêt donné. Les détails techniques de ce système sont beaucoup plus détaillés dans le FFF (qui vaut certainement la peine d’être lu), mais en résumé, un train ne devrait se rendre à un arrêt que s’il y a de la place pour le recevoir, ce qui est exactement ce que voulait le jeune Conor_. Mais est-ce que cela tient la route par rapport à mon nouvel amour, TSM ? Origine : FFF-361 Qu’est-ce que TSM et pourquoi devrais-je m’en inquiéter ? Train Supply Manager (TSM) est un mod qui permet aux arrêts de trains de demander un train lorsque certaines conditions logiques sont remplies. Un exemple pertinent pour une telle condition serait de demander un train lorsque moins d’un certain nombre de trains sont en route vers l’arrêt. Il vous permet également de faire de la magie logique plus complexe, par exemple en ne demandant un train que lorsqu’il y a assez de matériau pour le remplir réellement, bien que je n’aie jamais utilisé cette fonctionnalité. Le rêve de TSM est de mettre pleinement en œuvre un système logistique basé sur la demande plutôt que sur l’offre, comme c’est le cas pour des configurations plus élémentaires. La stratégie habituelle de l’offre est celle que l’on retrouve dans de nombreuses petites usines où les trains sont remplis à l’avant-poste, puis évacués, pour patienter à la destination. Avec un système de demande, les trains sont toujours prêts à livrer ou à être chargés, et ne sont appelés que lorsque des ressources sont nécessaires. La différence réside dans le choix du moment où les trains sont mis en marche ; dans le cas d’un système basé sur l’offre, le moment est fixé par la vitesse à laquelle les arrêts peuvent remplir les trains et les mettre en route, indépendamment du nombre de ressources dont l’usine a besoin. En passant à un système basé sur la demande, le moment est déterminé par les arrêts de destination, ce qui leur permet de ne demander des trains que lorsqu’ils sont réellement nécessaires. Cela vous permet de réduire massivement le nombre de trains en mouvement sur un réseau donné et de contrôler où les trains attendent pour s’assurer qu’ils ne provoquent pas de congestion. Bien que cela soit également possible avec le jeu de base en utilisant de grandes zones d’attente pour les trains, en planifiant soigneusement où les trains en attente doivent s’arrêter, ce n’est pas très idéal ni pratique. Dans ce système, les trains sont attendus à la fois aux arrêts de récupération et de livraison, ce qui est particulièrement important pour les grandes bases et c’est la raison pour laquelle j’aime tant TSM. &lt;/source&gt; Vidéo de TSM en fonctionnement Dans la vidéo, les arrêts de chargement et de déchargement n’ont jamais eu qu’un seul train arrêté, ce qui permet d’éviter les encombrements. Lorsqu’un arrêt est vide, un train est envoyé du dépôt par TSM pour réapprovisionner l’arrêt qui en a un besoin le plus urgent. Les limites d’arrêt de trains peuvent-elles remplacer TSM ? Pour comprendre quand il faudra utiliser TSM plutôt que la nouvelle fonction de limitation des arrêts de train, j’ai recréé la fonctionnalité de TSM dans le jeu normal en 1.1, sans TSM, avec beaucoup de succès ! &lt;/source&gt; Vidéo de la même installation utilisant les limites d’arrêt de trains Cette vidéo montre la même configuration de trains de cuivre en train de charger et de décharger, toujours avec un seul train aux arrêts de chargement et de déchargement, tandis que les autres attendent au dépôt. La raison pour laquelle ce système fonctionne à merveille et remplace si bien TSM, c’est que les trains attendent à l’arrêt du dépôt jusqu’à ce qu’il y ait de la place dans la gare de chargement ou de déchargement. Si les trains devaient attendre au point de chargement, cela provoquerait des encombrements et limiterait le débit du producteur. L’utilisation des arrêts de dépôt permet aux trains de disposer d’une sorte de “zone d’attente” à l’écart du reste du réseau ferroviaire, le temps qu’ils deviennent à nouveau nécessaires. Comme nous pouvons le voir, l’ensemble de ce système peut être recréé avec la nouvelle fonction du jeu, probablement avec de meilleures performances en raison de son intégration directe au jeu. Cela ne tient même pas compte de la plus grande simplicité de la limite d’arrêt de trains par rapport à la compréhension de TSM, qui a une courbe d’apprentissage assez raide et une documentation qui est loin d’être parfaite. TSM peut encore être utile dans certains cas, par exemple lorsque le joueur souhaite obtenir des informations sur les demandes actuellement non satisfaites que TSM fournit via son interface, bien que personnellement je n’utilise que rarement ces fonctionnalités. Conclusion Il arrive souvent que les développeurs de jeux avec possibilité de mods remarquent une fonctionnalité intéressante et l’implémentent dans le jeu de base. Cela peut être un peu douloureux pour les créateurs de mods car cela rend leur mod pour la plupart obsolète, mais au final, ils ont réussi à améliorer le jeu. Leur mod est maintenant indirectement intégré dans le jeu qu’ils aiment, ce qui signifie que plus de gens peuvent l’utiliser, ce qui est formidable. Je remercie tout particulièrement sorahn du serveur Discord de Factorio d’avoir repéré mes questions et d’avoir fait tout son possible pour m’aider, en réalisant la carte que j’ai modifiée ci-dessus pour illustrer comment TSM peut fonctionner dans la configuration “double requête”, ainsi que pour avoir vérifié l’équilibre mental de mes idées avant que je ne les construise. Cette fonction sera étonnante pour les nouveaux joueurs (comme le Conor_ jeune et naïf) qui pourront ainsi construire plus facilement des réseaux de trains plus vastes et plus élaborés. Elle offre une autre fonction facile à apprendre et difficile à maîtriser, que les joueurs expérimentés pourront utiliser et explorer, tout en aidant les débutants à s’amuser. Améliorations des performances avec la version 1.1 Therenas La dernière version expérimentale de Factorio a apporté de nombreux changements, dont un que je souhaite examiner de plus près aujourd’hui. Il se cache discrètement dans le journal des modifications de la version 1.1.0 et n’a été mentionné dans aucune des éditions des FFF précédant la sortie. Ce n’est que quelques mots : Mise à jour de la logique des convoyeurs en multithread. Je suis ici pour découvrir ce que cela signifie et quel est son impact réel. Comment cette optimisation fonctionne-t-elle sur le plan technique ? Maintenant, vous n’avez peut-être pas la moindre idée de ce que signifie la logique des jeux en multithread. Pourquoi ne pas simplement tout mettre en œuvre en multithread, afin que le jeu puisse tirer parti de tous les processeurs de votre PC ? Eh bien, il s’avère que ce n’est pas si simple. En général, le jeu doit mettre à jour toutes les machines, convoyeurs, tuyaux, etc. à chaque tick. C’est ainsi que le temps progresse réellement dans le jeu, ce qui vous permet de jouer, en premier lieu. L’ordre dans lequel cela se produit est important. D’abord, les convoyeurs déplacent les objets dans la direction du convoyeur, puis un bras en prend un et le met dans une machine, puis cette machine l’utilise pour fabriquer quelque chose. Le problème fondamental que pose le multithread est qu’il ne permet pas de garantir l’ordre dans lequel les choses se déroulent. Dans l’exemple précédent, il se peut que la machine essaie de fabriquer quelque chose avant que le bras n’insère l’objet. Dans ce cas, la machine n’aurait pas pu fonctionner car il lui manquait l’ingrédient. Si l’insertion se faisait en premier, la machine pourrait alors travailler. C’est un problème parce que ce n’est pas déterministe. En fonction de la logique du traitement informatique, la machine peut fabriquer un objet ou non, ce qui brise la simulation. Cet exemple n’est bien sûr qu’une illustration du problème. Les problèmes réels qui apparaissent sont plus compliqués et de nature technique. De plus, les actions que j’ai utilisées comme exemples ne se produisent naturellement pas toutes en un tick pour une machine spécifique ; elles sont une analogie pour illustrer le problème en question. Elles ne correspondent pas nécessairement à la façon dont le jeu organise réellement les choses. Donc, à première vue, il semble qu’on ne puisse pas faire du multithread dans un jeu comme Factorio parce que cela briserait la simulation. Tout dépend de tout, n’est-ce pas ? Eh bien, pas tout à fait. En effet, il y aura toujours des étapes qui devront être exécutées de manière strictement linéaire, mais vous pouvez trouver des parties de l’ensemble qui sont vraiment indépendantes les unes des autres si vous y regardez de plus près. La logique du convoyeur en est une. Quand on y pense, chaque convoyeur n’est pas lié à tous les autres sur la carte. Bien sûr, il y a des réseaux de convoyeurs géants qui sont interconnectés, comme dans un bus principal, mais il y a aussi des lignes de convoyeurs qui ne sont pas du tout reliées entre elles. En fait, il y en a beaucoup, car les trains ou les réseaux de machines ont tendance à briser les lignes de convoyeurs. Dans cette capture d’écran, les convoyeurs bleu et rouge font partie de lignes de convoyeurs distinctes. Remarquez comment elles se faufilent les unes dans les autres, sans jamais vraiment interagir. Remarquez également comment la machine leur permet d’interagir indirectement tout en préservant leur séparation à des fins de multithread. Cela nous permet de paralléliser (c’est-à-dire travailler en multithread) la logique de mise à jour des convoyeurs. Nous devons maintenant être prudents ; cela ne signifie pas que nous pouvons simplement mettre à jour les convoyeurs à n’importe quel moment pendant le tick. Il faut encore passer par les étapes consistant à déplacer les objets, à laisser le bras les ramasser, à faire fabriquer un objet par la machine, et ce dans cet ordre. La chose que nous pouvons faire est de séparer le déplacement des objets. Lorsque nous arrivons à ce point, nous répartissons la tâche de manière à ce que chaque ligne de convoyeurs isolée ait son propre processus. Chaque processus déplace ensuite les objets sur la ligne de convoyeurs qui lui a été attribuée, de sorte qu’ils se déplacent tous en même temps, c’est-à-dire qu’ils sont traités en parallèle. Si nous prenons soin de ne séparer que les lignes de convoyeurs qui n’interagissent pas avec d’autres, nous pouvons les mettre à jour en toute sécurité de manière autonome. Cette illustration montre comment on gagne en performance. Au lieu de devoir attendre le temps de mise à jour total de toutes les lignes de convoyeurs, le jeu n’a plus qu’à attendre celle qui prend le plus de temps (la n°2 dans ce cas). Cela peut conduire à de grandes améliorations, car en réalité il y a bien plus que trois lignes de convoyeurs séparées. Cette approche est très similaire à la façon dont la logique de mise à jour des fluides a été améliorée, comme indiqué dans le FFF n°271. Cet article du blog donne un aperçu de la manière dont la disposition de la mémoire a été modifiée pour améliorer l’efficacité de la cache, mais ce n’est pas le sujet de cet article. Il y a aussi un fil de discussion Reddit très intéressant de Varen/Raven qui parle de la refonte de Factorio en ayant la logique en multithread à l’esprit dès le départ. Lisez-le pour obtenir des informations techniques supplémentaires sur ce sujet. Au travail maintenant : quelle est la différence en pratique ? Toute cette théorie est bien belle, mais vous vous demandez quel est l’impact réel sur les performances. Eh bien inutile de vous poser ces questions, j’ai apporté des graphiques ! À titre d’avertissement, ces mesures ont été effectuées sur les versions 1.0.0 et 1.1.1 respectivement. J’ai utilisé la console de jeu pour augmenter la vitesse du jeu, ce qui m’a permis d’obtenir un UPS de plus de 60. Les chiffres n’ont pas été mesurés avec des méthodes très rigoureuses, ce qui signifie qu’ils ont une marge d’erreur non négligeable. Il faut également tenir compte du fait que les performances de mise à jour de l’entité ont également été augmentées selon les notes de correctifs. Ceci est également inclus, bien que je ne pense pas que mes mesures soient suffisamment précises pour tirer des conclusions définitives. J’ai comparé trois sauvegardes différentes avec des caractéristiques différentes, bien qu’elles utilisent toutes beaucoup de convoyeurs. On ne peut pas améliorer les performances de celles qui n’existent pas, après tout. Rencontrons nos concurrents, qui sont tous issus de l’étonnant site web FactorioBox qui propose une petite collection de cartes utiles pour la comparaison des performances. Tout d’abord, j’ai testé la base à 10 000 SPM de Stevetrov. Elle utilise des configurations vraiment optimisées en termes de performances, reposant presque entièrement sur des convoyeurs. Aucun train n’est en service, les robots n’étant utilisés que dans des circonstances très spécifiques où ils s’avèrent plus performants que les convoyeurs. Cela en fait un candidat idéal pour montrer l’impact que ce changement peut avoir. L’effet ne sera pas aussi prononcé dans d’autres cas, car les coûts de performance sont davantage répartis sur d’autres éléments comme les trains ou les robots. Comme le montrent ces graphiques, pour notre premier exemple, quelque peu idéalisé, l’amélioration du temps de mise à jour du convoyeur est assez importante puisque nous constatons une amélioration d’environ 150 % ! Sur cette carte, l’amélioration des UPS est d’environ 26 %, ce qui est considérable si l’on considère que seul le code relatif aux convoyeurs a changé. Il est intéressant de noter que le temps de mise à jour des entités a légèrement augmenté, mais cela reste dans la marge d’erreur de notre mesure, et nous ne pouvons donc pas en tirer de conclusions. Ensuite, j’ai testé une base dont la disposition est plus proche de ce que vous ou moi pourrions construire. Elle s’appelle simplement cam6 sans aucune indication quant à son origine. Elle repose principalement sur des convoyeurs, avec quelques trains et robots en plus. Elle produit également de l’électricité à l’aide de réacteurs nucléaires, qui ont tendance à couper une part non négligeable du gâteau des performances. Comme je l’ai dit, elle a tout ce que l’on peut attendre d’une carte habituelle de Factorio, ce qui en fait une bonne représentation de l’impact que vous pouvez attendre sur votre usine. En examinant ces graphiques pour notre carte plus traditionnelle, nous constatons une amélioration des temps de mise à jour des convoyeurs d’environ 100 %, ce qui est un peu moins que sur la mégabase à 10 000 SPM, mais reste une amélioration considérable. L’UPS augmente d’environ 16 %. Là encore, la modification des temps de mise à jour des entités se situe dans la marge d’erreur. Enfin, j’ai jeté un coup d’œil sur un candidat quelque peu inhabituel : une gigantesque carte désordonnée intitulée Besenovsky Pajzel, qui est probablement le nom de son créateur. Elle est décrite comme une “énorme carte (13300x7400 tuiles) avec une production inefficace allant de 2400 à 4000 SPM”. Cette carte utilise donc un mélange de tous ces éléments, la différence la plus significative avec les deux précédentes étant l’utilisation intensive des trains. Ce que nous en attendons, c’est que l’impact des optimisations de la version 1.1 soit moins important, car ce qui a été amélioré est moins pertinent sur cette carte. L’étude de ce dernier ensemble de graphiques pour notre sauvegarde plus désordonnée montre une augmentation des performances des temps de mise à jour des convoyeurs encore plus importante que celle de la mégabase, soit environ 170 %. Cela conduit à une amélioration de 37 % des UPS, qui semble être favorisée par les mises à jour des performances des entités, qui représentent en fait une différence de 38 % sur cette carte. Si nous faisons la moyenne de ces trois critères très approximatifs, nous obtenons une amélioration moyenne de 140 % des performances des convoyeurs, avec une augmentation moyenne de 26 % pour les UPS. Cela n’est pas représentatif de la moyenne de toutes les sauvegardes possibles en utilisation, bien sûr, car nous n’avons pris en compte que ces trois cartes spéciales. Dans l’ensemble, l’amélioration avec la version 1.1 dépend quelque peu de la configuration de votre base, mais c’est une belle amélioration générale. Après tout, peu importe qu’une amélioration particulière des performances ait un effet important ; c’est la somme de toutes les petites améliorations qui font que le jeu tourne plus vite d’un ordre de grandeur. Nous avons étudié cet effet il y a quelques semaines dans le Alt-F4 n°13, et je m’attends à ce que cette base obtienne une amélioration supplémentaire des performances. Contribuer Comme toujours, nous attendons vos contributions pour les Alt-F4, que cela soit par la soumission d’un article ou en aidant pour les traductions. Si vous avez quelque chose d’intéressant en tête que vous souhaitez partager avec la communauté, vous êtes au bon endroit. Si vous n’êtes pas sûr, nous serons heureux de vous aider en discutant structure, contenu et idées. Donc si vous voulez vous impliquer dans les Alt-F4, rejoignez-le Discord pour ne rien rater !">
<link rel="canonical" href="https://alt-f4.blog/fr/ALTF4-15/">
<meta property="og:url" content="https://alt-f4.blog/ALTF4-15/">
<meta property="og:site_name" content="Alternative Friday Factorio Fan Facts">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-11-27T00:00:00+00:00">
<script type="application/ld+json">
{"description":"Cette semaine, alors que la version expérimentale 1.1 vient de sortir, nous nous penchons sur deux des éléments qu’elle introduit. Tout d’abord, Conor_ étudie ce que la nouvelle limite d’arrêt de trains lui permet de faire dans son usine utilisant le mod TSM. Ensuite, Therenas explore ce que signifie la mise à jour des convoyeurs en multithread, à la fois en théorie et en pratique. Attention, vous pourriez bien apprendre quelque chose ! Limites d’arrêt de train Conor_ Quand il a été proposé de parler des changements qu’apporte la version 1.1, il fallait évidement que je parle de la nouvelle fonction de limitation de l’arrêt de trains, car j’adore les trains ! Dans ce qui suit, j’examine quel problème cette fonctionnalité résout, et comment je le traitais auparavant. Une simple erreur d’un Conor_ plus jeune et plus naïf Il y a quelque temps, je construisais l’une de mes premières grandes bases pour essayer de vaincre le mod SpaceX en multipliant par 5 les coûts des recherches (parce que Pourquoi pas ?) lorsque j’ai remarqué des problèmes dans mon réseau de trains spaghetti™. En raison de l’ignorance de ma jeunesse, j’avais décidé que les arrêts pour un matériau donné devaient avoir le même nom, en déployant un grand nombre de trains pour circuler entre ces arrêts afin de s’assurer qu’ils soient tous utilisés. Ce n’était pas une bonne idée. Ce système simple à mettre en œuvre a entraîné des douleurs et des souffrances, comme je n’en avais plus connues depuis mes tentatives de comprendre le traitement du pétrole. Cela avait bien fonctionné pour moi sur de petites bases avec seulement quelques arrêts répartis sur une courte distance, mais à grande échelle, les trains n’allaient tout simplement pas vers les avant-postes plus éloignés. Certains arrêts étaient bloqués et provoquaient des embouteillages, tandis que d’autres étaient déserts. J’ai décidé qu’il devait y avoir une meilleure solution, et comme le bon ingénieur que je suis, j’ai travaillé dur pour rechercher et développer une meilleure solution au problème demandé à Reddit. Quelqu’un connaît-il un mode de transport qui répartit équitablement les trains entre les arrêts de même nom, quelle que soit la différence de distance. Par exemple, tous les arrêts de déchargement du fer sont appelés de la même façon, mais un nombre égal de trains se rendent à chacun des différents arrêts. Does anyone knows of a mod that will equally distribute trains between stops of the same name, irrelevant of the distance difference. E.g. All iron unload stops called one thing but an equal number of trains go to each of the different stops. — Conor_ (Août 2019) Quel beau rêve de puissance j’ai eu là. Au lieu de ce que je demandais, on m’a dirigé à juste titre vers TSM et LTN, puis on m’a dit de poursuivre ma route. Mais avec la version 1.1, les développeurs ont crié depuis les hauteurs, “Nous avons une nouvelle fonctionnalité pour le train !” OK développeurs, je vous écoute… Que sont les limites d’arrêt de train ? La limite d’arrêt de trains, telle que décrite dans le FFF-361, vous permet de régler le nombre de trains à un arrêt donné. Les détails techniques de ce système sont beaucoup plus détaillés dans le FFF (qui vaut certainement la peine d’être lu), mais en résumé, un train ne devrait se rendre à un arrêt que s’il y a de la place pour le recevoir, ce qui est exactement ce que voulait le jeune Conor_. Mais est-ce que cela tient la route par rapport à mon nouvel amour, TSM ? Origine : FFF-361 Qu’est-ce que TSM et pourquoi devrais-je m’en inquiéter ? Train Supply Manager (TSM) est un mod qui permet aux arrêts de trains de demander un train lorsque certaines conditions logiques sont remplies. Un exemple pertinent pour une telle condition serait de demander un train lorsque moins d’un certain nombre de trains sont en route vers l’arrêt. Il vous permet également de faire de la magie logique plus complexe, par exemple en ne demandant un train que lorsqu’il y a assez de matériau pour le remplir réellement, bien que je n’aie jamais utilisé cette fonctionnalité. Le rêve de TSM est de mettre pleinement en œuvre un système logistique basé sur la demande plutôt que sur l’offre, comme c’est le cas pour des configurations plus élémentaires. La stratégie habituelle de l’offre est celle que l’on retrouve dans de nombreuses petites usines où les trains sont remplis à l’avant-poste, puis évacués, pour patienter à la destination. Avec un système de demande, les trains sont toujours prêts à livrer ou à être chargés, et ne sont appelés que lorsque des ressources sont nécessaires. La différence réside dans le choix du moment où les trains sont mis en marche ; dans le cas d’un système basé sur l’offre, le moment est fixé par la vitesse à laquelle les arrêts peuvent remplir les trains et les mettre en route, indépendamment du nombre de ressources dont l’usine a besoin. En passant à un système basé sur la demande, le moment est déterminé par les arrêts de destination, ce qui leur permet de ne demander des trains que lorsqu’ils sont réellement nécessaires. Cela vous permet de réduire massivement le nombre de trains en mouvement sur un réseau donné et de contrôler où les trains attendent pour s’assurer qu’ils ne provoquent pas de congestion. Bien que cela soit également possible avec le jeu de base en utilisant de grandes zones d’attente pour les trains, en planifiant soigneusement où les trains en attente doivent s’arrêter, ce n’est pas très idéal ni pratique. Dans ce système, les trains sont attendus à la fois aux arrêts de récupération et de livraison, ce qui est particulièrement important pour les grandes bases et c’est la raison pour laquelle j’aime tant TSM. &lt;/source&gt; Vidéo de TSM en fonctionnement Dans la vidéo, les arrêts de chargement et de déchargement n’ont jamais eu qu’un seul train arrêté, ce qui permet d’éviter les encombrements. Lorsqu’un arrêt est vide, un train est envoyé du dépôt par TSM pour réapprovisionner l’arrêt qui en a un besoin le plus urgent. Les limites d’arrêt de trains peuvent-elles remplacer TSM ? Pour comprendre quand il faudra utiliser TSM plutôt que la nouvelle fonction de limitation des arrêts de train, j’ai recréé la fonctionnalité de TSM dans le jeu normal en 1.1, sans TSM, avec beaucoup de succès ! &lt;/source&gt; Vidéo de la même installation utilisant les limites d’arrêt de trains Cette vidéo montre la même configuration de trains de cuivre en train de charger et de décharger, toujours avec un seul train aux arrêts de chargement et de déchargement, tandis que les autres attendent au dépôt. La raison pour laquelle ce système fonctionne à merveille et remplace si bien TSM, c’est que les trains attendent à l’arrêt du dépôt jusqu’à ce qu’il y ait de la place dans la gare de chargement ou de déchargement. Si les trains devaient attendre au point de chargement, cela provoquerait des encombrements et limiterait le débit du producteur. L’utilisation des arrêts de dépôt permet aux trains de disposer d’une sorte de “zone d’attente” à l’écart du reste du réseau ferroviaire, le temps qu’ils deviennent à nouveau nécessaires. Comme nous pouvons le voir, l’ensemble de ce système peut être recréé avec la nouvelle fonction du jeu, probablement avec de meilleures performances en raison de son intégration directe au jeu. Cela ne tient même pas compte de la plus grande simplicité de la limite d’arrêt de trains par rapport à la compréhension de TSM, qui a une courbe d’apprentissage assez raide et une documentation qui est loin d’être parfaite. TSM peut encore être utile dans certains cas, par exemple lorsque le joueur souhaite obtenir des informations sur les demandes actuellement non satisfaites que TSM fournit via son interface, bien que personnellement je n’utilise que rarement ces fonctionnalités. Conclusion Il arrive souvent que les développeurs de jeux avec possibilité de mods remarquent une fonctionnalité intéressante et l’implémentent dans le jeu de base. Cela peut être un peu douloureux pour les créateurs de mods car cela rend leur mod pour la plupart obsolète, mais au final, ils ont réussi à améliorer le jeu. Leur mod est maintenant indirectement intégré dans le jeu qu’ils aiment, ce qui signifie que plus de gens peuvent l’utiliser, ce qui est formidable. Je remercie tout particulièrement sorahn du serveur Discord de Factorio d’avoir repéré mes questions et d’avoir fait tout son possible pour m’aider, en réalisant la carte que j’ai modifiée ci-dessus pour illustrer comment TSM peut fonctionner dans la configuration “double requête”, ainsi que pour avoir vérifié l’équilibre mental de mes idées avant que je ne les construise. Cette fonction sera étonnante pour les nouveaux joueurs (comme le Conor_ jeune et naïf) qui pourront ainsi construire plus facilement des réseaux de trains plus vastes et plus élaborés. Elle offre une autre fonction facile à apprendre et difficile à maîtriser, que les joueurs expérimentés pourront utiliser et explorer, tout en aidant les débutants à s’amuser. Améliorations des performances avec la version 1.1 Therenas La dernière version expérimentale de Factorio a apporté de nombreux changements, dont un que je souhaite examiner de plus près aujourd’hui. Il se cache discrètement dans le journal des modifications de la version 1.1.0 et n’a été mentionné dans aucune des éditions des FFF précédant la sortie. Ce n’est que quelques mots : Mise à jour de la logique des convoyeurs en multithread. Je suis ici pour découvrir ce que cela signifie et quel est son impact réel. Comment cette optimisation fonctionne-t-elle sur le plan technique ? Maintenant, vous n’avez peut-être pas la moindre idée de ce que signifie la logique des jeux en multithread. Pourquoi ne pas simplement tout mettre en œuvre en multithread, afin que le jeu puisse tirer parti de tous les processeurs de votre PC ? Eh bien, il s’avère que ce n’est pas si simple. En général, le jeu doit mettre à jour toutes les machines, convoyeurs, tuyaux, etc. à chaque tick. C’est ainsi que le temps progresse réellement dans le jeu, ce qui vous permet de jouer, en premier lieu. L’ordre dans lequel cela se produit est important. D’abord, les convoyeurs déplacent les objets dans la direction du convoyeur, puis un bras en prend un et le met dans une machine, puis cette machine l’utilise pour fabriquer quelque chose. Le problème fondamental que pose le multithread est qu’il ne permet pas de garantir l’ordre dans lequel les choses se déroulent. Dans l’exemple précédent, il se peut que la machine essaie de fabriquer quelque chose avant que le bras n’insère l’objet. Dans ce cas, la machine n’aurait pas pu fonctionner car il lui manquait l’ingrédient. Si l’insertion se faisait en premier, la machine pourrait alors travailler. C’est un problème parce que ce n’est pas déterministe. En fonction de la logique du traitement informatique, la machine peut fabriquer un objet ou non, ce qui brise la simulation. Cet exemple n’est bien sûr qu’une illustration du problème. Les problèmes réels qui apparaissent sont plus compliqués et de nature technique. De plus, les actions que j’ai utilisées comme exemples ne se produisent naturellement pas toutes en un tick pour une machine spécifique ; elles sont une analogie pour illustrer le problème en question. Elles ne correspondent pas nécessairement à la façon dont le jeu organise réellement les choses. Donc, à première vue, il semble qu’on ne puisse pas faire du multithread dans un jeu comme Factorio parce que cela briserait la simulation. Tout dépend de tout, n’est-ce pas ? Eh bien, pas tout à fait. En effet, il y aura toujours des étapes qui devront être exécutées de manière strictement linéaire, mais vous pouvez trouver des parties de l’ensemble qui sont vraiment indépendantes les unes des autres si vous y regardez de plus près. La logique du convoyeur en est une. Quand on y pense, chaque convoyeur n’est pas lié à tous les autres sur la carte. Bien sûr, il y a des réseaux de convoyeurs géants qui sont interconnectés, comme dans un bus principal, mais il y a aussi des lignes de convoyeurs qui ne sont pas du tout reliées entre elles. En fait, il y en a beaucoup, car les trains ou les réseaux de machines ont tendance à briser les lignes de convoyeurs. Dans cette capture d’écran, les convoyeurs bleu et rouge font partie de lignes de convoyeurs distinctes. Remarquez comment elles se faufilent les unes dans les autres, sans jamais vraiment interagir. Remarquez également comment la machine leur permet d’interagir indirectement tout en préservant leur séparation à des fins de multithread. Cela nous permet de paralléliser (c’est-à-dire travailler en multithread) la logique de mise à jour des convoyeurs. Nous devons maintenant être prudents ; cela ne signifie pas que nous pouvons simplement mettre à jour les convoyeurs à n’importe quel moment pendant le tick. Il faut encore passer par les étapes consistant à déplacer les objets, à laisser le bras les ramasser, à faire fabriquer un objet par la machine, et ce dans cet ordre. La chose que nous pouvons faire est de séparer le déplacement des objets. Lorsque nous arrivons à ce point, nous répartissons la tâche de manière à ce que chaque ligne de convoyeurs isolée ait son propre processus. Chaque processus déplace ensuite les objets sur la ligne de convoyeurs qui lui a été attribuée, de sorte qu’ils se déplacent tous en même temps, c’est-à-dire qu’ils sont traités en parallèle. Si nous prenons soin de ne séparer que les lignes de convoyeurs qui n’interagissent pas avec d’autres, nous pouvons les mettre à jour en toute sécurité de manière autonome. Cette illustration montre comment on gagne en performance. Au lieu de devoir attendre le temps de mise à jour total de toutes les lignes de convoyeurs, le jeu n’a plus qu’à attendre celle qui prend le plus de temps (la n°2 dans ce cas). Cela peut conduire à de grandes améliorations, car en réalité il y a bien plus que trois lignes de convoyeurs séparées. Cette approche est très similaire à la façon dont la logique de mise à jour des fluides a été améliorée, comme indiqué dans le FFF n°271. Cet article du blog donne un aperçu de la manière dont la disposition de la mémoire a été modifiée pour améliorer l’efficacité de la cache, mais ce n’est pas le sujet de cet article. Il y a aussi un fil de discussion Reddit très intéressant de Varen/Raven qui parle de la refonte de Factorio en ayant la logique en multithread à l’esprit dès le départ. Lisez-le pour obtenir des informations techniques supplémentaires sur ce sujet. Au travail maintenant : quelle est la différence en pratique ? Toute cette théorie est bien belle, mais vous vous demandez quel est l’impact réel sur les performances. Eh bien inutile de vous poser ces questions, j’ai apporté des graphiques ! À titre d’avertissement, ces mesures ont été effectuées sur les versions 1.0.0 et 1.1.1 respectivement. J’ai utilisé la console de jeu pour augmenter la vitesse du jeu, ce qui m’a permis d’obtenir un UPS de plus de 60. Les chiffres n’ont pas été mesurés avec des méthodes très rigoureuses, ce qui signifie qu’ils ont une marge d’erreur non négligeable. Il faut également tenir compte du fait que les performances de mise à jour de l’entité ont également été augmentées selon les notes de correctifs. Ceci est également inclus, bien que je ne pense pas que mes mesures soient suffisamment précises pour tirer des conclusions définitives. J’ai comparé trois sauvegardes différentes avec des caractéristiques différentes, bien qu’elles utilisent toutes beaucoup de convoyeurs. On ne peut pas améliorer les performances de celles qui n’existent pas, après tout. Rencontrons nos concurrents, qui sont tous issus de l’étonnant site web FactorioBox qui propose une petite collection de cartes utiles pour la comparaison des performances. Tout d’abord, j’ai testé la base à 10 000 SPM de Stevetrov. Elle utilise des configurations vraiment optimisées en termes de performances, reposant presque entièrement sur des convoyeurs. Aucun train n’est en service, les robots n’étant utilisés que dans des circonstances très spécifiques où ils s’avèrent plus performants que les convoyeurs. Cela en fait un candidat idéal pour montrer l’impact que ce changement peut avoir. L’effet ne sera pas aussi prononcé dans d’autres cas, car les coûts de performance sont davantage répartis sur d’autres éléments comme les trains ou les robots. Comme le montrent ces graphiques, pour notre premier exemple, quelque peu idéalisé, l’amélioration du temps de mise à jour du convoyeur est assez importante puisque nous constatons une amélioration d’environ 150 % ! Sur cette carte, l’amélioration des UPS est d’environ 26 %, ce qui est considérable si l’on considère que seul le code relatif aux convoyeurs a changé. Il est intéressant de noter que le temps de mise à jour des entités a légèrement augmenté, mais cela reste dans la marge d’erreur de notre mesure, et nous ne pouvons donc pas en tirer de conclusions. Ensuite, j’ai testé une base dont la disposition est plus proche de ce que vous ou moi pourrions construire. Elle s’appelle simplement cam6 sans aucune indication quant à son origine. Elle repose principalement sur des convoyeurs, avec quelques trains et robots en plus. Elle produit également de l’électricité à l’aide de réacteurs nucléaires, qui ont tendance à couper une part non négligeable du gâteau des performances. Comme je l’ai dit, elle a tout ce que l’on peut attendre d’une carte habituelle de Factorio, ce qui en fait une bonne représentation de l’impact que vous pouvez attendre sur votre usine. En examinant ces graphiques pour notre carte plus traditionnelle, nous constatons une amélioration des temps de mise à jour des convoyeurs d’environ 100 %, ce qui est un peu moins que sur la mégabase à 10 000 SPM, mais reste une amélioration considérable. L’UPS augmente d’environ 16 %. Là encore, la modification des temps de mise à jour des entités se situe dans la marge d’erreur. Enfin, j’ai jeté un coup d’œil sur un candidat quelque peu inhabituel : une gigantesque carte désordonnée intitulée Besenovsky Pajzel, qui est probablement le nom de son créateur. Elle est décrite comme une “énorme carte (13300x7400 tuiles) avec une production inefficace allant de 2400 à 4000 SPM”. Cette carte utilise donc un mélange de tous ces éléments, la différence la plus significative avec les deux précédentes étant l’utilisation intensive des trains. Ce que nous en attendons, c’est que l’impact des optimisations de la version 1.1 soit moins important, car ce qui a été amélioré est moins pertinent sur cette carte. L’étude de ce dernier ensemble de graphiques pour notre sauvegarde plus désordonnée montre une augmentation des performances des temps de mise à jour des convoyeurs encore plus importante que celle de la mégabase, soit environ 170 %. Cela conduit à une amélioration de 37 % des UPS, qui semble être favorisée par les mises à jour des performances des entités, qui représentent en fait une différence de 38 % sur cette carte. Si nous faisons la moyenne de ces trois critères très approximatifs, nous obtenons une amélioration moyenne de 140 % des performances des convoyeurs, avec une augmentation moyenne de 26 % pour les UPS. Cela n’est pas représentatif de la moyenne de toutes les sauvegardes possibles en utilisation, bien sûr, car nous n’avons pris en compte que ces trois cartes spéciales. Dans l’ensemble, l’amélioration avec la version 1.1 dépend quelque peu de la configuration de votre base, mais c’est une belle amélioration générale. Après tout, peu importe qu’une amélioration particulière des performances ait un effet important ; c’est la somme de toutes les petites améliorations qui font que le jeu tourne plus vite d’un ordre de grandeur. Nous avons étudié cet effet il y a quelques semaines dans le Alt-F4 n°13, et je m’attends à ce que cette base obtienne une amélioration supplémentaire des performances. Contribuer Comme toujours, nous attendons vos contributions pour les Alt-F4, que cela soit par la soumission d’un article ou en aidant pour les traductions. Si vous avez quelque chose d’intéressant en tête que vous souhaitez partager avec la communauté, vous êtes au bon endroit. Si vous n’êtes pas sûr, nous serons heureux de vous aider en discutant structure, contenu et idées. Donc si vous voulez vous impliquer dans les Alt-F4, rejoignez-le Discord pour ne rien rater !","@type":"BlogPosting","url":"https://alt-f4.blog/ALTF4-15/","headline":"Alt-F4 #15 - Exploration de la version 1.1","dateModified":"2020-11-27T00:00:00+00:00","datePublished":"2020-11-27T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://alt-f4.blog/ALTF4-15/"},"author":{"@type":"Person","name":"Conor_, Therenas"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
	

	
	  <meta property="og:image" content="https://alt-f4.blog/assets/ALTF4/15/thumbnail.jpg">
	  <meta name="twitter:image" content="https://alt-f4.blog/assets/ALTF4/15/thumbnail.jpg">
	

	<!-- CSS & fonts -->
	<link href="/fr/assets/GLOBAL/css/titillium-web.css" rel="stylesheet">
	<link rel="stylesheet" href="/fr/assets/GLOBAL/css/style.css">
	<link rel="stylesheet" href="/fr/assets/GLOBAL/css/spidertron.css">
	<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.css" rel="stylesheet" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,400italic%7CSignika:700,300,400,600" rel="stylesheet" type="text/css">

	<link href="/fr/assets/GLOBAL/img/favicon.ico" rel="icon" type="image/x-icon">
	<link href="/fr/assets/GLOBAL/img/favicon.ico" rel="shortcut icon" type="image/x-icon">

	<!-- RSS -->
	<link href="/fr/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed">

	<script src="/assets/GLOBAL/js/spidertron.js"></script>
	<script src="/assets/GLOBAL/js/localization.js"></script>
	<script src="/assets/GLOBAL/js/modernizr-webp.js"></script>
	<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
</head>


  <body>
    <!-- Navigation Bar -->
    <nav id="top" class="top-bar">
	<div class="top-bar-inner flex flex-space-between">
		<div class="sites links flex">
			<a href="/fr/" class="sites-current">
				<div id="navbar-logo" role="img" aria-label="Alt-F4 Logo"></div>
			</a>
			<a href="https://discord.gg/AsXAwyV" class="">Discord</a>
			<span class="separator">|</span>
			<a href="https://factorio.com/blog" class="">FFF</a>
		</div>
		<div class="sites links flex hide-tag-line">
			<em>La suite communautaire aux tant appréciés Faits du vendredi sur Factorio</em>
		</div>
		<div class="dropdown flex-end">
			<a class="button flex flex-space-between" href="#">
				<i class="fas fa-language"></i>
			</a>
			<div class="submenu">
				
				<a class="button lang-button" href="/../ALTF4-15/" onclick="setLanguage('en')">en</a>
				
				<a class="button lang-button" href="/cs/ALTF4-15/" onclick="setLanguage('cs')">cs</a>
				
				<a class="button lang-button" href="/de/ALTF4-15/" onclick="setLanguage('de')">de</a>
				
				<a class="button lang-button" href="/es/ALTF4-15/" onclick="setLanguage('es')">es</a>
				
				<a class="button button-green lang-button" href="/fr/ALTF4-15/" onclick="setLanguage('fr')">fr</a>
				
				<a class="button lang-button" href="/it/ALTF4-15/" onclick="setLanguage('it')">it</a>
				
				<a class="button lang-button" href="/nl/ALTF4-15/" onclick="setLanguage('nl')">nl</a>
				
				<a class="button lang-button" href="/ru/ALTF4-15/" onclick="setLanguage('ru')">ru</a>
				
				<a class="button lang-button" href="/zh/ALTF4-15/" onclick="setLanguage('zh')">zh</a>
				
			</div>
		</div>
	</div>
</nav>


    <!-- Main content -->
    <div class="container">
      <div class="container-inner">
        <div class="small-center"></div>
        <!-- Posts -->
        <article class="panel blog-post">
	
	<h1 class="page-title-headder">Alt-F4 #15 - Exploration de la version 1.1  <author>27-11-2020</author>
</h1>
	
	
	<div class="panel-inset mb0">
		
Écrit par <em>Conor_, Therenas</em>,



édité par <em>stringweasel, Nanogamer7, nicgarner, Firerazer</em>,



<br>traduit par <em>bev</em>






	</div>
	
	<div class="panel-inset-lighter mt0">
		<details class="panel toc">
  <summary>
    <h2>Sommaire</h2>
  </summary>
  <div class="panel-inset mb0">
    <ul>
  <li>
<a href="#limites-darr%C3%AAt-de-train-conor_">Limites d’arrêt de train <author>Conor_</author></a>
    <ul>
      <li><a href="#une-simple-erreur-dun-conor_-plus-jeune-et-plus-na%C3%AFf">Une simple erreur d’un Conor_ plus jeune et plus naïf</a></li>
      <li><a href="#que-sont-les-limites-darr%C3%AAt-de-train-">Que sont les limites d’arrêt de train ?</a></li>
      <li><a href="#quest-ce-que-tsm-et-pourquoi-devrais-je-men-inqui%C3%A9ter-">Qu’est-ce que TSM et pourquoi devrais-je m’en inquiéter ?</a></li>
      <li><a href="#les-limites-darr%C3%AAt-de-trains-peuvent-elles-remplacer-tsm-">Les limites d’arrêt de trains peuvent-elles remplacer TSM ?</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
    </ul>
  </li>
  <li>
<a href="#am%C3%A9liorations-des-performances-avec-la-version-11-therenas">Améliorations des performances avec la version 1.1 <author>Therenas</author></a>
    <ul>
      <li><a href="#comment-cette-optimisation-fonctionne-t-elle-sur-le-plan-technique-">Comment cette optimisation fonctionne-t-elle sur le plan technique ?</a></li>
      <li><a href="#au-travail-maintenant--quelle-est-la-diff%C3%A9rence-en-pratique-">Au travail maintenant : quelle est la différence en pratique ?</a></li>
    </ul>
  </li>
  <li><a href="#contribuer">Contribuer</a></li>
</ul>

  </div>
</details>




<p>Cette semaine, alors que la version expérimentale 1.1 vient de sortir, nous nous penchons sur deux des éléments qu’elle introduit. Tout d’abord, Conor_ étudie ce que la nouvelle limite d’arrêt de trains lui permet de faire dans son usine utilisant le mod TSM. Ensuite, Therenas explore ce que signifie la mise à jour des convoyeurs en multithread, à la fois en théorie et en pratique. Attention, vous pourriez bien apprendre quelque chose !</p>
      <h2 id="limites-darrêt-de-train-conor_">
        
        
            <a href="#limites-darr%C3%AAt-de-train-conor_" class="anchor" style="text-decoration: none;">Limites d’arrêt de train <author>Conor_</author></a>
          
        
      </h2>
    

<p>Quand il a été proposé de parler des changements qu’apporte la version 1.1, il fallait évidement que je parle de la nouvelle fonction de limitation de l’arrêt de trains, car <a href="https://alt-f4.blog/fr/ALTF4-8/#jaime-factorio-%C3%A0-cause-des-trains-conor_">j’adore les trains</a> ! Dans ce qui suit, j’examine quel problème cette fonctionnalité résout, et comment je le traitais auparavant.</p>
      <h3 id="une-simple-erreur-dun-conor_-plus-jeune-et-plus-naïf">
        
        
            <a href="#une-simple-erreur-dun-conor_-plus-jeune-et-plus-na%C3%AFf" class="anchor" style="text-decoration: none;">Une simple erreur d’un Conor_ plus jeune et plus naïf</a>
          
        
      </h3>
    

<p>Il y a quelque temps, je construisais l’une de mes premières grandes bases pour essayer de vaincre le mod <a href="https://mods.factorio.com/mod/SpaceMod">SpaceX</a> en multipliant par 5 les coûts des recherches (parce que <em>Pourquoi pas ?</em>) lorsque j’ai remarqué des problèmes dans mon réseau de trains spaghetti™. En raison de l’ignorance de ma jeunesse, j’avais décidé que les arrêts pour un matériau donné devaient avoir le même nom, en déployant un grand nombre de trains pour circuler entre ces arrêts afin de s’assurer qu’ils soient tous utilisés. Ce n’était pas une bonne idée. Ce système simple à mettre en œuvre a entraîné des douleurs et des souffrances, comme je n’en avais plus connues depuis mes tentatives de comprendre le traitement du pétrole. Cela avait bien fonctionné pour moi sur de petites bases avec seulement quelques arrêts répartis sur une courte distance, mais à grande échelle, les trains n’allaient tout simplement pas vers les avant-postes plus éloignés. Certains arrêts étaient bloqués et provoquaient des embouteillages, tandis que d’autres étaient déserts. J’ai décidé qu’il devait y avoir une meilleure solution, et comme le bon ingénieur que je suis, j’ai <del>travaillé dur pour rechercher et développer une meilleure solution au problème</del> demandé à <a href="https://www.reddit.com/r/factorio/comments/creeix/train_distribution_mod/">Reddit</a>.</p>

<div class="m0 h100 flex flex-column flex-center quote">
  <blockquote cite="">
    <div class="panel-inset-lighter">
      
        <div class="translation">
          <p>Quelqu’un connaît-il un mode de transport qui répartit équitablement les trains entre les arrêts de même nom, quelle que soit la différence de distance. Par exemple, tous les arrêts de déchargement du fer sont appelés de la même façon, mais un nombre égal de trains se rendent à chacun des différents arrêts.</p>

        </div>
<hr>
      
      <p>Does anyone knows of a mod that will equally distribute trains between stops of the same name, irrelevant of the distance difference. E.g. All iron unload stops called one thing but an equal number of trains go to each of the different stops.</p>

      <author>
      — Conor_ (Août 2019)
      </author>
    </div>
  </blockquote>
</div>

<p>Quel beau rêve de puissance j’ai eu là. Au lieu de ce que je demandais, on m’a dirigé à juste titre vers <a href="https://mods.factorio.com/mod/train-pubsub">TSM</a> et <a href="https://mods.factorio.com/mods/Optera/LogisticTrainNetwork">LTN</a>, puis on m’a dit de poursuivre ma route. Mais avec la version 1.1, les développeurs ont crié depuis les hauteurs, <strong>“Nous avons une nouvelle fonctionnalité pour le train !”</strong> OK développeurs, je vous écoute…</p>
      <h3 id="que-sont-les-limites-darrêt-de-train-">
        
        
            <a href="#que-sont-les-limites-darr%C3%AAt-de-train-" class="anchor" style="text-decoration: none;">Que sont les limites d’arrêt de train ?</a>
          
        
      </h3>
    

<p>La limite d’arrêt de trains, telle que décrite dans le <a href="https://factorio.com/blog/post/fff-361">FFF-361</a>, vous permet de régler le nombre de trains à un arrêt donné. Les détails techniques de ce système sont beaucoup plus détaillés dans le FFF (qui vaut certainement la peine d’être lu), mais en résumé, un train ne devrait se rendre à un arrêt que s’il y a de la place pour le recevoir, ce qui est exactement ce que voulait le jeune Conor_. Mais est-ce que cela tient la route par rapport à mon nouvel amour, TSM ?</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    <figure>
      <img src="https://cdn.factorio.com/assets/img/blog/fff-361-train-stop-limit.png" alt="Interface graphique pour la limitation de l’arrêt de trains" style="max-width: ; max-height: ">
      
      <figcaption>Origine : <a href="https://www.factorio.com/blog/post/fff-361">FFF-361</a></figcaption>
    </figure>
    
    
</div>
<p></p>
<p><!-- Spacing --></p>
      <h3 id="quest-ce-que-tsm-et-pourquoi-devrais-je-men-inquiéter-">
        
        
            <a href="#quest-ce-que-tsm-et-pourquoi-devrais-je-men-inqui%C3%A9ter-" class="anchor" style="text-decoration: none;">Qu’est-ce que TSM et pourquoi devrais-je m’en inquiéter ?</a>
          
        
      </h3>
    

<p>Train Supply Manager (TSM) est un mod qui permet aux arrêts de trains de demander un train lorsque certaines conditions logiques sont remplies. Un exemple pertinent pour une telle condition serait de demander un train lorsque moins d’un certain nombre de trains sont en route vers l’arrêt. Il vous permet également de faire de la magie logique plus complexe, par exemple en ne demandant un train que lorsqu’il y a assez de matériau pour le remplir réellement, bien que je n’aie jamais utilisé cette fonctionnalité.</p>

<p>Le rêve de TSM est de mettre pleinement en œuvre un système logistique basé sur <a href="https://en.wikipedia.org/wiki/Push%E2%80%93pull_strategy">la demande</a> plutôt que sur l’offre, comme c’est le cas pour des configurations plus élémentaires. La stratégie habituelle de l’offre est celle que l’on retrouve dans de nombreuses petites usines où les trains sont remplis à l’avant-poste, puis évacués, pour patienter à la destination. Avec un système de demande, les trains sont toujours prêts à livrer ou à être chargés, et ne sont appelés que lorsque des ressources sont nécessaires.</p>

<p>La différence réside dans le choix du moment où les trains sont mis en marche ; dans le cas d’un système basé sur l’offre, le moment est fixé par la vitesse à laquelle les arrêts peuvent remplir les trains et les mettre en route, indépendamment du nombre de ressources dont l’usine a besoin. En passant à un système basé sur la demande, le moment est déterminé par les arrêts de destination, ce qui leur permet de ne demander des trains que lorsqu’ils sont réellement nécessaires. Cela vous permet de réduire massivement le nombre de trains en mouvement sur un réseau donné et de contrôler où les trains attendent pour s’assurer qu’ils ne provoquent pas de congestion. Bien que cela soit également possible avec le jeu de base en utilisant de grandes zones d’attente pour les trains, en planifiant soigneusement où les trains en attente doivent s’arrêter, ce n’est pas très idéal ni pratique. Dans ce système, les trains sont attendus à la fois aux arrêts de récupération et de livraison, ce qui est particulièrement important pour les grandes bases et c’est la raison pour laquelle j’aime tant TSM.</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 1000px; max-height: 900px" playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/15/TSL-Video-1.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Vidéo de TSM en fonctionnement
    </video>
    <figcaption>Dans la vidéo, les arrêts de chargement et de déchargement n’ont jamais eu qu’un seul train arrêté, ce qui permet d’éviter les encombrements. Lorsqu’un arrêt est vide, un train est envoyé du dépôt par TSM pour réapprovisionner l’arrêt qui en a un besoin le plus urgent.</figcaption>
  </figure>
  </p>
      <h3 id="les-limites-darrêt-de-trains-peuvent-elles-remplacer-tsm-">
        
        
            <a href="#les-limites-darr%C3%AAt-de-trains-peuvent-elles-remplacer-tsm-" class="anchor" style="text-decoration: none;">Les limites d’arrêt de trains peuvent-elles remplacer TSM ?</a>
          
        
      </h3>
    

<p>Pour comprendre quand il faudra utiliser TSM plutôt que la nouvelle fonction de limitation des arrêts de train, j’ai recréé la fonctionnalité de TSM dans le jeu normal en 1.1, sans TSM, avec <a href="https://www.youtube.com/watch?v=J88-RdWnNT0">beaucoup de succès</a> !</p>

<p>
  <figure>
    <video class="media" width="100%" height="100%" style="max-width: 1000px; max-height: 900px" playsinline="" autoplay="" muted="" loop="" controls="">
      <source src="https://media.alt-f4.blog/ALTF4/15/TSL-Video-2.mp4" type="video/mp4"></source>
      &lt;/source&gt;
      <!-- <source src="movie.ogg" type="video/webm"> -->
      <!-- <source src="movie.ogg" type="video/ogg"> -->
      Vidéo de la même installation utilisant les limites d’arrêt de trains
    </video>
    <figcaption>Cette vidéo montre la même configuration de trains de cuivre en train de charger et de décharger, toujours avec un seul train aux arrêts de chargement et de déchargement, tandis que les autres attendent au dépôt.</figcaption>
  </figure>
  </p>

<p>La raison pour laquelle ce système fonctionne à merveille et remplace si bien TSM, c’est que les trains attendent à l’arrêt du dépôt jusqu’à ce qu’il y ait de la place dans la gare de chargement ou de déchargement. Si les trains devaient attendre au point de chargement, cela provoquerait des encombrements et limiterait le débit du producteur. L’utilisation des arrêts de dépôt permet aux trains de disposer d’une sorte de “zone d’attente” à l’écart du reste du réseau ferroviaire, le temps qu’ils deviennent à nouveau nécessaires.</p>

<p>Comme nous pouvons le voir, l’ensemble de ce système peut être recréé avec la nouvelle fonction du jeu, probablement avec de meilleures performances en raison de son intégration directe au jeu. Cela ne tient même pas compte de la plus grande simplicité de la limite d’arrêt de trains par rapport à la compréhension de TSM, qui a une courbe d’apprentissage assez raide et une documentation qui est loin d’être parfaite. TSM peut encore être utile dans certains cas, par exemple lorsque le joueur souhaite obtenir des informations sur les demandes actuellement non satisfaites que TSM fournit via son interface, bien que personnellement je n’utilise que rarement ces fonctionnalités.</p>
      <h3 id="conclusion">
        
        
            <a href="#conclusion" class="anchor" style="text-decoration: none;">Conclusion</a>
          
        
      </h3>
    

<p>Il arrive souvent que les développeurs de jeux avec possibilité de mods remarquent une fonctionnalité intéressante et l’implémentent dans le jeu de base. Cela peut être un peu douloureux pour les créateurs de mods car cela rend leur mod pour la plupart obsolète, mais au final, ils ont réussi à améliorer le jeu. Leur mod est maintenant indirectement intégré dans le jeu qu’ils aiment, ce qui signifie que plus de gens peuvent l’utiliser, ce qui est formidable.</p>

<p>Je remercie tout particulièrement sorahn du <a href="https://discord.com/invite/factorio">serveur Discord de Factorio</a> d’avoir repéré mes questions et d’avoir fait tout son possible pour m’aider, en réalisant la carte que j’ai modifiée ci-dessus pour illustrer comment TSM peut fonctionner dans la configuration “double requête”, ainsi que pour avoir vérifié l’équilibre mental de mes idées avant que je ne les construise.</p>

<p>Cette fonction sera étonnante pour les nouveaux joueurs (comme le Conor_ jeune et naïf) qui pourront ainsi construire plus facilement des réseaux de trains plus vastes et plus élaborés. Elle offre une autre fonction facile à apprendre et difficile à maîtriser, que les joueurs expérimentés pourront utiliser et explorer, tout en aidant les débutants à s’amuser.</p>
      <h2 id="améliorations-des-performances-avec-la-version-11-therenas">
        
        
            <a href="#am%C3%A9liorations-des-performances-avec-la-version-11-therenas" class="anchor" style="text-decoration: none;">Améliorations des performances avec la version 1.1 <author>Therenas</author></a>
          
        
      </h2>
    

<p>La dernière version expérimentale de Factorio a apporté de nombreux changements, dont un que je souhaite examiner de plus près aujourd’hui. Il se cache discrètement dans le <a href="https://forums.factorio.com/viewtopic.php?p=521942#p521942">journal des modifications de la version 1.1.0</a> et n’a été mentionné dans aucune des éditions des <a href="https://factorio.com/blog/">FFF</a> précédant la sortie. Ce n’est que quelques mots : Mise à jour de la logique des convoyeurs en multithread. Je suis ici pour découvrir ce que cela signifie et quel est son impact réel.</p>
      <h3 id="comment-cette-optimisation-fonctionne-t-elle-sur-le-plan-technique-">
        
        
            <a href="#comment-cette-optimisation-fonctionne-t-elle-sur-le-plan-technique-" class="anchor" style="text-decoration: none;">Comment cette optimisation fonctionne-t-elle sur le plan technique ?</a>
          
        
      </h3>
    

<p>Maintenant, vous n’avez peut-être pas la moindre idée de ce que signifie la logique des jeux en multithread. Pourquoi ne pas simplement tout mettre en œuvre en multithread, afin que le jeu puisse tirer parti de tous les processeurs de votre PC ? Eh bien, il s’avère que ce n’est pas si simple. En général, le jeu doit mettre à jour toutes les machines, convoyeurs, tuyaux, etc. à chaque tick. C’est ainsi que le temps progresse réellement dans le jeu, ce qui vous permet de jouer, en premier lieu. L’ordre dans lequel cela se produit est important. D’abord, les convoyeurs déplacent les objets dans la direction du convoyeur, puis un bras en prend un et le met dans une machine, puis cette machine l’utilise pour fabriquer quelque chose.</p>

<p>Le problème fondamental que pose le multithread est qu’il ne permet pas de garantir l’ordre dans lequel les choses se déroulent. Dans l’exemple précédent, il se peut que la machine essaie de fabriquer quelque chose avant que le bras n’insère l’objet. Dans ce cas, la machine n’aurait pas pu fonctionner car il lui manquait l’ingrédient. Si l’insertion se faisait en premier, la machine pourrait alors travailler. C’est un problème parce que ce n’est pas déterministe. En fonction de la logique du traitement informatique, la machine peut fabriquer un objet ou non, ce qui brise la simulation.</p>

<p>Cet exemple n’est bien sûr qu’une illustration du problème. Les problèmes réels qui apparaissent sont plus compliqués et de nature technique. De plus, les actions que j’ai utilisées comme exemples ne se produisent naturellement pas toutes en un tick pour une machine spécifique ; elles sont une analogie pour illustrer le problème en question. Elles ne correspondent pas nécessairement à la façon dont le jeu organise réellement les choses.</p>

<p>Donc, à première vue, il semble qu’on ne puisse pas faire du multithread dans un jeu comme Factorio parce que cela briserait la simulation. Tout dépend de tout, n’est-ce pas ? Eh bien, pas tout à fait. En effet, il y aura toujours des étapes qui devront être exécutées de manière strictement linéaire, mais vous pouvez trouver des parties de l’ensemble qui sont vraiment indépendantes les unes des autres si vous y regardez de plus près. La logique du convoyeur en est une.</p>

<p>Quand on y pense, chaque convoyeur n’est pas lié à tous les autres sur la carte. Bien sûr, il y a des réseaux de convoyeurs géants qui sont interconnectés, comme dans un <a href="https://wiki.factorio.com/Tutorial:Main_bus">bus principal</a>, mais il y a aussi des lignes de convoyeurs qui ne sont pas du tout reliées entre elles. En fait, il y en a beaucoup, car les trains ou les réseaux de machines ont tendance à briser les lignes de convoyeurs.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    <figure>
      <img src="https://media.alt-f4.blog/ALTF4/15/beltlines.jpg" alt="Capture d’écran de deux lignes distinctes de convoyeurs entrelacées" style="max-width: ; max-height: ">
      
      <figcaption>Dans cette capture d’écran, les convoyeurs bleu et rouge font partie de lignes de convoyeurs distinctes. Remarquez comment elles se faufilent les unes dans les autres, sans jamais vraiment interagir. Remarquez également comment la machine leur permet d’interagir indirectement tout en préservant leur séparation à des fins de multithread.</figcaption>
    </figure>
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Cela nous permet de paralléliser (c’est-à-dire travailler en multithread) la logique de mise à jour des convoyeurs. Nous devons maintenant être prudents ; cela ne signifie pas que nous pouvons simplement mettre à jour les convoyeurs à n’importe quel moment pendant le tick. Il faut encore passer par les étapes consistant à déplacer les objets, à laisser le bras les ramasser, à faire fabriquer un objet par la machine, et ce dans cet ordre. La chose que nous pouvons faire est de séparer le déplacement des objets. Lorsque nous arrivons à ce point, nous répartissons la tâche de manière à ce que chaque ligne de convoyeurs isolée ait son propre processus. Chaque processus déplace ensuite les objets sur la ligne de convoyeurs qui lui a été attribuée, de sorte qu’ils se déplacent tous en même temps, c’est-à-dire qu’ils sont traités en parallèle. Si nous prenons soin de ne séparer que les lignes de convoyeurs qui n’interagissent pas avec d’autres, nous pouvons les mettre à jour en toute sécurité de manière autonome.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    <figure>
      <img src="https://media.alt-f4.blog/ALTF4/15/multithreading_illustration.jpg" alt="Illustration de la partie pertinente du processus de mise à jour du jeu" style="max-width: ; max-height: ">
      
      <figcaption>Cette illustration montre comment on gagne en performance. Au lieu de devoir attendre le temps de mise à jour total de toutes les lignes de convoyeurs, le jeu n’a plus qu’à attendre celle qui prend le plus de temps (la n°2 dans ce cas). Cela peut conduire à de grandes améliorations, car en réalité il y a bien plus que trois lignes de convoyeurs séparées.</figcaption>
    </figure>
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Cette approche est très similaire à la façon dont la logique de mise à jour des fluides a été améliorée, comme indiqué dans le <a href="https://factorio.com/blog/post/fff-271">FFF n°271</a>. Cet article du blog donne un aperçu de la manière dont la disposition de la mémoire a été modifiée pour améliorer l’efficacité de la cache, mais ce n’est pas le sujet de cet article. Il y a aussi un <a href="https://www.reddit.com/r/factorio/comments/jizq1b/i_programmed_factorio_from_scratch_multithreaded/">fil de discussion Reddit</a> très intéressant de Varen/Raven qui parle de la refonte de Factorio en ayant la logique en multithread à l’esprit dès le départ. Lisez-le pour obtenir des informations techniques supplémentaires sur ce sujet.</p>
      <h3 id="au-travail-maintenant--quelle-est-la-différence-en-pratique-">
        
        
            <a href="#au-travail-maintenant--quelle-est-la-diff%C3%A9rence-en-pratique-" class="anchor" style="text-decoration: none;">Au travail maintenant : quelle est la différence en pratique ?</a>
          
        
      </h3>
    

<p>Toute cette théorie est bien belle, mais vous vous demandez quel est l’impact réel sur les performances. Eh bien inutile de vous poser ces questions, j’ai apporté des graphiques !</p>

<p>À titre d’avertissement, ces mesures ont été effectuées sur les versions 1.0.0 et 1.1.1 respectivement. J’ai utilisé la console de jeu pour augmenter la vitesse du jeu, ce qui m’a permis d’obtenir un <a href="https://www.reddit.com/r/factorio/comments/5dmura/can_someone_explain_ups/">UPS</a> de plus de 60. Les chiffres n’ont pas été mesurés avec des méthodes très rigoureuses, ce qui signifie qu’ils ont une marge d’erreur non négligeable. Il faut également tenir compte du fait que les performances de mise à jour de l’entité ont également été augmentées selon les notes de correctifs. Ceci est également inclus, bien que je ne pense pas que mes mesures soient suffisamment précises pour tirer des conclusions définitives.</p>

<p>J’ai comparé trois sauvegardes différentes avec des caractéristiques différentes, bien qu’elles utilisent toutes beaucoup de convoyeurs. On ne peut pas améliorer les performances de celles qui n’existent pas, après tout. Rencontrons nos concurrents, qui sont tous issus de l’étonnant site web <a href="https://factoriobox.1au.us">FactorioBox</a> qui propose une petite collection de cartes utiles pour la comparaison des performances.</p>

<p>Tout d’abord, j’ai testé la <a href="https://www.reddit.com/r/factorio/comments/bdkrwz/10k_spm_belt_megabase_benchmarked_83ups_with_way/">base à 10 000 SPM de Stevetrov</a>. Elle utilise des configurations vraiment optimisées en termes de performances, reposant presque entièrement sur des convoyeurs. Aucun train n’est en service, les robots n’étant utilisés que dans des circonstances très spécifiques où ils s’avèrent plus performants que les convoyeurs. Cela en fait un candidat idéal pour montrer l’impact que ce changement peut avoir. L’effet ne sera pas aussi prononcé dans d’autres cas, car les coûts de performance sont davantage répartis sur d’autres éléments comme les trains ou les robots.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    <figure>
      <img id="desktop" src="https://media.alt-f4.blog/ALTF4/15/graph1-wide.jpg" alt="Graphique illustrant diverses mesures de performance pour les versions 1.0 et 1.1" style="max-width: ; max-height: 600px">
      <img id="mobile" src="https://media.alt-f4.blog/ALTF4/15/graph1.jpg" alt="Graphique illustrant diverses mesures de performance pour les versions 1.0 et 1.1" style="max-width: ; max-height: 600px">
      <figcaption>Comme le montrent ces graphiques, pour notre premier exemple, quelque peu idéalisé, l’amélioration du temps de mise à jour du convoyeur est assez importante puisque nous constatons une amélioration d’environ 150 % ! Sur cette carte, l’amélioration des UPS est d’environ 26 %, ce qui est considérable si l’on considère que seul le code relatif aux convoyeurs a changé. Il est intéressant de noter que le temps de mise à jour des entités a légèrement augmenté, mais cela reste dans la marge d’erreur de notre mesure, et nous ne pouvons donc pas en tirer de conclusions.</figcaption>
    </figure>
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Ensuite, j’ai testé une base dont la disposition est plus proche de ce que vous ou moi pourrions construire. Elle s’appelle simplement <a href="https://factoriobox.1au.us/map/info/da5d1a5a8c66638254f5ddaa1d90f1084ba2b00f28888abc83e5bfef4d3b4cd1">cam6</a> sans aucune indication quant à son origine. Elle repose principalement sur des convoyeurs, avec quelques trains et robots en plus. Elle produit également de l’électricité à l’aide de réacteurs nucléaires, qui ont tendance à couper une part non négligeable du gâteau des performances. Comme je l’ai dit, elle a tout ce que l’on peut attendre d’une carte habituelle de Factorio, ce qui en fait une bonne représentation de l’impact que vous pouvez attendre sur votre usine.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    <figure>
      <img id="desktop" src="https://media.alt-f4.blog/ALTF4/15/graph2-wide.jpg" alt="Graphique illustrant diverses mesures de performance pour les versions 1.0 et 1.1" style="max-width: ; max-height: 600px">
      <img id="mobile" src="https://media.alt-f4.blog/ALTF4/15/graph2.jpg" alt="Graphique illustrant diverses mesures de performance pour les versions 1.0 et 1.1" style="max-width: ; max-height: 600px">
      <figcaption>En examinant ces graphiques pour notre carte plus traditionnelle, nous constatons une amélioration des temps de mise à jour des convoyeurs d’environ 100 %, ce qui est un peu moins que sur la mégabase à 10 000 SPM, mais reste une amélioration considérable. L’UPS augmente d’environ 16 %. Là encore, la modification des temps de mise à jour des entités se situe dans la marge d’erreur.</figcaption>
    </figure>
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Enfin, j’ai jeté un coup d’œil sur un candidat quelque peu inhabituel : une gigantesque carte désordonnée intitulée <a href="https://factoriobox.1au.us/map/info/06fde508f4db1afd18ae17903af1dd830a50ecf7af342afef3df99ee00c3b6bc">Besenovsky Pajzel</a>, qui est probablement le nom de son créateur. Elle est décrite comme une “énorme carte (13300x7400 tuiles) avec une production inefficace allant de 2400 à 4000 SPM”. Cette carte utilise donc un mélange de tous ces éléments, la différence la plus significative avec les deux précédentes étant l’utilisation intensive des trains. Ce que nous en attendons, c’est que l’impact des optimisations de la version 1.1 soit moins important, car ce qui a été amélioré est moins pertinent sur cette carte.</p>

<p></p>
<p><!-- Spacing --></p>
<div class="image">
  
    <figure>
      <img id="desktop" src="https://media.alt-f4.blog/ALTF4/15/graph3-wide.jpg" alt="Graphique illustrant diverses mesures de performance pour les versions 1.0 et 1.1" style="max-width: ; max-height: 600px">
      <img id="mobile" src="https://media.alt-f4.blog/ALTF4/15/graph3.jpg" alt="Graphique illustrant diverses mesures de performance pour les versions 1.0 et 1.1" style="max-width: ; max-height: 600px">
      <figcaption>L’étude de ce dernier ensemble de graphiques pour notre sauvegarde plus désordonnée montre une augmentation des performances des temps de mise à jour des convoyeurs encore plus importante que celle de la mégabase, soit environ 170 %. Cela conduit à une amélioration de 37 % des UPS, qui semble être favorisée par les mises à jour des performances des entités, qui représentent en fait une différence de 38 % sur cette carte.</figcaption>
    </figure>
    
    
</div>
<p></p>
<p><!-- Spacing --></p>

<p>Si nous faisons la moyenne de ces trois critères très approximatifs, nous obtenons une amélioration moyenne de 140 % des performances des convoyeurs, avec une augmentation moyenne de 26 % pour les UPS. Cela n’est pas représentatif de la moyenne de toutes les sauvegardes possibles en utilisation, bien sûr, car nous n’avons pris en compte que ces trois cartes spéciales. Dans l’ensemble, l’amélioration avec la version 1.1 dépend quelque peu de la configuration de votre base, mais c’est une belle amélioration générale.</p>

<p>Après tout, peu importe qu’une amélioration particulière des performances ait un effet important ; c’est la somme de toutes les petites améliorations qui font que le jeu tourne plus vite d’un ordre de grandeur. Nous avons étudié cet effet il y a quelques semaines dans le <a href="https://alt-f4.blog/fr/ALTF4-13/#faire-tourner-lusine-en-10">Alt-F4 n°13</a>, et je m’attends à ce que cette base obtienne une amélioration supplémentaire des performances.</p>
      <h2 id="contribuer">
        
        
            <a href="#contribuer" class="anchor" style="text-decoration: none;">Contribuer</a>
          
        
      </h2>
    

<p>Comme toujours, nous attendons vos contributions pour les Alt-F4, que cela soit par la soumission d’un article ou en aidant pour les traductions. Si vous avez quelque chose d’intéressant en tête que vous souhaitez partager avec la communauté, vous êtes au bon endroit. Si vous n’êtes pas sûr, nous serons heureux de vous aider en discutant structure, contenu et idées. Donc si vous voulez vous impliquer dans les Alt-F4, rejoignez-le <a href="https://discord.gg/nxnCFkb">Discord</a> pour ne rien rater !</p>





<script>
  (() => {
    if (window.innerWidth >= 1920) {
      document.getElementsByClassName('toc')[0].setAttribute('open', '')
    }
  })()
</script>

		
<div class="flex flex-column flex-items-center mt8">
  
  <a class="button-green-right m4" style="width: 16em;" href="https://forums.factorio.com/viewtopic.php?f=5&t=92074">
    Discuter sur les forums de Factorio
  </a>
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://www.reddit.com/r/factorio/comments/k20lpm/altf4_15_investigating_11/">
    Discuter sur Reddit
  </a>
  
  
  <a class="button-green-right m4" style="width: 16em;" href="https://discord.gg/ceKebbY">
    Discuter sur Discord
  </a>
  
</div>


	</div>
	<div class="panel-inset mb0 p4 flex">
		<div>
		<!-- Previous Button -->
		
		<a href="/fr/ALTF4-14/" class="button square-sm"><i class="fas fa-angle-double-left"></i></a>
		
		<a class="button square-sm" href="/fr/">
			<i class="fas fa-home"></i>
		</a>

		<!-- Next Button -->
		
		<a href="/fr/ALTF4-16/" class="button square-sm">
			<i class="fas fa-angle-double-right"></i>
		</a>
		
		</div>
	</div>
</article>

      </div>
    </div>


    <!-- Footer -->
    <footer class="footer">
  <div class="footer-inner panel">

    <div class="footer-links panel-inset slots p1 mt0 mb0">
      <a href="/fr/about" class="slot" title="About">
        <div class="slot-button">
          <i class="fas fa-info"></i>
        </div>
      </a>
      <a href="https://github.com/AlternativeFFFF/Alt-F4" class="slot" title="Github">
        <div class="slot-button">
          <i class="fab fa-github"></i>
        </div>
      </a>
      <a href="https://discord.gg/ceKebbY" class="slot" title="Discord">
        <div class="slot-button">
          <i class="fab fa-discord"></i>
        </div>
      </a>
      <a href="/fr/atom.xml" type="application/atom+xml" rel="alternate" class="slot" title="ATOM Feed">
        <div class="slot-button">
          <i class="fas fa-rss"></i>
        </div>
      </a>


      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
      <div class="slot">
        <div class="slot-empty"></div>
      </div>
    </div>
    <div class="footer-rocket panel-inset m0">
      <div class="spidertron-center">
        <div id="spidertron" class="spidertron-home" data-spidertron-scale="0.6" data-spidertron-speed="400"></div>
      </div>
      <div class="shadow-overlay"></div>
      <div class="shadow-overlay-bottom"></div>
    </div>
    <div class="footer-copyright panel-inset m0">
      Ce site internet est un projet proposé par les fans et n'est pas directement affilié à Wube Software
    </div>
  </div>
</footer>

  </body>

</html>
